{"ast":null,"code":"import _objectSpread from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.anchor.js\";\nimport \"core-js/modules/es.array.concat.js\";\n// Composables\nimport { useToggleScope } from \"../../composables/toggleScope.js\"; // Utilities\n\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue';\nimport { anchorToPoint, getOffset } from \"./util/point.js\";\nimport { clamp, consoleError, convertToUnit, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \"../../util/index.js\";\nimport { Box, getOverflow, getTargetBox } from \"../../util/box.js\"; // Types\n\nvar locationStrategies = {\n  static: staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy // connected to a certain element\n\n};\nexport var makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    default: 'static',\n    validator: function validator(val) {\n      return typeof val === 'function' || val in locationStrategies;\n    }\n  },\n  location: {\n    type: String,\n    default: 'bottom'\n  },\n  origin: {\n    type: String,\n    default: 'auto'\n  },\n  offset: [Number, String, Array]\n}, 'VOverlay-location-strategies');\nexport function useLocationStrategies(props, data) {\n  var contentStyles = ref({});\n  var updateLocation = ref();\n\n  if (IN_BROWSER) {\n    useToggleScope(function () {\n      return !!(data.isActive.value && props.locationStrategy);\n    }, function (reset) {\n      watch(function () {\n        return props.locationStrategy;\n      }, reset);\n      onScopeDispose(function () {\n        window.removeEventListener('resize', onResize);\n        updateLocation.value = undefined;\n      });\n      window.addEventListener('resize', onResize, {\n        passive: true\n      });\n\n      if (typeof props.locationStrategy === 'function') {\n        var _props$locationStrate;\n\n        updateLocation.value = (_props$locationStrate = props.locationStrategy(data, props, contentStyles)) === null || _props$locationStrate === void 0 ? void 0 : _props$locationStrate.updateLocation;\n      } else {\n        var _locationStrategies$p;\n\n        updateLocation.value = (_locationStrategies$p = locationStrategies[props.locationStrategy](data, props, contentStyles)) === null || _locationStrategies$p === void 0 ? void 0 : _locationStrategies$p.updateLocation;\n      }\n    });\n  }\n\n  function onResize(e) {\n    var _updateLocation$value;\n\n    (_updateLocation$value = updateLocation.value) === null || _updateLocation$value === void 0 ? void 0 : _updateLocation$value.call(updateLocation, e);\n  }\n\n  return {\n    contentStyles: contentStyles,\n    updateLocation: updateLocation\n  };\n}\n\nfunction staticLocationStrategy() {// TODO\n}\n/** Get size of element ignoring max-width/max-height */\n\n\nfunction getIntrinsicSize(el, isRtl) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  var contentBox = nullifyTransforms(el);\n\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0);\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0);\n  }\n\n  contentBox.y -= parseFloat(el.style.top || 0); // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox;\n}\n\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  var activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);\n\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, _defineProperty({\n      position: 'fixed',\n      top: 0\n    }, data.isRtl.value ? 'right' : 'left', 0));\n  }\n\n  var _destructComputed = destructComputed(function () {\n    var parsedAnchor = parseAnchor(props.location, data.isRtl.value);\n    var parsedOrigin = props.origin === 'overlap' ? parsedAnchor : props.origin === 'auto' ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value); // Some combinations of props may produce an invalid origin\n\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin)\n      };\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin\n      };\n    }\n  }),\n      preferredAnchor = _destructComputed.preferredAnchor,\n      preferredOrigin = _destructComputed.preferredOrigin;\n\n  var _map = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map(function (key) {\n    return computed(function () {\n      var val = parseFloat(props[key]);\n      return isNaN(val) ? Infinity : val;\n    });\n  }),\n      _map2 = _slicedToArray(_map, 4),\n      minWidth = _map2[0],\n      minHeight = _map2[1],\n      maxWidth = _map2[2],\n      maxHeight = _map2[3];\n\n  var offset = computed(function () {\n    if (Array.isArray(props.offset)) {\n      return props.offset;\n    }\n\n    if (typeof props.offset === 'string') {\n      var _offset = props.offset.split(' ').map(parseFloat);\n\n      if (_offset.length < 2) _offset.push(0);\n      return _offset;\n    }\n\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0];\n  });\n  var observe = false;\n  var observer = new ResizeObserver(function () {\n    if (observe) updateLocation();\n  });\n  watch([data.target, data.contentEl], function (_ref, _ref2) {\n    var _ref3 = _slicedToArray(_ref, 2),\n        newTarget = _ref3[0],\n        newContentEl = _ref3[1];\n\n    var _ref4 = _slicedToArray(_ref2, 2),\n        oldTarget = _ref4[0],\n        oldContentEl = _ref4[1];\n\n    if (oldTarget && !Array.isArray(oldTarget)) observer.unobserve(oldTarget);\n    if (newTarget && !Array.isArray(newTarget)) observer.observe(newTarget);\n    if (oldContentEl) observer.unobserve(oldContentEl);\n    if (newContentEl) observer.observe(newContentEl);\n  }, {\n    immediate: true\n  });\n  onScopeDispose(function () {\n    observer.disconnect();\n  }); // eslint-disable-next-line max-statements\n\n  function updateLocation() {\n    observe = false;\n    requestAnimationFrame(function () {\n      return observe = true;\n    });\n    if (!data.target.value || !data.contentEl.value) return;\n    var targetBox = getTargetBox(data.target.value);\n    var contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);\n    var scrollParents = getScrollParents(data.contentEl.value);\n    var viewportMargin = 12;\n\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement);\n\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0);\n        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0);\n      }\n    }\n\n    var viewport = scrollParents.reduce(function (box, el) {\n      var rect = el.getBoundingClientRect();\n      var scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight\n      });\n\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\n        });\n      }\n\n      return scrollBox;\n    }, undefined);\n    viewport.x += viewportMargin;\n    viewport.y += viewportMargin;\n    viewport.width -= viewportMargin * 2;\n    viewport.height -= viewportMargin * 2;\n    var placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value\n    };\n\n    function checkOverflow(_placement) {\n      var box = new Box(contentBox);\n      var targetPoint = anchorToPoint(_placement.anchor, targetBox);\n      var contentPoint = anchorToPoint(_placement.origin, box);\n\n      var _getOffset = getOffset(targetPoint, contentPoint),\n          x = _getOffset.x,\n          y = _getOffset.y;\n\n      switch (_placement.anchor.side) {\n        case 'top':\n          y -= offset.value[0];\n          break;\n\n        case 'bottom':\n          y += offset.value[0];\n          break;\n\n        case 'left':\n          x -= offset.value[0];\n          break;\n\n        case 'right':\n          x += offset.value[0];\n          break;\n      }\n\n      switch (_placement.anchor.align) {\n        case 'top':\n          y -= offset.value[1];\n          break;\n\n        case 'bottom':\n          y += offset.value[1];\n          break;\n\n        case 'left':\n          x -= offset.value[1];\n          break;\n\n        case 'right':\n          x += offset.value[1];\n          break;\n      }\n\n      box.x += x;\n      box.y += y;\n      box.width = Math.min(box.width, maxWidth.value);\n      box.height = Math.min(box.height, maxHeight.value);\n      var overflows = getOverflow(box, viewport);\n      return {\n        overflows: overflows,\n        x: x,\n        y: y\n      };\n    }\n\n    var x = 0;\n    var y = 0;\n    var available = {\n      x: 0,\n      y: 0\n    };\n    var flipped = {\n      x: false,\n      y: false\n    };\n    var resets = -1;\n\n    var _loop = function _loop() {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy');\n        return \"break\";\n      }\n\n      var _checkOverflow = checkOverflow(placement),\n          _x = _checkOverflow.x,\n          _y = _checkOverflow.y,\n          overflows = _checkOverflow.overflows;\n\n      x += _x;\n      y += _y;\n      contentBox.x += _x;\n      contentBox.y += _y; // flip\n\n      {\n        var _axis = getAxis(placement.anchor);\n\n        var hasOverflowX = overflows.x.before || overflows.x.after;\n        var hasOverflowY = overflows.y.before || overflows.y.after;\n        var reset = false;\n        ['x', 'y'].forEach(function (key) {\n          if (key === 'x' && hasOverflowX && !flipped.x || key === 'y' && hasOverflowY && !flipped.y) {\n            var newPlacement = {\n              anchor: _objectSpread({}, placement.anchor),\n              origin: _objectSpread({}, placement.origin)\n            };\n            var flip = key === 'x' ? _axis === 'y' ? flipAlign : flipSide : _axis === 'y' ? flipSide : flipAlign;\n            newPlacement.anchor = flip(newPlacement.anchor);\n            newPlacement.origin = flip(newPlacement.origin);\n\n            var _checkOverflow2 = checkOverflow(newPlacement),\n                newOverflows = _checkOverflow2.overflows;\n\n            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\n              placement = newPlacement;\n              reset = flipped[key] = true;\n            }\n          }\n        });\n        if (reset) return \"continue\";\n      } // shift\n\n      if (overflows.x.before) {\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n      }\n\n      if (overflows.x.after) {\n        x -= overflows.x.after;\n        contentBox.x -= overflows.x.after;\n      }\n\n      if (overflows.y.before) {\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n\n      if (overflows.y.after) {\n        y -= overflows.y.after;\n        contentBox.y -= overflows.y.after;\n      } // size\n\n\n      {\n        var _overflows = getOverflow(contentBox, viewport);\n\n        available.x = viewport.width - _overflows.x.before - _overflows.x.after;\n        available.y = viewport.height - _overflows.y.before - _overflows.y.after;\n        x += _overflows.x.before;\n        contentBox.x += _overflows.x.before;\n        y += _overflows.y.before;\n        contentBox.y += _overflows.y.before;\n      }\n      return \"break\";\n    };\n\n    while (true) {\n      var _ret = _loop();\n\n      if (_ret === \"break\") break;\n      if (_ret === \"continue\") continue;\n    }\n\n    var axis = getAxis(placement.anchor);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': \"\".concat(placement.anchor.side, \" \").concat(placement.anchor.align),\n      transformOrigin: \"\".concat(placement.origin.side, \" \").concat(placement.origin.align),\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\n    });\n    return {\n      available: available,\n      contentBox: contentBox\n    };\n  }\n\n  watch(function () {\n    return [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight];\n  }, function () {\n    return updateLocation();\n  });\n  nextTick(function () {\n    var result = updateLocation(); // TODO: overflowing content should only require a single updateLocation call\n    // Icky hack to make sure the content is positioned consistently\n\n    if (!result) return;\n    var available = result.available,\n        contentBox = result.contentBox;\n\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(function () {\n        updateLocation();\n        requestAnimationFrame(function () {\n          updateLocation();\n        });\n      });\n    }\n  });\n  return {\n    updateLocation: updateLocation\n  };\n}\n\nfunction pixelRound(val) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\n}\n\nfunction pixelCeil(val) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\n}","map":{"version":3,"mappings":"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","names":["useToggleScope","computed","nextTick","onScopeDispose","ref","watch","anchorToPoint","getOffset","clamp","consoleError","convertToUnit","destructComputed","flipAlign","flipCorner","flipSide","getAxis","getScrollParents","IN_BROWSER","isFixedPosition","nullifyTransforms","parseAnchor","propsFactory","Box","getOverflow","getTargetBox","locationStrategies","static","staticLocationStrategy","connected","connectedLocationStrategy","makeLocationStrategyProps","locationStrategy","type","String","Function","default","validator","val","location","origin","offset","Number","Array","useLocationStrategies","props","data","contentStyles","updateLocation","isActive","value","reset","window","removeEventListener","onResize","undefined","addEventListener","passive","e","getIntrinsicSize","el","isRtl","contentBox","x","parseFloat","style","right","left","y","top","activatorFixed","isArray","target","Object","assign","position","parsedAnchor","parsedOrigin","side","align","preferredAnchor","preferredOrigin","map","key","isNaN","Infinity","minWidth","minHeight","maxWidth","maxHeight","split","length","push","observe","observer","ResizeObserver","contentEl","_ref","newTarget","newContentEl","_ref2","oldTarget","oldContentEl","unobserve","immediate","disconnect","requestAnimationFrame","targetBox","scrollParents","viewportMargin","document","documentElement","getPropertyValue","viewport","reduce","box","rect","getBoundingClientRect","scrollBox","width","clientWidth","height","clientHeight","Math","max","min","bottom","placement","anchor","checkOverflow","_placement","targetPoint","contentPoint","overflows","available","flipped","resets","_x","_y","axis","hasOverflowX","before","after","hasOverflowY","forEach","newPlacement","flip","newOverflows","transformOrigin","pixelRound","pixelCeil","result","round","devicePixelRatio","ceil"],"sources":["../../../src/components/VOverlay/locationStrategies.ts"],"sourcesContent":["// Composables\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Utilities\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue'\nimport { anchorToPoint, getOffset } from './util/point'\nimport {\n  clamp,\n  consoleError,\n  convertToUnit,\n  destructComputed,\n  flipAlign,\n  flipCorner,\n  flipSide,\n  getAxis,\n  getScrollParents,\n  IN_BROWSER,\n  isFixedPosition,\n  nullifyTransforms,\n  parseAnchor,\n  propsFactory,\n} from '@/util'\nimport { Box, getOverflow, getTargetBox } from '@/util/box'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { Anchor } from '@/util'\n\nexport interface LocationStrategyData {\n  contentEl: Ref<HTMLElement | undefined>\n  target: Ref<HTMLElement | [x: number, y: number] | undefined>\n  isActive: Ref<boolean>\n  isRtl: Ref<boolean>\n}\n\nexport type LocationStrategyFunction = (\n  data: LocationStrategyData,\n  props: StrategyProps,\n  contentStyles: Ref<Record<string, string>>\n) => undefined | { updateLocation: (e?: Event) => void }\n\nconst locationStrategies = {\n  static: staticLocationStrategy, // specific viewport position, usually centered\n  connected: connectedLocationStrategy, // connected to a certain element\n}\n\nexport interface StrategyProps {\n  locationStrategy: keyof typeof locationStrategies | LocationStrategyFunction\n  location: Anchor\n  origin: Anchor | 'auto' | 'overlap'\n  offset?: number | string | number[]\n  maxHeight?: number | string\n  maxWidth?: number | string\n  minHeight?: number | string\n  minWidth?: number | string\n}\n\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function] as PropType<StrategyProps['locationStrategy']>,\n    default: 'static',\n    validator: (val: any) => typeof val === 'function' || val in locationStrategies,\n  },\n  location: {\n    type: String as PropType<StrategyProps['location']>,\n    default: 'bottom',\n  },\n  origin: {\n    type: String as PropType<StrategyProps['origin']>,\n    default: 'auto',\n  },\n  offset: [Number, String, Array] as PropType<StrategyProps['offset']>,\n}, 'VOverlay-location-strategies')\n\nexport function useLocationStrategies (\n  props: StrategyProps,\n  data: LocationStrategyData\n) {\n  const contentStyles = ref({})\n  const updateLocation = ref<(e: Event) => void>()\n\n  if (IN_BROWSER) {\n    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), reset => {\n      watch(() => props.locationStrategy, reset)\n      onScopeDispose(() => {\n        window.removeEventListener('resize', onResize)\n        updateLocation.value = undefined\n      })\n\n      window.addEventListener('resize', onResize, { passive: true })\n\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation\n      }\n    })\n  }\n\n  function onResize (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  return {\n    contentStyles,\n    updateLocation,\n  }\n}\n\nfunction staticLocationStrategy () {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize (el: HTMLElement, isRtl: boolean) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el)\n\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0)\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0)\n  }\n  contentBox.y -= parseFloat(el.style.top || 0)\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox\n}\n\nfunction connectedLocationStrategy (data: LocationStrategyData, props: StrategyProps, contentStyles: Ref<Record<string, string>>) {\n  const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value)\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n      top: 0,\n      [data.isRtl.value ? 'right' : 'left']: 0,\n    })\n  }\n\n  const { preferredAnchor, preferredOrigin } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value)\n    const parsedOrigin =\n      props.origin === 'overlap' ? parsedAnchor\n      : props.origin === 'auto' ? flipSide(parsedAnchor)\n      : parseAnchor(props.origin, data.isRtl.value)\n\n    // Some combinations of props may produce an invalid origin\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin),\n      }\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin,\n      }\n    }\n  })\n\n  const [minWidth, minHeight, maxWidth, maxHeight] =\n    (['minWidth', 'minHeight', 'maxWidth', 'maxHeight'] as const).map(key => {\n      return computed(() => {\n        const val = parseFloat(props[key]!)\n        return isNaN(val) ? Infinity : val\n      })\n    })\n\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat)\n      if (offset.length < 2) offset.push(0)\n      return offset\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0]\n  })\n\n  let observe = false\n  const observer = new ResizeObserver(() => {\n    if (observe) updateLocation()\n  })\n\n  watch([data.target, data.contentEl], ([newTarget, newContentEl], [oldTarget, oldContentEl]) => {\n    if (oldTarget && !Array.isArray(oldTarget)) observer.unobserve(oldTarget)\n    if (newTarget && !Array.isArray(newTarget)) observer.observe(newTarget)\n\n    if (oldContentEl) observer.unobserve(oldContentEl)\n    if (newContentEl) observer.observe(newContentEl)\n  }, {\n    immediate: true,\n  })\n\n  onScopeDispose(() => {\n    observer.disconnect()\n  })\n\n  // eslint-disable-next-line max-statements\n  function updateLocation () {\n    observe = false\n    requestAnimationFrame(() => observe = true)\n\n    if (!data.target.value || !data.contentEl.value) return\n\n    const targetBox = getTargetBox(data.target.value)\n    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value)\n    const scrollParents = getScrollParents(data.contentEl.value)\n    const viewportMargin = 12\n\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement)\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0)\n        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0)\n      }\n    }\n\n    const viewport = scrollParents.reduce<Box>((box: Box | undefined, el) => {\n      const rect = el.getBoundingClientRect()\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight,\n      })\n\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top),\n        })\n      }\n      return scrollBox\n    }, undefined!)\n    viewport.x += viewportMargin\n    viewport.y += viewportMargin\n    viewport.width -= viewportMargin * 2\n    viewport.height -= viewportMargin * 2\n\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value,\n    }\n\n    function checkOverflow (_placement: typeof placement) {\n      const box = new Box(contentBox)\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox)\n      const contentPoint = anchorToPoint(_placement.origin, box)\n\n      let { x, y } = getOffset(targetPoint, contentPoint)\n\n      switch (_placement.anchor.side) {\n        case 'top': y -= offset.value[0]; break\n        case 'bottom': y += offset.value[0]; break\n        case 'left': x -= offset.value[0]; break\n        case 'right': x += offset.value[0]; break\n      }\n\n      switch (_placement.anchor.align) {\n        case 'top': y -= offset.value[1]; break\n        case 'bottom': y += offset.value[1]; break\n        case 'left': x -= offset.value[1]; break\n        case 'right': x += offset.value[1]; break\n      }\n\n      box.x += x\n      box.y += y\n\n      box.width = Math.min(box.width, maxWidth.value)\n      box.height = Math.min(box.height, maxHeight.value)\n\n      const overflows = getOverflow(box, viewport)\n\n      return { overflows, x, y }\n    }\n\n    let x = 0; let y = 0\n    const available = { x: 0, y: 0 }\n    const flipped = { x: false, y: false }\n    let resets = -1\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy')\n        break\n      }\n\n      const { x: _x, y: _y, overflows } = checkOverflow(placement)\n\n      x += _x\n      y += _y\n\n      contentBox.x += _x\n      contentBox.y += _y\n\n      // flip\n      {\n        const axis = getAxis(placement.anchor)\n        const hasOverflowX = overflows.x.before || overflows.x.after\n        const hasOverflowY = overflows.y.before || overflows.y.after\n\n        let reset = false\n        ;['x', 'y'].forEach(key => {\n          if (\n            (key === 'x' && hasOverflowX && !flipped.x) ||\n            (key === 'y' && hasOverflowY && !flipped.y)\n          ) {\n            const newPlacement = { anchor: { ...placement.anchor }, origin: { ...placement.origin } }\n            const flip = key === 'x'\n              ? axis === 'y' ? flipAlign : flipSide\n              : axis === 'y' ? flipSide : flipAlign\n            newPlacement.anchor = flip(newPlacement.anchor)\n            newPlacement.origin = flip(newPlacement.origin)\n            const { overflows: newOverflows } = checkOverflow(newPlacement)\n            if (\n              (newOverflows[key].before <= overflows[key].before &&\n                newOverflows[key].after <= overflows[key].after) ||\n              (newOverflows[key].before + newOverflows[key].after <\n                (overflows[key].before + overflows[key].after) / 2)\n            ) {\n              placement = newPlacement\n              reset = flipped[key] = true\n            }\n          }\n        })\n        if (reset) continue\n      }\n\n      // shift\n      if (overflows.x.before) {\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after\n        contentBox.x -= overflows.x.after\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after\n        contentBox.y -= overflows.y.after\n      }\n\n      // size\n      {\n        const overflows = getOverflow(contentBox, viewport)\n        available.x = viewport.width - overflows.x.before - overflows.x.after\n        available.y = viewport.height - overflows.y.before - overflows.y.after\n\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n\n      break\n    }\n\n    const axis = getAxis(placement.anchor)\n\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value))),\n    })\n\n    return {\n      available,\n      contentBox,\n    }\n  }\n\n  watch(\n    () => [\n      preferredAnchor.value,\n      preferredOrigin.value,\n      props.offset,\n      props.minWidth,\n      props.minHeight,\n      props.maxWidth,\n      props.maxHeight,\n    ],\n    () => updateLocation(),\n  )\n\n  nextTick(() => {\n    const result = updateLocation()\n\n    // TODO: overflowing content should only require a single updateLocation call\n    // Icky hack to make sure the content is positioned consistently\n    if (!result) return\n    const { available, contentBox } = result\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(() => {\n        updateLocation()\n        requestAnimationFrame(() => {\n          updateLocation()\n        })\n      })\n    }\n  })\n\n  return { updateLocation }\n}\n\nfunction pixelRound (val: number) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio\n}\n\nfunction pixelCeil (val: number) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio\n}\n"]},"metadata":{},"sourceType":"module"}