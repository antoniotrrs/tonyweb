{"ast":null,"code":"// Composables\nimport { makeFocusProps } from \"./focus.js\";\nimport { useForm } from \"./form.js\";\nimport { useProxiedModel } from \"./proxiedModel.js\";\nimport { useToggleScope } from \"./toggleScope.js\"; // import { useRules } from '@/labs/rules'\n// Utilities\n\nimport { computed, nextTick, onBeforeMount, onBeforeUnmount, onMounted, ref, shallowRef, unref, useId, watch } from 'vue';\nimport { getCurrentInstance, getCurrentInstanceName, propsFactory, wrapInArray } from \"../util/index.js\"; // Types\n// type ValidationRuleParams = [any, string?]\n// type ValidationAlias = string | [string, ...ValidationRuleParams]\n\nexport const makeValidationProps = propsFactory({\n  disabled: {\n    type: Boolean,\n    default: null\n  },\n  error: Boolean,\n  errorMessages: {\n    type: [Array, String],\n    default: () => []\n  },\n  maxErrors: {\n    type: [Number, String],\n    default: 1\n  },\n  name: String,\n  label: String,\n  readonly: {\n    type: Boolean,\n    default: null\n  },\n  rules: {\n    type: Array,\n    // type: Array as PropType<readonly (ValidationRule | ValidationAlias)[]>,\n    default: () => []\n  },\n  modelValue: null,\n  validateOn: String,\n  validationValue: null,\n  ...makeFocusProps()\n}, 'validation');\nexport function useValidation(props) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getCurrentInstanceName();\n  let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : useId();\n  const model = useProxiedModel(props, 'modelValue');\n  const validationModel = computed(() => props.validationValue === undefined ? model.value : props.validationValue);\n  const form = useForm(props); // const rules = useRules()\n\n  const internalErrorMessages = ref([]);\n  const isPristine = shallowRef(true);\n  const isDirty = computed(() => !!(wrapInArray(model.value === '' ? null : model.value).length || wrapInArray(validationModel.value === '' ? null : validationModel.value).length));\n  const errorMessages = computed(() => {\n    return props.errorMessages?.length ? wrapInArray(props.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, Number(props.maxErrors))) : internalErrorMessages.value;\n  });\n  const validateOn = computed(() => {\n    let value = (props.validateOn ?? form.validateOn?.value) || 'input';\n    if (value === 'lazy') value = 'input lazy';\n    if (value === 'eager') value = 'input eager';\n    const set = new Set(value?.split(' ') ?? []);\n    return {\n      input: set.has('input'),\n      blur: set.has('blur') || set.has('input') || set.has('invalid-input'),\n      invalidInput: set.has('invalid-input'),\n      lazy: set.has('lazy'),\n      eager: set.has('eager')\n    };\n  });\n  const isValid = computed(() => {\n    if (props.error || props.errorMessages?.length) return false;\n    if (!props.rules.length) return true;\n\n    if (isPristine.value) {\n      return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;\n    } else {\n      return !internalErrorMessages.value.length;\n    }\n  });\n  const isValidating = shallowRef(false);\n  const validationClasses = computed(() => {\n    return {\n      [`${name}--error`]: isValid.value === false,\n      [`${name}--dirty`]: isDirty.value,\n      [`${name}--disabled`]: form.isDisabled.value,\n      [`${name}--readonly`]: form.isReadonly.value\n    };\n  });\n  const vm = getCurrentInstance('validation');\n  const uid = computed(() => props.name ?? unref(id)); // const resolvedRules = computed(() => props.rules.map(rule => {\n  //   let ruleName: string | null = null\n  //   let ruleParams: ValidationRuleParams = [undefined]\n  //   if (Array.isArray(rule)) {\n  //     ruleName = rule[0]\n  //     ruleParams = rule.slice(1) as ValidationRuleParams\n  //   } else if (typeof rule === 'string') {\n  //     ruleName = rule\n  //   }\n  //   if (ruleName !== null) {\n  //     if (ruleName.startsWith('$')) {\n  //       ruleName = ruleName.slice(1)\n  //     }\n  //     return rules?.[ruleName]?.(...ruleParams)\n  //   } else {\n  //     return rule\n  //   }\n  // }))\n\n  onBeforeMount(() => {\n    form.register?.({\n      id: uid.value,\n      vm,\n      validate,\n      reset,\n      resetValidation\n    });\n  });\n  onBeforeUnmount(() => {\n    form.unregister?.(uid.value);\n  });\n  onMounted(async () => {\n    if (!validateOn.value.lazy) {\n      await validate(!validateOn.value.eager);\n    }\n\n    form.update?.(uid.value, isValid.value, errorMessages.value);\n  });\n  useToggleScope(() => validateOn.value.input || validateOn.value.invalidInput && isValid.value === false, () => {\n    watch(validationModel, () => {\n      if (validationModel.value != null) {\n        validate();\n      } else if (props.focused) {\n        const unwatch = watch(() => props.focused, val => {\n          if (!val) validate();\n          unwatch();\n        });\n      }\n    });\n  });\n  useToggleScope(() => validateOn.value.blur, () => {\n    watch(() => props.focused, val => {\n      if (!val) validate();\n    });\n  });\n  watch([isValid, errorMessages], () => {\n    form.update?.(uid.value, isValid.value, errorMessages.value);\n  });\n\n  async function reset() {\n    model.value = null;\n    await nextTick();\n    await resetValidation();\n  }\n\n  async function resetValidation() {\n    isPristine.value = true;\n\n    if (!validateOn.value.lazy) {\n      await validate(!validateOn.value.eager);\n    } else {\n      internalErrorMessages.value = [];\n    }\n  }\n\n  async function validate() {\n    let silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (props.disabled || props.readonly) {\n      internalErrorMessages.value = [];\n      isValidating.value = false;\n      return internalErrorMessages.value;\n    }\n\n    const results = [];\n    isValidating.value = true;\n\n    for (const rule of props.rules) {\n      if (results.length >= Number(props.maxErrors ?? 1)) {\n        break;\n      }\n\n      const handler = typeof rule === 'function' ? rule : () => rule;\n      const result = await handler(validationModel.value);\n      if (result === true) continue;\n\n      if (result !== false && typeof result !== 'string') {\n        // eslint-disable-next-line no-console\n        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);\n        continue;\n      }\n\n      results.push(result || '');\n    }\n\n    internalErrorMessages.value = results;\n    isValidating.value = false;\n    isPristine.value = silent;\n    return internalErrorMessages.value;\n  }\n\n  return {\n    errorMessages,\n    isDirty,\n    isDisabled: form.isDisabled,\n    isReadonly: form.isReadonly,\n    isPristine,\n    isValid,\n    isValidating,\n    reset,\n    resetValidation,\n    validate,\n    validationClasses\n  };\n}","map":{"version":3,"mappings":"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","names":["makeFocusProps","useForm","useProxiedModel","useToggleScope","computed","nextTick","onBeforeMount","onBeforeUnmount","onMounted","ref","shallowRef","unref","useId","watch","getCurrentInstance","getCurrentInstanceName","propsFactory","wrapInArray","makeValidationProps","disabled","type","Boolean","default","error","errorMessages","Array","String","maxErrors","Number","name","label","readonly","rules","modelValue","validateOn","validationValue","useValidation","props","id","model","validationModel","undefined","value","form","internalErrorMessages","isPristine","isDirty","length","concat","slice","Math","max","set","Set","split","input","has","blur","invalidInput","lazy","eager","isValid","isValidating","validationClasses","isDisabled","isReadonly","vm","uid","register","validate","reset","resetValidation","unregister","update","focused","unwatch","val","silent","results","rule","handler","result","console","warn","push"],"sources":["../../src/composables/validation.ts"],"sourcesContent":["// Composables\nimport { makeFocusProps } from '@/composables/focus'\nimport { useForm } from '@/composables/form'\nimport { useProxiedModel } from '@/composables/proxiedModel'\nimport { useToggleScope } from '@/composables/toggleScope'\n// import { useRules } from '@/labs/rules'\n\n// Utilities\nimport { computed, nextTick, onBeforeMount, onBeforeUnmount, onMounted, ref, shallowRef, unref, useId, watch } from 'vue'\nimport { getCurrentInstance, getCurrentInstanceName, propsFactory, wrapInArray } from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\nimport type { EventProp, MaybeRef } from '@/util'\n\nexport type ValidationResult = string | boolean\nexport type ValidationRule =\n  | ValidationResult\n  | PromiseLike<ValidationResult>\n  | ((value: any) => ValidationResult)\n  | ((value: any) => PromiseLike<ValidationResult>)\n\ntype ValidateOnValue = 'blur' | 'input' | 'submit' | 'invalid-input'\ntype ValidateOn =\n  | ValidateOnValue\n  | `${ValidateOnValue} lazy`\n  | `${ValidateOnValue} eager`\n  | `lazy ${ValidateOnValue}`\n  | `eager ${ValidateOnValue}`\n  | 'lazy'\n  | 'eager'\n\n// type ValidationRuleParams = [any, string?]\n// type ValidationAlias = string | [string, ...ValidationRuleParams]\n\nexport interface ValidationProps {\n  disabled: boolean | null\n  error: boolean\n  errorMessages: string | readonly string[] | null\n  focused: boolean\n  maxErrors: string | number\n  name: string | undefined\n  label: string | undefined\n  readonly: boolean | null\n  rules: readonly ValidationRule[]\n  // rules: readonly (ValidationRule | ValidationAlias)[]\n  modelValue: any\n  'onUpdate:modelValue': EventProp | undefined\n  validateOn?: ValidateOn\n  validationValue: any\n}\n\nexport const makeValidationProps = propsFactory({\n  disabled: {\n    type: Boolean as PropType<boolean | null>,\n    default: null,\n  },\n  error: Boolean,\n  errorMessages: {\n    type: [Array, String] as PropType<string | readonly string[] | null>,\n    default: () => ([]),\n  },\n  maxErrors: {\n    type: [Number, String],\n    default: 1,\n  },\n  name: String,\n  label: String,\n  readonly: {\n    type: Boolean as PropType<boolean | null>,\n    default: null,\n  },\n  rules: {\n    type: Array as PropType<readonly ValidationRule[]>,\n    // type: Array as PropType<readonly (ValidationRule | ValidationAlias)[]>,\n    default: () => ([]),\n  },\n  modelValue: null,\n  validateOn: String as PropType<ValidationProps['validateOn']>,\n  validationValue: null,\n\n  ...makeFocusProps(),\n}, 'validation')\n\nexport function useValidation (\n  props: ValidationProps,\n  name = getCurrentInstanceName(),\n  id: MaybeRef<string | number> = useId(),\n) {\n  const model = useProxiedModel(props, 'modelValue')\n  const validationModel = computed(() => props.validationValue === undefined ? model.value : props.validationValue)\n  const form = useForm(props)\n  // const rules = useRules()\n  const internalErrorMessages = ref<string[]>([])\n  const isPristine = shallowRef(true)\n  const isDirty = computed(() => !!(\n    wrapInArray(model.value === '' ? null : model.value).length ||\n    wrapInArray(validationModel.value === '' ? null : validationModel.value).length\n  ))\n  const errorMessages = computed(() => {\n    return props.errorMessages?.length\n      ? wrapInArray(props.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, Number(props.maxErrors)))\n      : internalErrorMessages.value\n  })\n  const validateOn = computed(() => {\n    let value = (props.validateOn ?? form.validateOn?.value) || 'input'\n    if (value === 'lazy') value = 'input lazy'\n    if (value === 'eager') value = 'input eager'\n    const set = new Set(value?.split(' ') ?? [])\n\n    return {\n      input: set.has('input'),\n      blur: set.has('blur') || set.has('input') || set.has('invalid-input'),\n      invalidInput: set.has('invalid-input'),\n      lazy: set.has('lazy'),\n      eager: set.has('eager'),\n    }\n  })\n  const isValid = computed(() => {\n    if (props.error || props.errorMessages?.length) return false\n    if (!props.rules.length) return true\n    if (isPristine.value) {\n      return internalErrorMessages.value.length || validateOn.value.lazy ? null : true\n    } else {\n      return !internalErrorMessages.value.length\n    }\n  })\n  const isValidating = shallowRef(false)\n  const validationClasses = computed(() => {\n    return {\n      [`${name}--error`]: isValid.value === false,\n      [`${name}--dirty`]: isDirty.value,\n      [`${name}--disabled`]: form.isDisabled.value,\n      [`${name}--readonly`]: form.isReadonly.value,\n    }\n  })\n\n  const vm = getCurrentInstance('validation')\n  const uid = computed(() => props.name ?? unref(id))\n\n  // const resolvedRules = computed(() => props.rules.map(rule => {\n  //   let ruleName: string | null = null\n  //   let ruleParams: ValidationRuleParams = [undefined]\n  //   if (Array.isArray(rule)) {\n  //     ruleName = rule[0]\n  //     ruleParams = rule.slice(1) as ValidationRuleParams\n  //   } else if (typeof rule === 'string') {\n  //     ruleName = rule\n  //   }\n\n  //   if (ruleName !== null) {\n  //     if (ruleName.startsWith('$')) {\n  //       ruleName = ruleName.slice(1)\n  //     }\n\n  //     return rules?.[ruleName]?.(...ruleParams)\n  //   } else {\n  //     return rule\n  //   }\n  // }))\n\n  onBeforeMount(() => {\n    form.register?.({\n      id: uid.value,\n      vm,\n      validate,\n      reset,\n      resetValidation,\n    })\n  })\n\n  onBeforeUnmount(() => {\n    form.unregister?.(uid.value)\n  })\n\n  onMounted(async () => {\n    if (!validateOn.value.lazy) {\n      await validate(!validateOn.value.eager)\n    }\n    form.update?.(uid.value, isValid.value, errorMessages.value)\n  })\n\n  useToggleScope(() => validateOn.value.input || (validateOn.value.invalidInput && isValid.value === false), () => {\n    watch(validationModel, () => {\n      if (validationModel.value != null) {\n        validate()\n      } else if (props.focused) {\n        const unwatch = watch(() => props.focused, val => {\n          if (!val) validate()\n\n          unwatch()\n        })\n      }\n    })\n  })\n\n  useToggleScope(() => validateOn.value.blur, () => {\n    watch(() => props.focused, val => {\n      if (!val) validate()\n    })\n  })\n\n  watch([isValid, errorMessages], () => {\n    form.update?.(uid.value, isValid.value, errorMessages.value)\n  })\n\n  async function reset () {\n    model.value = null\n    await nextTick()\n    await resetValidation()\n  }\n\n  async function resetValidation () {\n    isPristine.value = true\n    if (!validateOn.value.lazy) {\n      await validate(!validateOn.value.eager)\n    } else {\n      internalErrorMessages.value = []\n    }\n  }\n\n  async function validate (silent = false) {\n    if (props.disabled || props.readonly) {\n      internalErrorMessages.value = []\n      isValidating.value = false\n      return internalErrorMessages.value\n    }\n\n    const results = []\n\n    isValidating.value = true\n\n    for (const rule of props.rules) {\n      if (results.length >= Number(props.maxErrors ?? 1)) {\n        break\n      }\n\n      const handler = typeof rule === 'function' ? rule : () => rule\n      const result = await handler(validationModel.value)\n\n      if (result === true) continue\n\n      if (result !== false && typeof result !== 'string') {\n        // eslint-disable-next-line no-console\n        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`)\n\n        continue\n      }\n\n      results.push(result || '')\n    }\n\n    internalErrorMessages.value = results\n    isValidating.value = false\n    isPristine.value = silent\n\n    return internalErrorMessages.value\n  }\n\n  return {\n    errorMessages,\n    isDirty,\n    isDisabled: form.isDisabled,\n    isReadonly: form.isReadonly,\n    isPristine,\n    isValid,\n    isValidating,\n    reset,\n    resetValidation,\n    validate,\n    validationClasses,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}