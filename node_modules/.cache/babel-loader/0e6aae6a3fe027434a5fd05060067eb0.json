{"ast":null,"code":"/* eslint-disable max-statements */\n\n/* eslint-disable no-labels */\n// Utilities\nimport { computed, shallowRef, unref, watchEffect, createVNode as _createVNode, Fragment as _Fragment } from 'vue';\nimport { getPropertyFromItem, propsFactory, wrapInArray } from \"../util/index.js\"; // Types\n\n/**\n * - boolean: match without highlight\n * - number: single match (index), length already known\n * - []: single match (start, end)\n * - [][]: multiple matches (start, end), shouldn't overlap\n */\n// Composables\n\nexport const defaultFilter = (value, query, item) => {\n  if (value == null || query == null) return -1;\n  if (!query.length) return 0;\n  value = value.toString().toLocaleLowerCase();\n  query = query.toString().toLocaleLowerCase();\n  const result = [];\n  let idx = value.indexOf(query);\n\n  while (~idx) {\n    result.push([idx, idx + query.length]);\n    idx = value.indexOf(query, idx + query.length);\n  }\n\n  return result.length ? result : -1;\n};\n\nfunction normaliseMatch(match, query) {\n  if (match == null || typeof match === 'boolean' || match === -1) return;\n  if (typeof match === 'number') return [[match, match + query.length]];\n  if (Array.isArray(match[0])) return match;\n  return [match];\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function,\n  customKeyFilter: Object,\n  filterKeys: [Array, String],\n  filterMode: {\n    type: String,\n    default: 'intersection'\n  },\n  noFilter: Boolean\n}, 'filter');\nexport function filterItems(items, query, options) {\n  const array = []; // always ensure we fall back to a functioning filter\n\n  const filter = options?.default ?? defaultFilter;\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false;\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length;\n  if (!items?.length) return array;\n\n  loop: for (let i = 0; i < items.length; i++) {\n    const [item, transformed = item] = wrapInArray(items[i]);\n    const customMatches = {};\n    const defaultMatches = {};\n    let match = -1;\n\n    if ((query || customFiltersLength > 0) && !options?.noFilter) {\n      if (typeof item === 'object') {\n        const filterKeys = keys || Object.keys(transformed);\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(transformed, key);\n          const keyFilter = options?.customKeyFilter?.[key];\n          match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = normaliseMatch(match, query);else defaultMatches[key] = normaliseMatch(match, query);\n          } else if (options?.filterMode === 'every') {\n            continue loop;\n          }\n        }\n      } else {\n        match = filter(item, query, item);\n\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = normaliseMatch(match, query);\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length;\n      const customMatchesLength = Object.keys(customMatches).length;\n      if (!defaultMatchesLength && !customMatchesLength) continue;\n      if (options?.filterMode === 'union' && customMatchesLength !== customFiltersLength && !defaultMatchesLength) continue;\n      if (options?.filterMode === 'intersection' && (customMatchesLength !== customFiltersLength || !defaultMatchesLength)) continue;\n    }\n\n    array.push({\n      index: i,\n      matches: { ...defaultMatches,\n        ...customMatches\n      }\n    });\n  }\n\n  return array;\n}\nexport function useFilter(props, items, query, options) {\n  const filteredItems = shallowRef([]);\n  const filteredMatches = shallowRef(new Map());\n  const transformedItems = computed(() => options?.transform ? unref(items).map(item => [item, options.transform(item)]) : unref(items));\n  watchEffect(() => {\n    const _query = typeof query === 'function' ? query() : unref(query);\n\n    const strQuery = typeof _query !== 'string' && typeof _query !== 'number' ? '' : String(_query);\n    const results = filterItems(transformedItems.value, strQuery, {\n      customKeyFilter: { ...props.customKeyFilter,\n        ...unref(options?.customKeyFilter)\n      },\n      default: props.customFilter,\n      filterKeys: props.filterKeys,\n      filterMode: props.filterMode,\n      noFilter: props.noFilter\n    });\n    const originalItems = unref(items);\n    const _filteredItems = [];\n\n    const _filteredMatches = new Map();\n\n    results.forEach(_ref => {\n      let {\n        index,\n        matches\n      } = _ref;\n      const item = originalItems[index];\n\n      _filteredItems.push(item);\n\n      _filteredMatches.set(item.value, matches);\n    });\n    filteredItems.value = _filteredItems;\n    filteredMatches.value = _filteredMatches;\n  });\n\n  function getMatches(item) {\n    return filteredMatches.value.get(item.value);\n  }\n\n  return {\n    filteredItems,\n    filteredMatches,\n    getMatches\n  };\n}\nexport function highlightResult(name, text, matches) {\n  if (matches == null || !matches.length) return text;\n  return matches.map((match, i) => {\n    const start = i === 0 ? 0 : matches[i - 1][1];\n    const result = [_createVNode(\"span\", {\n      \"class\": `${name}__unmask`\n    }, [text.slice(start, match[0])]), _createVNode(\"span\", {\n      \"class\": `${name}__mask`\n    }, [text.slice(match[0], match[1])])];\n\n    if (i === matches.length - 1) {\n      result.push(_createVNode(\"span\", {\n        \"class\": `${name}__unmask`\n      }, [text.slice(match[1])]));\n    }\n\n    return _createVNode(_Fragment, null, [result]);\n  });\n}","map":{"version":3,"mappings":"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","names":["computed","shallowRef","unref","watchEffect","createVNode","Fragment","getPropertyFromItem","propsFactory","wrapInArray","defaultFilter","value","query","item","length","toString","toLocaleLowerCase","result","idx","indexOf","push","normaliseMatch","match","Array","isArray","makeFilterProps","customFilter","Function","customKeyFilter","Object","filterKeys","String","filterMode","type","default","noFilter","Boolean","filterItems","items","options","array","filter","keys","customFiltersLength","loop","i","transformed","customMatches","defaultMatches","key","keyFilter","title","defaultMatchesLength","customMatchesLength","index","matches","useFilter","props","filteredItems","filteredMatches","Map","transformedItems","transform","map","_query","strQuery","results","originalItems","_filteredItems","_filteredMatches","forEach","_ref","set","getMatches","get","highlightResult","name","text","start","slice","_createVNode"],"sources":["../../src/composables/filter.tsx"],"sourcesContent":["/* eslint-disable max-statements */\n/* eslint-disable no-labels */\n\n// Utilities\nimport { computed, shallowRef, unref, watchEffect } from 'vue'\nimport { getPropertyFromItem, propsFactory, wrapInArray } from '@/util'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { MaybeRef } from '@/util'\n\n/**\n * - boolean: match without highlight\n * - number: single match (index), length already known\n * - []: single match (start, end)\n * - [][]: multiple matches (start, end), shouldn't overlap\n */\nexport type FilterMatchArraySingle = readonly [number, number]\nexport type FilterMatchArrayMultiple = readonly FilterMatchArraySingle[]\nexport type FilterMatchArray = FilterMatchArraySingle | FilterMatchArrayMultiple\nexport type FilterMatch = boolean | number | FilterMatchArray\nexport type FilterFunction = (value: string, query: string, item?: InternalItem) => FilterMatch\nexport type FilterKeyFunctions = Record<string, FilterFunction>\nexport type FilterKeys = string | string[]\nexport type FilterMode = 'some' | 'every' | 'union' | 'intersection'\n\nexport interface FilterProps {\n  customFilter?: FilterFunction\n  customKeyFilter?: FilterKeyFunctions\n  filterKeys?: FilterKeys\n  filterMode?: FilterMode\n  noFilter?: boolean\n}\n\nexport interface InternalItem<T = any> {\n  value: any\n  raw: T\n}\n\n// Composables\nexport const defaultFilter: FilterFunction = (value, query, item) => {\n  if (value == null || query == null) return -1\n  if (!query.length) return 0\n\n  value = value.toString().toLocaleLowerCase()\n  query = query.toString().toLocaleLowerCase()\n\n  const result = []\n  let idx = value.indexOf(query)\n  while (~idx) {\n    result.push([idx, idx + query.length] as const)\n\n    idx = value.indexOf(query, idx + query.length)\n  }\n\n  return result.length ? result : -1\n}\n\nfunction normaliseMatch (match: FilterMatch, query: string): FilterMatchArrayMultiple | undefined {\n  if (match == null || typeof match === 'boolean' || match === -1) return\n  if (typeof match === 'number') return [[match, match + query.length]]\n  if (Array.isArray(match[0])) return match as FilterMatchArrayMultiple\n  return [match] as FilterMatchArrayMultiple\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function as PropType<FilterFunction>,\n  customKeyFilter: Object as PropType<FilterKeyFunctions>,\n  filterKeys: [Array, String] as PropType<FilterKeys>,\n  filterMode: {\n    type: String as PropType<FilterMode>,\n    default: 'intersection',\n  },\n  noFilter: Boolean,\n}, 'filter')\n\nexport function filterItems (\n  items: readonly (readonly [item: InternalItem, transformed: {}])[] | readonly InternalItem[],\n  query: string,\n  options?: {\n    customKeyFilter?: FilterKeyFunctions\n    default?: FilterFunction\n    filterKeys?: FilterKeys\n    filterMode?: FilterMode\n    noFilter?: boolean\n  },\n) {\n  const array: { index: number, matches: Record<string, FilterMatchArrayMultiple | undefined> }[] = []\n  // always ensure we fall back to a functioning filter\n  const filter = options?.default ?? defaultFilter\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length\n\n  if (!items?.length) return array\n\n  loop:\n  for (let i = 0; i < items.length; i++) {\n    const [item, transformed = item] = wrapInArray(items[i]) as readonly [InternalItem, {}]\n    const customMatches: Record<string, FilterMatchArrayMultiple | undefined> = {}\n    const defaultMatches: Record<string, FilterMatchArrayMultiple | undefined> = {}\n    let match: FilterMatch = -1\n\n    if ((query || customFiltersLength > 0) && !options?.noFilter) {\n      if (typeof item === 'object') {\n        const filterKeys = keys || Object.keys(transformed)\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(transformed, key)\n          const keyFilter = options?.customKeyFilter?.[key]\n\n          match = keyFilter\n            ? keyFilter(value, query, item)\n            : filter(value, query, item)\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = normaliseMatch(match, query)\n            else defaultMatches[key] = normaliseMatch(match, query)\n          } else if (options?.filterMode === 'every') {\n            continue loop\n          }\n        }\n      } else {\n        match = filter(item, query, item)\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = normaliseMatch(match, query)\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length\n      const customMatchesLength = Object.keys(customMatches).length\n\n      if (!defaultMatchesLength && !customMatchesLength) continue\n\n      if (\n        options?.filterMode === 'union' &&\n        customMatchesLength !== customFiltersLength &&\n        !defaultMatchesLength\n      ) continue\n\n      if (\n        options?.filterMode === 'intersection' &&\n        (\n          customMatchesLength !== customFiltersLength ||\n          !defaultMatchesLength\n        )\n      ) continue\n    }\n\n    array.push({ index: i, matches: { ...defaultMatches, ...customMatches } })\n  }\n\n  return array\n}\n\nexport function useFilter <T extends InternalItem> (\n  props: FilterProps,\n  items: MaybeRef<T[]>,\n  query: Ref<string | undefined> | (() => string | undefined),\n  options?: {\n    transform?: (item: T) => {}\n    customKeyFilter?: MaybeRef<FilterKeyFunctions | undefined>\n  }\n) {\n  const filteredItems = shallowRef<T[]>([])\n  const filteredMatches = shallowRef(new Map<unknown, Record<string, FilterMatchArrayMultiple | undefined>>())\n  const transformedItems = computed(() => (\n    options?.transform\n      ? unref(items).map(item => ([item, options.transform!(item)] as const))\n      : unref(items)\n  ))\n\n  watchEffect(() => {\n    const _query = typeof query === 'function' ? query() : unref(query)\n    const strQuery = (\n      typeof _query !== 'string' &&\n      typeof _query !== 'number'\n    ) ? '' : String(_query)\n\n    const results = filterItems(\n      transformedItems.value,\n      strQuery,\n      {\n        customKeyFilter: {\n          ...props.customKeyFilter,\n          ...unref(options?.customKeyFilter),\n        },\n        default: props.customFilter,\n        filterKeys: props.filterKeys,\n        filterMode: props.filterMode,\n        noFilter: props.noFilter,\n      },\n    )\n\n    const originalItems = unref(items)\n\n    const _filteredItems: typeof filteredItems['value'] = []\n    const _filteredMatches: typeof filteredMatches['value'] = new Map()\n    results.forEach(({ index, matches }) => {\n      const item = originalItems[index]\n      _filteredItems.push(item)\n      _filteredMatches.set(item.value, matches)\n    })\n    filteredItems.value = _filteredItems\n    filteredMatches.value = _filteredMatches\n  })\n\n  function getMatches (item: T) {\n    return filteredMatches.value.get(item.value)\n  }\n\n  return { filteredItems, filteredMatches, getMatches }\n}\n\nexport function highlightResult (name: string, text: string, matches: FilterMatchArrayMultiple | undefined) {\n  if (matches == null || !matches.length) return text\n\n  return matches.map((match, i) => {\n    const start = i === 0 ? 0 : matches[i - 1][1]\n    const result = [\n      <span class={ `${name}__unmask` }>{ text.slice(start, match[0]) }</span>,\n      <span class={ `${name}__mask` }>{ text.slice(match[0], match[1]) }</span>,\n    ]\n    if (i === matches.length - 1) {\n      result.push(<span class={ `${name}__unmask` }>{ text.slice(match[1]) }</span>)\n    }\n    return <>{ result }</>\n  })\n}\n"]},"metadata":{},"sourceType":"module"}