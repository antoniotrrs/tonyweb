{"ast":null,"code":"import _asyncToGenerator from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _typeof from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _toConsumableArray from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\n// Utilities\nimport { computed, nextTick, ref, useId, watch, createVNode as _createVNode } from 'vue';\nimport { makeLineProps } from \"./util/line.js\";\nimport { genPath as _genPath } from \"./util/path.js\";\nimport { genericComponent, getPropertyFromItem, propsFactory, useRender } from \"../../util/index.js\"; // Types\n\nexport var makeVTrendlineProps = propsFactory(_objectSpread({\n  fill: Boolean\n}, makeLineProps()), 'VTrendline');\nexport var VTrendline = genericComponent()({\n  name: 'VTrendline',\n  props: makeVTrendlineProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots;\n    var uid = useId();\n    var id = computed(function () {\n      return props.id || \"trendline-\".concat(uid);\n    });\n    var autoDrawDuration = computed(function () {\n      return Number(props.autoDrawDuration) || (props.fill ? 500 : 2000);\n    });\n    var lastLength = ref(0);\n    var path = ref(null);\n\n    function genPoints(values, boundary) {\n      var minX = boundary.minX,\n          maxX = boundary.maxX,\n          minY = boundary.minY,\n          maxY = boundary.maxY;\n      var totalValues = values.length;\n      var maxValue = props.max != null ? Number(props.max) : Math.max.apply(Math, _toConsumableArray(values));\n      var minValue = props.min != null ? Number(props.min) : Math.min.apply(Math, _toConsumableArray(values));\n      var gridX = (maxX - minX) / (totalValues - 1);\n      var gridY = (maxY - minY) / (maxValue - minValue || 1);\n      return values.map(function (value, index) {\n        return {\n          x: minX + index * gridX,\n          y: maxY - (value - minValue) * gridY,\n          value: value\n        };\n      });\n    }\n\n    var hasLabels = computed(function () {\n      return Boolean(props.showLabels || props.labels.length > 0 || !!(slots !== null && slots !== void 0 && slots.label));\n    });\n    var lineWidth = computed(function () {\n      return parseFloat(props.lineWidth) || 4;\n    });\n    var totalWidth = computed(function () {\n      return Number(props.width);\n    });\n    var boundary = computed(function () {\n      var padding = Number(props.padding);\n      return {\n        minX: padding,\n        maxX: totalWidth.value - padding,\n        minY: padding,\n        maxY: parseInt(props.height, 10) - padding\n      };\n    });\n    var items = computed(function () {\n      return props.modelValue.map(function (item) {\n        return getPropertyFromItem(item, props.itemValue, item);\n      });\n    });\n    var parsedLabels = computed(function () {\n      var labels = [];\n      var points = genPoints(items.value, boundary.value);\n      var len = points.length;\n\n      for (var i = 0; labels.length < len; i++) {\n        var item = points[i];\n        var value = props.labels[i];\n\n        if (!value) {\n          value = _typeof(item) === 'object' ? item.value : item;\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value)\n        });\n      }\n\n      return labels;\n    });\n    watch(function () {\n      return props.modelValue;\n    }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var pathRef, length;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return nextTick();\n\n            case 2:\n              if (!(!props.autoDraw || !path.value)) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 4:\n              pathRef = path.value;\n              length = pathRef.getTotalLength();\n\n              if (!props.fill) {\n                // Initial setup to \"hide\" the line by using the stroke dash array\n                pathRef.style.strokeDasharray = \"\".concat(length);\n                pathRef.style.strokeDashoffset = \"\".concat(length); // Force reflow to ensure the transition starts from this state\n\n                pathRef.getBoundingClientRect(); // Animate the stroke dash offset to \"draw\" the line\n\n                pathRef.style.transition = \"stroke-dashoffset \".concat(autoDrawDuration.value, \"ms \").concat(props.autoDrawEasing);\n                pathRef.style.strokeDashoffset = '0';\n              } else {\n                // Your existing logic for filled paths remains the same\n                pathRef.style.transformOrigin = 'bottom center';\n                pathRef.style.transition = 'none';\n                pathRef.style.transform = \"scaleY(0)\";\n                pathRef.getBoundingClientRect();\n                pathRef.style.transition = \"transform \".concat(autoDrawDuration.value, \"ms \").concat(props.autoDrawEasing);\n                pathRef.style.transform = \"scaleY(1)\";\n              }\n\n              lastLength.value = length;\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })), {\n      immediate: true\n    });\n\n    function genPath(fill) {\n      var smoothValue = typeof props.smooth === 'boolean' ? props.smooth ? 8 : 0 : Number(props.smooth);\n      return _genPath(genPoints(items.value, boundary.value), smoothValue, fill, parseInt(props.height, 10));\n    }\n\n    useRender(function () {\n      var _parseFloat, _props$color, _props$gradient;\n\n      var gradientData = !props.gradient.slice().length ? [''] : props.gradient.slice().reverse();\n      return _createVNode(\"svg\", {\n        \"display\": \"block\",\n        \"stroke-width\": (_parseFloat = parseFloat(props.lineWidth)) !== null && _parseFloat !== void 0 ? _parseFloat : 4\n      }, [_createVNode(\"defs\", null, [_createVNode(\"linearGradient\", {\n        \"id\": id.value,\n        \"gradientUnits\": \"userSpaceOnUse\",\n        \"x1\": props.gradientDirection === 'left' ? '100%' : '0',\n        \"y1\": props.gradientDirection === 'top' ? '100%' : '0',\n        \"x2\": props.gradientDirection === 'right' ? '100%' : '0',\n        \"y2\": props.gradientDirection === 'bottom' ? '100%' : '0'\n      }, [gradientData.map(function (color, index) {\n        return _createVNode(\"stop\", {\n          \"offset\": index / Math.max(gradientData.length - 1, 1),\n          \"stop-color\": color || 'currentColor'\n        }, null);\n      })])]), hasLabels.value && _createVNode(\"g\", {\n        \"key\": \"labels\",\n        \"style\": {\n          textAnchor: 'middle',\n          dominantBaseline: 'mathematical',\n          fill: 'currentColor'\n        }\n      }, [parsedLabels.value.map(function (item, i) {\n        var _slots$label, _slots$label2;\n\n        return _createVNode(\"text\", {\n          \"x\": item.x + lineWidth.value / 2 + lineWidth.value / 2,\n          \"y\": parseInt(props.height, 10) - 4 + (parseInt(props.labelSize, 10) || 7 * 0.75),\n          \"font-size\": Number(props.labelSize) || 7\n        }, [(_slots$label = (_slots$label2 = slots.label) === null || _slots$label2 === void 0 ? void 0 : _slots$label2.call(slots, {\n          index: i,\n          value: item.value\n        })) !== null && _slots$label !== void 0 ? _slots$label : item.value]);\n      })]), _createVNode(\"path\", {\n        \"ref\": path,\n        \"d\": genPath(props.fill),\n        \"fill\": props.fill ? \"url(#\".concat(id.value, \")\") : 'none',\n        \"stroke\": props.fill ? 'none' : \"url(#\".concat(id.value, \")\")\n      }, null), props.fill && _createVNode(\"path\", {\n        \"d\": genPath(false),\n        \"fill\": \"none\",\n        \"stroke\": (_props$color = props.color) !== null && _props$color !== void 0 ? _props$color : (_props$gradient = props.gradient) === null || _props$gradient === void 0 ? void 0 : _props$gradient[0]\n      }, null)]);\n    });\n  }\n});","map":{"version":3,"mappings":"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","names":["computed","nextTick","ref","useId","watch","createVNode","makeLineProps","genPath","_genPath","genericComponent","getPropertyFromItem","propsFactory","useRender","makeVTrendlineProps","fill","Boolean","VTrendline","name","props","setup","_ref","slots","uid","id","autoDrawDuration","Number","lastLength","path","genPoints","values","boundary","minX","maxX","minY","maxY","totalValues","length","maxValue","max","Math","minValue","min","gridX","gridY","map","value","index","x","y","hasLabels","showLabels","labels","label","lineWidth","parseFloat","totalWidth","width","padding","parseInt","height","items","modelValue","item","itemValue","parsedLabels","points","len","i","push","String","autoDraw","pathRef","getTotalLength","style","strokeDasharray","strokeDashoffset","getBoundingClientRect","transition","autoDrawEasing","transformOrigin","transform","immediate","smoothValue","smooth","gradientData","gradient","slice","reverse","gradientDirection","color","_createVNode","textAnchor","dominantBaseline","labelSize"],"sources":["../../../src/components/VSparkline/VTrendline.tsx"],"sourcesContent":["// Utilities\nimport { computed, nextTick, ref, useId, watch } from 'vue'\nimport { makeLineProps } from './util/line'\nimport { genPath as _genPath } from './util/path'\nimport { genericComponent, getPropertyFromItem, propsFactory, useRender } from '@/util'\n\n// Types\nexport type VTrendlineSlots = {\n  default: void\n  label: { index: number, value: string }\n}\n\nexport type SparklineItem = number | { value: number }\n\nexport type SparklineText = {\n  x: number\n  value: string\n}\n\nexport interface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport interface Point {\n  x: number\n  y: number\n  value: number\n}\n\nexport const makeVTrendlineProps = propsFactory({\n  fill: Boolean,\n\n  ...makeLineProps(),\n}, 'VTrendline')\n\nexport const VTrendline = genericComponent<VTrendlineSlots>()({\n  name: 'VTrendline',\n\n  props: makeVTrendlineProps(),\n\n  setup (props, { slots }) {\n    const uid = useId()\n    const id = computed(() => props.id || `trendline-${uid}`)\n    const autoDrawDuration = computed(() => Number(props.autoDrawDuration) || (props.fill ? 500 : 2000))\n\n    const lastLength = ref(0)\n    const path = ref<SVGPathElement | null>(null)\n\n    function genPoints (\n      values: number[],\n      boundary: Boundary\n    ): Point[] {\n      const { minX, maxX, minY, maxY } = boundary\n      const totalValues = values.length\n      const maxValue = props.max != null ? Number(props.max) : Math.max(...values)\n      const minValue = props.min != null ? Number(props.min) : Math.min(...values)\n\n      const gridX = (maxX - minX) / (totalValues - 1)\n      const gridY = (maxY - minY) / ((maxValue - minValue) || 1)\n\n      return values.map((value, index) => {\n        return {\n          x: minX + index * gridX,\n          y: maxY - (value - minValue) * gridY,\n          value,\n        }\n      })\n    }\n    const hasLabels = computed(() => {\n      return Boolean(\n        props.showLabels ||\n        props.labels.length > 0 ||\n        !!slots?.label\n      )\n    })\n    const lineWidth = computed(() => {\n      return parseFloat(props.lineWidth) || 4\n    })\n    const totalWidth = computed(() => Number(props.width))\n\n    const boundary = computed<Boundary>(() => {\n      const padding = Number(props.padding)\n\n      return {\n        minX: padding,\n        maxX: totalWidth.value - padding,\n        minY: padding,\n        maxY: parseInt(props.height, 10) - padding,\n      }\n    })\n    const items = computed(() => props.modelValue.map(item => getPropertyFromItem(item, props.itemValue, item)))\n    const parsedLabels = computed(() => {\n      const labels = []\n      const points = genPoints(items.value, boundary.value)\n      const len = points.length\n\n      for (let i = 0; labels.length < len; i++) {\n        const item = points[i]\n        let value = props.labels[i]\n\n        if (!value) {\n          value = typeof item === 'object'\n            ? item.value\n            : item\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value),\n        })\n      }\n\n      return labels\n    })\n\n    watch(() => props.modelValue, async () => {\n      await nextTick()\n\n      if (!props.autoDraw || !path.value) return\n\n      const pathRef = path.value\n      const length = pathRef.getTotalLength()\n\n      if (!props.fill) {\n        // Initial setup to \"hide\" the line by using the stroke dash array\n        pathRef.style.strokeDasharray = `${length}`\n        pathRef.style.strokeDashoffset = `${length}`\n\n        // Force reflow to ensure the transition starts from this state\n        pathRef.getBoundingClientRect()\n\n        // Animate the stroke dash offset to \"draw\" the line\n        pathRef.style.transition = `stroke-dashoffset ${autoDrawDuration.value}ms ${props.autoDrawEasing}`\n        pathRef.style.strokeDashoffset = '0'\n      } else {\n        // Your existing logic for filled paths remains the same\n        pathRef.style.transformOrigin = 'bottom center'\n        pathRef.style.transition = 'none'\n        pathRef.style.transform = `scaleY(0)`\n        pathRef.getBoundingClientRect()\n        pathRef.style.transition = `transform ${autoDrawDuration.value}ms ${props.autoDrawEasing}`\n        pathRef.style.transform = `scaleY(1)`\n      }\n\n      lastLength.value = length\n    }, { immediate: true })\n\n    function genPath (fill: boolean) {\n      const smoothValue = typeof props.smooth === 'boolean' ? (props.smooth ? 8 : 0) : Number(props.smooth)\n\n      return _genPath(\n        genPoints(items.value, boundary.value),\n        smoothValue,\n        fill,\n        parseInt(props.height, 10)\n      )\n    }\n\n    useRender(() => {\n      const gradientData = !props.gradient.slice().length ? [''] : props.gradient.slice().reverse()\n\n      return (\n        <svg\n          display=\"block\"\n          stroke-width={ parseFloat(props.lineWidth) ?? 4 }\n        >\n          <defs>\n            <linearGradient\n              id={ id.value }\n              gradientUnits=\"userSpaceOnUse\"\n              x1={ props.gradientDirection === 'left' ? '100%' : '0' }\n              y1={ props.gradientDirection === 'top' ? '100%' : '0' }\n              x2={ props.gradientDirection === 'right' ? '100%' : '0' }\n              y2={ props.gradientDirection === 'bottom' ? '100%' : '0' }\n            >\n              {\n                gradientData.map((color, index) => (\n                  <stop offset={ index / (Math.max(gradientData.length - 1, 1)) } stop-color={ color || 'currentColor' } />\n                ))\n              }\n            </linearGradient>\n          </defs>\n\n          { hasLabels.value && (\n            <g\n              key=\"labels\"\n              style={{\n                textAnchor: 'middle',\n                dominantBaseline: 'mathematical',\n                fill: 'currentColor',\n              }}\n            >\n              {\n                parsedLabels.value.map((item, i) => (\n                  <text\n                    x={ item.x + (lineWidth.value / 2) + lineWidth.value / 2 }\n                    y={ (parseInt(props.height, 10) - 4) + (parseInt(props.labelSize, 10) || 7 * 0.75) }\n                    font-size={ Number(props.labelSize) || 7 }\n                  >\n                    { slots.label?.({ index: i, value: item.value }) ?? item.value }\n                  </text>\n                ))\n              }\n            </g>\n          )}\n\n          <path\n            ref={ path }\n            d={ genPath(props.fill) }\n            fill={ props.fill ? `url(#${id.value})` : 'none' }\n            stroke={ props.fill ? 'none' : `url(#${id.value})` }\n          />\n\n          { props.fill && (\n            <path\n              d={ genPath(false) }\n              fill=\"none\"\n              stroke={ props.color ?? props.gradient?.[0] }\n            />\n          )}\n        </svg>\n      )\n    })\n  },\n})\n\nexport type VTrendline = InstanceType<typeof VTrendline>\n"]},"metadata":{},"sourceType":"module"}