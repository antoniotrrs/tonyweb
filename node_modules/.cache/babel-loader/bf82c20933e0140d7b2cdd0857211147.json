{"ast":null,"code":"import _toConsumableArray from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _typeof from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.has.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.reflect.set.js\";\nimport \"core-js/modules/es.array.slice.js\";\n// Types\nvar Refs = Symbol('Forwarded refs');\n/** Omit properties starting with P */\n\n/** Omit keyof $props from T */\n\nfunction getDescriptor(obj, key) {\n  var currentObj = obj;\n\n  while (currentObj) {\n    var descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);\n    if (descriptor) return descriptor;\n    currentObj = Object.getPrototypeOf(currentObj);\n  }\n\n  return undefined;\n}\n\nexport function forwardRefs(target) {\n  for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    refs[_key - 1] = arguments[_key];\n  }\n\n  target[Refs] = refs;\n  return new Proxy(target, {\n    get: function get(target, key) {\n      if (Reflect.has(target, key)) {\n        return Reflect.get(target, key);\n      } // Skip internal properties\n\n\n      if (_typeof(key) === 'symbol' || key.startsWith('$') || key.startsWith('__')) return;\n\n      var _iterator = _createForOfIteratorHelper(refs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ref = _step.value;\n\n          if (ref.value && Reflect.has(ref.value, key)) {\n            var val = Reflect.get(ref.value, key);\n            return typeof val === 'function' ? val.bind(ref.value) : val;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    },\n    has: function has(target, key) {\n      if (Reflect.has(target, key)) {\n        return true;\n      } // Skip internal properties\n\n\n      if (_typeof(key) === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false;\n\n      var _iterator2 = _createForOfIteratorHelper(refs),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var ref = _step2.value;\n\n          if (ref.value && Reflect.has(ref.value, key)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    },\n    set: function set(target, key, value) {\n      if (Reflect.has(target, key)) {\n        return Reflect.set(target, key, value);\n      } // Skip internal properties\n\n\n      if (_typeof(key) === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false;\n\n      var _iterator3 = _createForOfIteratorHelper(refs),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var ref = _step3.value;\n\n          if (ref.value && Reflect.has(ref.value, key)) {\n            return Reflect.set(ref.value, key, value);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return false;\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, key) {\n      var descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n      if (descriptor) return descriptor; // Skip internal properties\n\n      if (_typeof(key) === 'symbol' || key.startsWith('$') || key.startsWith('__')) return; // Check each ref's own properties\n\n      var _iterator4 = _createForOfIteratorHelper(refs),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _getDescriptor, _ref$value$_;\n\n          var ref = _step4.value;\n          if (!ref.value) continue;\n\n          var _descriptor = (_getDescriptor = getDescriptor(ref.value, key)) !== null && _getDescriptor !== void 0 ? _getDescriptor : '_' in ref.value ? getDescriptor((_ref$value$_ = ref.value._) === null || _ref$value$_ === void 0 ? void 0 : _ref$value$_.setupState, key) : undefined;\n\n          if (_descriptor) return _descriptor;\n        } // Recursive search up each ref's prototype\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(refs),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _ref = _step5.value;\n          var childRefs = _ref.value && _ref.value[Refs];\n          if (!childRefs) continue;\n          var queue = childRefs.slice();\n\n          while (queue.length) {\n            var _ref2 = queue.shift();\n\n            var _descriptor2 = getDescriptor(_ref2.value, key);\n\n            if (_descriptor2) return _descriptor2;\n\n            var _childRefs = _ref2.value && _ref2.value[Refs];\n\n            if (_childRefs) queue.push.apply(queue, _toConsumableArray(_childRefs));\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return undefined;\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["Refs","Symbol","getDescriptor","obj","key","currentObj","descriptor","Reflect","getOwnPropertyDescriptor","Object","getPrototypeOf","undefined","forwardRefs","target","refs","_key","arguments","Proxy","get","has","startsWith","ref","value","val","bind","set","_","setupState","childRefs","queue","slice","length","shift","push"],"sources":["../../src/composables/forwardRefs.ts"],"sourcesContent":["// Types\nimport type { ComponentOptionsBase, ComponentPublicInstance, Ref, UnwrapRef } from 'vue'\nimport type { UnionToIntersection } from '@/util'\n\nconst Refs = Symbol('Forwarded refs')\n\n/** Omit properties starting with P */\ntype OmitPrefix<\n  T,\n  P extends string,\n  E = Extract<keyof T, `${P}${any}`>,\n> = [E] extends [never] ? T : Omit<T, `${P}${any}`>\ntype OmitPrivate<T> = OmitPrefix<T, '$'>\n\n/** Omit keyof $props from T */\ntype OmitProps<T> = T extends { $props: any } ? Omit<T, keyof T['$props']> : T\n\nfunction getDescriptor (obj: any, key: PropertyKey) {\n  let currentObj = obj\n  while (currentObj) {\n    const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key)\n    if (descriptor) return descriptor\n    currentObj = Object.getPrototypeOf(currentObj)\n  }\n  return undefined\n}\n\nexport function forwardRefs<\n  T extends {},\n  U extends Ref<HTMLElement | Omit<ComponentPublicInstance, '$emit' | '$slots'> | undefined>[],\n  UU = { [K in keyof U]: NonNullable<UnwrapRef<U[K]>> }[number],\n  UC = { [K in keyof U]: OmitPrivate<OmitProps<NonNullable<UnwrapRef<U[K]>>>> }[number],\n  R = T & UnionToIntersection<UC> & {\n    _allExposed: T | (\n      UU extends { $options: infer O }\n        ? O extends ComponentOptionsBase<any, infer E, any, any, any, any, any, any>\n          ? E\n          : never\n        : never\n    )\n  }\n> (target: T, ...refs: U): R {\n  (target as any)[Refs] = refs\n\n  return new Proxy(target, {\n    get (target, key) {\n      if (Reflect.has(target, key)) {\n        return Reflect.get(target, key)\n      }\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          const val = Reflect.get(ref.value, key)\n          return typeof val === 'function'\n            ? val.bind(ref.value)\n            : val\n        }\n      }\n    },\n    has (target, key) {\n      if (Reflect.has(target, key)) {\n        return true\n      }\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          return true\n        }\n      }\n      return false\n    },\n    set (target, key, value) {\n      if (Reflect.has(target, key)) {\n        return Reflect.set(target, key, value)\n      }\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          return Reflect.set(ref.value, key, value)\n        }\n      }\n\n      return false\n    },\n    getOwnPropertyDescriptor (target, key) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (descriptor) return descriptor\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return\n\n      // Check each ref's own properties\n      for (const ref of refs) {\n        if (!ref.value) continue\n        const descriptor = getDescriptor(ref.value, key) ?? ('_' in ref.value ? getDescriptor(ref.value._?.setupState, key) : undefined)\n        if (descriptor) return descriptor\n      }\n\n      // Recursive search up each ref's prototype\n      for (const ref of refs) {\n        const childRefs = ref.value && (ref.value as any)[Refs]\n        if (!childRefs) continue\n        const queue = childRefs.slice()\n        while (queue.length) {\n          const ref = queue.shift()\n          const descriptor = getDescriptor(ref.value, key)\n          if (descriptor) return descriptor\n          const childRefs = ref.value && (ref.value as any)[Refs]\n          if (childRefs) queue.push(...childRefs)\n        }\n      }\n\n      return undefined\n    },\n  }) as any\n}\n"]},"metadata":{},"sourceType":"module"}