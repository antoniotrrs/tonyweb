{"ast":null,"code":"import { createVNode as _createVNode } from \"vue\"; // Styles\n\nimport \"./VSlideGroup.css\"; // Components\n\nimport { VFadeTransition } from \"../transitions/index.js\";\nimport { VIcon } from \"../VIcon/index.js\"; // Composables\n\nimport { makeComponentProps } from \"../../composables/component.js\";\nimport { makeDisplayProps, useDisplay } from \"../../composables/display.js\";\nimport { useGoTo } from \"../../composables/goto.js\";\nimport { makeGroupProps, useGroup } from \"../../composables/group.js\";\nimport { IconValue } from \"../../composables/icons.js\";\nimport { useRtl } from \"../../composables/locale.js\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.js\";\nimport { makeTagProps } from \"../../composables/tag.js\"; // Utilities\n\nimport { computed, shallowRef, watch } from 'vue';\nimport { calculateCenteredTarget, calculateUpdatedTarget, getClientSize, getOffsetSize, getScrollPosition, getScrollSize } from \"./helpers.js\";\nimport { focusableChildren, genericComponent, IN_BROWSER, propsFactory, useRender } from \"../../util/index.js\"; // Types\n\nexport const VSlideGroupSymbol = Symbol.for('vuetify:v-slide-group');\nexport const makeVSlideGroupProps = propsFactory({\n  centerActive: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  symbol: {\n    type: null,\n    default: VSlideGroupSymbol\n  },\n  nextIcon: {\n    type: IconValue,\n    default: '$next'\n  },\n  prevIcon: {\n    type: IconValue,\n    default: '$prev'\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: v => typeof v === 'boolean' || ['always', 'desktop', 'mobile'].includes(v)\n  },\n  ...makeComponentProps(),\n  ...makeDisplayProps({\n    mobile: null\n  }),\n  ...makeTagProps(),\n  ...makeGroupProps({\n    selectedClass: 'v-slide-group-item--active'\n  })\n}, 'VSlideGroup');\nexport const VSlideGroup = genericComponent()({\n  name: 'VSlideGroup',\n  props: makeVSlideGroupProps(),\n  emits: {\n    'update:modelValue': value => true\n  },\n\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      isRtl\n    } = useRtl();\n    const {\n      displayClasses,\n      mobile\n    } = useDisplay(props);\n    const group = useGroup(props, props.symbol);\n    const isOverflowing = shallowRef(false);\n    const scrollOffset = shallowRef(0);\n    const containerSize = shallowRef(0);\n    const contentSize = shallowRef(0);\n    const isHorizontal = computed(() => props.direction === 'horizontal');\n    const {\n      resizeRef: containerRef,\n      contentRect: containerRect\n    } = useResizeObserver();\n    const {\n      resizeRef: contentRef,\n      contentRect\n    } = useResizeObserver();\n    const goTo = useGoTo();\n    const goToOptions = computed(() => {\n      return {\n        container: containerRef.el,\n        duration: 200,\n        easing: 'easeOutQuart'\n      };\n    });\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[0]);\n    });\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1]);\n    });\n\n    if (IN_BROWSER) {\n      let frame = -1;\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame);\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height';\n            containerSize.value = containerRect.value[sizeProperty];\n            contentSize.value = contentRect.value[sizeProperty];\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.el) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.el.children[lastSelectedIndex.value];\n            scrollToChildren(selectedElement, props.centerActive);\n          }\n        });\n      });\n    }\n\n    const isFocused = shallowRef(false);\n\n    function scrollToChildren(children, center) {\n      let target = 0;\n\n      if (center) {\n        target = calculateCenteredTarget({\n          containerElement: containerRef.el,\n          isHorizontal: isHorizontal.value,\n          selectedElement: children\n        });\n      } else {\n        target = calculateUpdatedTarget({\n          containerElement: containerRef.el,\n          isHorizontal: isHorizontal.value,\n          isRtl: isRtl.value,\n          selectedElement: children\n        });\n      }\n\n      scrollToPosition(target);\n    }\n\n    function scrollToPosition(newPosition) {\n      if (!IN_BROWSER || !containerRef.el) return;\n      const offsetSize = getOffsetSize(isHorizontal.value, containerRef.el);\n      const scrollPosition = getScrollPosition(isHorizontal.value, isRtl.value, containerRef.el);\n      const scrollSize = getScrollSize(isHorizontal.value, containerRef.el);\n      if (scrollSize <= offsetSize || // Prevent scrolling by only a couple of pixels, which doesn't look smooth\n      Math.abs(newPosition - scrollPosition) < 16) return;\n\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        const {\n          scrollWidth,\n          offsetWidth: containerWidth\n        } = containerRef.el;\n        newPosition = scrollWidth - containerWidth - newPosition;\n      }\n\n      if (isHorizontal.value) {\n        goTo.horizontal(newPosition, goToOptions.value);\n      } else {\n        goTo(newPosition, goToOptions.value);\n      }\n    }\n\n    function onScroll(e) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = e.target;\n      scrollOffset.value = isHorizontal.value ? scrollLeft : scrollTop;\n    }\n\n    function onFocusin(e) {\n      isFocused.value = true;\n      if (!isOverflowing.value || !contentRef.el) return; // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.el.children) {\n          if (item === el) {\n            scrollToChildren(item);\n            return;\n          }\n        }\n      }\n    }\n\n    function onFocusout(e) {\n      isFocused.value = false;\n    } // Affix clicks produce onFocus that we have to ignore to avoid extra scrollToChildren\n\n\n    let ignoreFocusEvent = false;\n\n    function onFocus(e) {\n      if (!ignoreFocusEvent && !isFocused.value && !(e.relatedTarget && contentRef.el?.contains(e.relatedTarget))) focus();\n      ignoreFocusEvent = false;\n    }\n\n    function onFocusAffixes() {\n      ignoreFocusEvent = true;\n    }\n\n    function onKeydown(e) {\n      if (!contentRef.el) return;\n\n      function toFocus(location) {\n        e.preventDefault();\n        focus(location);\n      }\n\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          toFocus(isRtl.value ? 'prev' : 'next');\n        } else if (e.key === 'ArrowLeft') {\n          toFocus(isRtl.value ? 'next' : 'prev');\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          toFocus('next');\n        } else if (e.key === 'ArrowUp') {\n          toFocus('prev');\n        }\n      }\n\n      if (e.key === 'Home') {\n        toFocus('first');\n      } else if (e.key === 'End') {\n        toFocus('last');\n      }\n    }\n\n    function getSiblingElement(el, location) {\n      if (!el) return undefined;\n      let sibling = el;\n\n      do {\n        sibling = sibling?.[location === 'next' ? 'nextElementSibling' : 'previousElementSibling'];\n      } while (sibling?.hasAttribute('disabled'));\n\n      return sibling;\n    }\n\n    function focus(location) {\n      if (!contentRef.el) return;\n      let el;\n\n      if (!location) {\n        const focusable = focusableChildren(contentRef.el);\n        el = focusable[0];\n      } else if (location === 'next') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location);\n        if (!el) return focus('first');\n      } else if (location === 'prev') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location);\n        if (!el) return focus('last');\n      } else if (location === 'first') {\n        el = contentRef.el.firstElementChild;\n        if (el?.hasAttribute('disabled')) el = getSiblingElement(el, 'next');\n      } else if (location === 'last') {\n        el = contentRef.el.lastElementChild;\n        if (el?.hasAttribute('disabled')) el = getSiblingElement(el, 'prev');\n      }\n\n      if (el) {\n        el.focus({\n          preventScroll: true\n        });\n      }\n    }\n\n    function scrollTo(location) {\n      const direction = isHorizontal.value && isRtl.value ? -1 : 1;\n      const offsetStep = (location === 'prev' ? -direction : direction) * containerSize.value;\n      let newPosition = scrollOffset.value + offsetStep; // TODO: improve it\n\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        const {\n          scrollWidth,\n          offsetWidth: containerWidth\n        } = containerRef.el;\n        newPosition += scrollWidth - containerWidth;\n      }\n\n      scrollToPosition(newPosition);\n    }\n\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected\n    }));\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always':\n          return true;\n        // Always show arrows on desktop\n\n        case 'desktop':\n          return !mobile.value;\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n\n        case true:\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        // Always show on mobile\n\n        case 'mobile':\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n\n        default:\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\n      }\n    });\n    const hasPrev = computed(() => {\n      // 1 pixel in reserve, may be lost after rounding\n      return Math.abs(scrollOffset.value) > 1;\n    });\n    const hasNext = computed(() => {\n      if (!containerRef.value) return false;\n      const scrollSize = getScrollSize(isHorizontal.value, containerRef.el);\n      const clientSize = getClientSize(isHorizontal.value, containerRef.el);\n      const scrollSizeMax = scrollSize - clientSize; // 1 pixel in reserve, may be lost after rounding\n\n      return scrollSizeMax - Math.abs(scrollOffset.value) > 1;\n    });\n    useRender(() => _createVNode(props.tag, {\n      \"class\": ['v-slide-group', {\n        'v-slide-group--vertical': !isHorizontal.value,\n        'v-slide-group--has-affixes': hasAffixes.value,\n        'v-slide-group--is-overflowing': isOverflowing.value\n      }, displayClasses.value, props.class],\n      \"style\": props.style,\n      \"tabindex\": isFocused.value || group.selected.value.length ? -1 : 0,\n      \"onFocus\": onFocus\n    }, {\n      default: () => [hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"prev\",\n        \"class\": ['v-slide-group__prev', {\n          'v-slide-group__prev--disabled': !hasPrev.value\n        }],\n        \"onMousedown\": onFocusAffixes,\n        \"onClick\": () => hasPrev.value && scrollTo('prev')\n      }, [slots.prev?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.nextIcon : props.prevIcon\n        }, null)]\n      })]), _createVNode(\"div\", {\n        \"key\": \"container\",\n        \"ref\": containerRef,\n        \"class\": \"v-slide-group__container\",\n        \"onScroll\": onScroll\n      }, [_createVNode(\"div\", {\n        \"ref\": contentRef,\n        \"class\": \"v-slide-group__content\",\n        \"onFocusin\": onFocusin,\n        \"onFocusout\": onFocusout,\n        \"onKeydown\": onKeydown\n      }, [slots.default?.(slotProps.value)])]), hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"next\",\n        \"class\": ['v-slide-group__next', {\n          'v-slide-group__next--disabled': !hasNext.value\n        }],\n        \"onMousedown\": onFocusAffixes,\n        \"onClick\": () => hasNext.value && scrollTo('next')\n      }, [slots.next?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.prevIcon : props.nextIcon\n        }, null)]\n      })])]\n    }));\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus,\n      hasPrev,\n      hasNext\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["VFadeTransition","VIcon","makeComponentProps","makeDisplayProps","useDisplay","useGoTo","makeGroupProps","useGroup","IconValue","useRtl","useResizeObserver","makeTagProps","computed","shallowRef","watch","calculateCenteredTarget","calculateUpdatedTarget","getClientSize","getOffsetSize","getScrollPosition","getScrollSize","focusableChildren","genericComponent","IN_BROWSER","propsFactory","useRender","VSlideGroupSymbol","Symbol","for","makeVSlideGroupProps","centerActive","Boolean","direction","type","String","default","symbol","nextIcon","prevIcon","showArrows","validator","v","includes","mobile","selectedClass","VSlideGroup","name","props","emits","value","setup","_ref","slots","isRtl","displayClasses","group","isOverflowing","scrollOffset","containerSize","contentSize","isHorizontal","resizeRef","containerRef","contentRect","containerRect","contentRef","goTo","goToOptions","container","el","duration","easing","firstSelectedIndex","selected","length","items","findIndex","item","id","lastSelectedIndex","frame","cancelAnimationFrame","requestAnimationFrame","sizeProperty","selectedElement","children","scrollToChildren","isFocused","center","target","containerElement","scrollToPosition","newPosition","offsetSize","scrollPosition","scrollSize","Math","abs","scrollWidth","offsetWidth","containerWidth","horizontal","onScroll","e","scrollTop","scrollLeft","onFocusin","composedPath","onFocusout","ignoreFocusEvent","onFocus","relatedTarget","contains","focus","onFocusAffixes","onKeydown","toFocus","location","preventDefault","key","getSiblingElement","undefined","sibling","hasAttribute","focusable","querySelector","firstElementChild","lastElementChild","preventScroll","scrollTo","offsetStep","slotProps","next","prev","select","isSelected","hasAffixes","hasPrev","hasNext","clientSize","scrollSizeMax","class","style","_createVNode","onClick"],"sources":["../../../src/components/VSlideGroup/VSlideGroup.tsx"],"sourcesContent":["// Styles\nimport './VSlideGroup.sass'\n\n// Components\nimport { VFadeTransition } from '@/components/transitions'\nimport { VIcon } from '@/components/VIcon'\n\n// Composables\nimport { makeComponentProps } from '@/composables/component'\nimport { makeDisplayProps, useDisplay } from '@/composables/display'\nimport { useGoTo } from '@/composables/goto'\nimport { makeGroupProps, useGroup } from '@/composables/group'\nimport { IconValue } from '@/composables/icons'\nimport { useRtl } from '@/composables/locale'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { makeTagProps } from '@/composables/tag'\n\n// Utilities\nimport { computed, shallowRef, watch } from 'vue'\nimport {\n  calculateCenteredTarget,\n  calculateUpdatedTarget,\n  getClientSize,\n  getOffsetSize,\n  getScrollPosition,\n  getScrollSize,\n} from './helpers'\nimport { focusableChildren, genericComponent, IN_BROWSER, propsFactory, useRender } from '@/util'\n\n// Types\nimport type { InjectionKey, PropType } from 'vue'\nimport type { GoToOptions } from '@/composables/goto'\nimport type { GroupProvide } from '@/composables/group'\nimport type { GenericProps } from '@/util'\n\nexport const VSlideGroupSymbol: InjectionKey<GroupProvide> = Symbol.for('vuetify:v-slide-group')\n\ninterface SlideGroupSlot {\n  next: GroupProvide['next']\n  prev: GroupProvide['prev']\n  select: GroupProvide['select']\n  isSelected: GroupProvide['isSelected']\n}\n\ntype VSlideGroupSlots = {\n  default: SlideGroupSlot\n  prev: SlideGroupSlot\n  next: SlideGroupSlot\n}\n\nexport const makeVSlideGroupProps = propsFactory({\n  centerActive: Boolean,\n  direction: {\n    type: String as PropType<'horizontal' | 'vertical'>,\n    default: 'horizontal',\n  },\n  symbol: {\n    type: null,\n    default: VSlideGroupSymbol,\n  },\n  nextIcon: {\n    type: IconValue,\n    default: '$next',\n  },\n  prevIcon: {\n    type: IconValue,\n    default: '$prev',\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: (v: any) => (\n      typeof v === 'boolean' || [\n        'always',\n        'desktop',\n        'mobile',\n      ].includes(v)\n    ),\n  },\n\n  ...makeComponentProps(),\n  ...makeDisplayProps({ mobile: null }),\n  ...makeTagProps(),\n  ...makeGroupProps({\n    selectedClass: 'v-slide-group-item--active',\n  }),\n}, 'VSlideGroup')\n\nexport const VSlideGroup = genericComponent<new <T>(\n  props: {\n    modelValue?: T\n    'onUpdate:modelValue'?: (value: T) => void\n  },\n  slots: VSlideGroupSlots,\n) => GenericProps<typeof props, typeof slots>>()({\n  name: 'VSlideGroup',\n\n  props: makeVSlideGroupProps(),\n\n  emits: {\n    'update:modelValue': (value: any) => true,\n  },\n\n  setup (props, { slots }) {\n    const { isRtl } = useRtl()\n    const { displayClasses, mobile } = useDisplay(props)\n    const group = useGroup(props, props.symbol)\n    const isOverflowing = shallowRef(false)\n    const scrollOffset = shallowRef(0)\n    const containerSize = shallowRef(0)\n    const contentSize = shallowRef(0)\n    const isHorizontal = computed(() => props.direction === 'horizontal')\n\n    const { resizeRef: containerRef, contentRect: containerRect } = useResizeObserver()\n    const { resizeRef: contentRef, contentRect } = useResizeObserver()\n\n    const goTo = useGoTo()\n    const goToOptions = computed<Partial<GoToOptions>>(() => {\n      return {\n        container: containerRef.el,\n        duration: 200,\n        easing: 'easeOutQuart',\n      }\n    })\n\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[0])\n    })\n\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1])\n    })\n\n    if (IN_BROWSER) {\n      let frame = -1\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame)\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height'\n\n            containerSize.value = containerRect.value[sizeProperty]\n            contentSize.value = contentRect.value[sizeProperty]\n\n            isOverflowing.value = containerSize.value + 1 < contentSize.value\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.el) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.el.children[lastSelectedIndex.value] as HTMLElement\n\n            scrollToChildren(selectedElement, props.centerActive)\n          }\n        })\n      })\n    }\n\n    const isFocused = shallowRef(false)\n\n    function scrollToChildren (children: HTMLElement, center?: boolean) {\n      let target = 0\n\n      if (center) {\n        target = calculateCenteredTarget({\n          containerElement: containerRef.el!,\n          isHorizontal: isHorizontal.value,\n          selectedElement: children,\n        })\n      } else {\n        target = calculateUpdatedTarget({\n          containerElement: containerRef.el!,\n          isHorizontal: isHorizontal.value,\n          isRtl: isRtl.value,\n          selectedElement: children,\n        })\n      }\n\n      scrollToPosition(target)\n    }\n\n    function scrollToPosition (newPosition: number) {\n      if (!IN_BROWSER || !containerRef.el) return\n\n      const offsetSize = getOffsetSize(isHorizontal.value, containerRef.el)\n      const scrollPosition = getScrollPosition(isHorizontal.value, isRtl.value, containerRef.el)\n      const scrollSize = getScrollSize(isHorizontal.value, containerRef.el)\n\n      if (\n        scrollSize <= offsetSize ||\n        // Prevent scrolling by only a couple of pixels, which doesn't look smooth\n        Math.abs(newPosition - scrollPosition) < 16\n      ) return\n\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        const { scrollWidth, offsetWidth: containerWidth } = containerRef.el!\n\n        newPosition = (scrollWidth - containerWidth) - newPosition\n      }\n\n      if (isHorizontal.value) {\n        goTo.horizontal(newPosition, goToOptions.value)\n      } else {\n        goTo(newPosition, goToOptions.value)\n      }\n    }\n\n    function onScroll (e: Event) {\n      const { scrollTop, scrollLeft } = e.target as HTMLElement\n\n      scrollOffset.value = isHorizontal.value ? scrollLeft : scrollTop\n    }\n\n    function onFocusin (e: FocusEvent) {\n      isFocused.value = true\n\n      if (!isOverflowing.value || !contentRef.el) return\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.el.children) {\n          if (item === el) {\n            scrollToChildren(item as HTMLElement)\n            return\n          }\n        }\n      }\n    }\n\n    function onFocusout (e: FocusEvent) {\n      isFocused.value = false\n    }\n\n    // Affix clicks produce onFocus that we have to ignore to avoid extra scrollToChildren\n    let ignoreFocusEvent = false\n    function onFocus (e: FocusEvent) {\n      if (\n        !ignoreFocusEvent &&\n        !isFocused.value &&\n        !(e.relatedTarget && contentRef.el?.contains(e.relatedTarget as Node))\n      ) focus()\n\n      ignoreFocusEvent = false\n    }\n\n    function onFocusAffixes () {\n      ignoreFocusEvent = true\n    }\n\n    function onKeydown (e: KeyboardEvent) {\n      if (!contentRef.el) return\n\n      function toFocus (location: Parameters<typeof focus>[0]) {\n        e.preventDefault()\n        focus(location)\n      }\n\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          toFocus(isRtl.value ? 'prev' : 'next')\n        } else if (e.key === 'ArrowLeft') {\n          toFocus(isRtl.value ? 'next' : 'prev')\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          toFocus('next')\n        } else if (e.key === 'ArrowUp') {\n          toFocus('prev')\n        }\n      }\n\n      if (e.key === 'Home') {\n        toFocus('first')\n      } else if (e.key === 'End') {\n        toFocus('last')\n      }\n    }\n\n    function getSiblingElement (el: HTMLElement | null, location: 'next' | 'prev') {\n      if (!el) return undefined\n      let sibling: HTMLElement | null = el\n      do {\n        sibling = sibling?.[location === 'next' ? 'nextElementSibling' : 'previousElementSibling'] as HTMLElement | null\n      } while (sibling?.hasAttribute('disabled'))\n      return sibling\n    }\n\n    function focus (location?: 'next' | 'prev' | 'first' | 'last') {\n      if (!contentRef.el) return\n\n      let el: HTMLElement | null | undefined\n\n      if (!location) {\n        const focusable = focusableChildren(contentRef.el)\n        el = focusable[0]\n      } else if (location === 'next') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location)\n\n        if (!el) return focus('first')\n      } else if (location === 'prev') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location)\n\n        if (!el) return focus('last')\n      } else if (location === 'first') {\n        el = (contentRef.el.firstElementChild as HTMLElement)\n\n        if (el?.hasAttribute('disabled')) el = getSiblingElement(el, 'next')\n      } else if (location === 'last') {\n        el = (contentRef.el.lastElementChild as HTMLElement)\n\n        if (el?.hasAttribute('disabled')) el = getSiblingElement(el, 'prev')\n      }\n\n      if (el) {\n        el.focus({ preventScroll: true })\n      }\n    }\n\n    function scrollTo (location: 'prev' | 'next') {\n      const direction = isHorizontal.value && isRtl.value ? -1 : 1\n\n      const offsetStep = (location === 'prev' ? -direction : direction) * containerSize.value\n\n      let newPosition = scrollOffset.value + offsetStep\n\n      // TODO: improve it\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        const { scrollWidth, offsetWidth: containerWidth } = containerRef.el!\n\n        newPosition += scrollWidth - containerWidth\n      }\n\n      scrollToPosition(newPosition)\n    }\n\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected,\n    }))\n\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always': return true\n\n        // Always show arrows on desktop\n        case 'desktop': return !mobile.value\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true: return isOverflowing.value || Math.abs(scrollOffset.value) > 0\n\n        // Always show on mobile\n        case 'mobile': return (\n          mobile.value ||\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default: return (\n          !mobile.value &&\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n      }\n    })\n\n    const hasPrev = computed(() => {\n      // 1 pixel in reserve, may be lost after rounding\n      return Math.abs(scrollOffset.value) > 1\n    })\n\n    const hasNext = computed(() => {\n      if (!containerRef.value) return false\n\n      const scrollSize = getScrollSize(isHorizontal.value, containerRef.el)\n      const clientSize = getClientSize(isHorizontal.value, containerRef.el)\n\n      const scrollSizeMax = scrollSize - clientSize\n\n      // 1 pixel in reserve, may be lost after rounding\n      return scrollSizeMax - Math.abs(scrollOffset.value) > 1\n    })\n\n    useRender(() => (\n      <props.tag\n        class={[\n          'v-slide-group',\n          {\n            'v-slide-group--vertical': !isHorizontal.value,\n            'v-slide-group--has-affixes': hasAffixes.value,\n            'v-slide-group--is-overflowing': isOverflowing.value,\n          },\n          displayClasses.value,\n          props.class,\n        ]}\n        style={ props.style }\n        tabindex={ (isFocused.value || group.selected.value.length) ? -1 : 0 }\n        onFocus={ onFocus }\n      >\n        { hasAffixes.value && (\n          <div\n            key=\"prev\"\n            class={[\n              'v-slide-group__prev',\n              { 'v-slide-group__prev--disabled': !hasPrev.value },\n            ]}\n            onMousedown={ onFocusAffixes }\n            onClick={ () => hasPrev.value && scrollTo('prev') }\n          >\n            { slots.prev?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.nextIcon : props.prevIcon }></VIcon>\n              </VFadeTransition>\n            )}\n          </div>\n        )}\n\n        <div\n          key=\"container\"\n          ref={ containerRef }\n          class=\"v-slide-group__container\"\n          onScroll={ onScroll }\n        >\n          <div\n            ref={ contentRef }\n            class=\"v-slide-group__content\"\n            onFocusin={ onFocusin }\n            onFocusout={ onFocusout }\n            onKeydown={ onKeydown }\n          >\n            { slots.default?.(slotProps.value) }\n          </div>\n        </div>\n\n        { hasAffixes.value && (\n          <div\n            key=\"next\"\n            class={[\n              'v-slide-group__next',\n              { 'v-slide-group__next--disabled': !hasNext.value },\n            ]}\n            onMousedown={ onFocusAffixes }\n            onClick={ () => hasNext.value && scrollTo('next') }\n          >\n            { slots.next?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.prevIcon : props.nextIcon }></VIcon>\n              </VFadeTransition>\n            )}\n          </div>\n        )}\n      </props.tag>\n    ))\n\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus,\n      hasPrev,\n      hasNext,\n    }\n  },\n})\n\nexport type VSlideGroup = InstanceType<typeof VSlideGroup>\n"]},"metadata":{},"sourceType":"module"}