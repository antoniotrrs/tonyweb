{"ast":null,"code":"import _toConsumableArray from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n// Composables\nimport { useProxiedModel } from \"../../../composables/proxiedModel.js\"; // Utilities\n\nimport { computed, inject, provide, ref } from 'vue';\nimport { getObjectValueByPath, propsFactory } from \"../../../util/index.js\"; // Types\n\nexport var makeDataTableGroupProps = propsFactory({\n  groupBy: {\n    type: Array,\n    default: function _default() {\n      return [];\n    }\n  }\n}, 'DataTable-group');\nvar VDataTableGroupSymbol = Symbol.for('vuetify:data-table-group');\nexport function createGroupBy(props) {\n  var groupBy = useProxiedModel(props, 'groupBy');\n  return {\n    groupBy: groupBy\n  };\n}\nexport function provideGroupBy(options) {\n  var disableSort = options.disableSort,\n      groupBy = options.groupBy,\n      sortBy = options.sortBy;\n  var opened = ref(new Set());\n  var sortByWithGroups = computed(function () {\n    return groupBy.value.map(function (val) {\n      var _val$order;\n\n      return _objectSpread(_objectSpread({}, val), {}, {\n        order: (_val$order = val.order) !== null && _val$order !== void 0 ? _val$order : false\n      });\n    }).concat(disableSort !== null && disableSort !== void 0 && disableSort.value ? [] : sortBy.value);\n  });\n\n  function isGroupOpen(group) {\n    return opened.value.has(group.id);\n  }\n\n  function toggleGroup(group) {\n    var newOpened = new Set(opened.value);\n    if (!isGroupOpen(group)) newOpened.add(group.id);else newOpened.delete(group.id);\n    opened.value = newOpened;\n  }\n\n  function extractRows(items) {\n    function dive(group) {\n      var arr = [];\n\n      var _iterator = _createForOfIteratorHelper(group.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n\n          if ('type' in item && item.type === 'group') {\n            arr.push.apply(arr, _toConsumableArray(dive(item)));\n          } else {\n            arr.push(item);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return _toConsumableArray(new Set(arr));\n    }\n\n    return dive({\n      type: 'group',\n      items: items,\n      id: 'dummy',\n      key: 'dummy',\n      value: 'dummy',\n      depth: 0\n    });\n  } // onBeforeMount(() => {\n  //   for (const key of groupedItems.value.keys()) {\n  //     opened.value.add(key)\n  //   }\n  // })\n\n\n  var data = {\n    sortByWithGroups: sortByWithGroups,\n    toggleGroup: toggleGroup,\n    opened: opened,\n    groupBy: groupBy,\n    extractRows: extractRows,\n    isGroupOpen: isGroupOpen\n  };\n  provide(VDataTableGroupSymbol, data);\n  return data;\n}\nexport function useGroupBy() {\n  var data = inject(VDataTableGroupSymbol);\n  if (!data) throw new Error('Missing group!');\n  return data;\n}\n\nfunction groupItemsByProperty(items, groupBy) {\n  if (!items.length) return [];\n  var groups = new Map();\n\n  var _iterator2 = _createForOfIteratorHelper(items),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      var value = getObjectValueByPath(item.raw, groupBy);\n\n      if (!groups.has(value)) {\n        groups.set(value, []);\n      }\n\n      groups.get(value).push(item);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return groups;\n}\n\nfunction groupItems(items, groupBy) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'root';\n  if (!groupBy.length) return [];\n  var groupedItems = groupItemsByProperty(items, groupBy[0]);\n  var groups = [];\n  var rest = groupBy.slice(1);\n  groupedItems.forEach(function (items, value) {\n    var key = groupBy[0];\n    var id = \"\".concat(prefix, \"_\").concat(key, \"_\").concat(value);\n    groups.push({\n      depth: depth,\n      id: id,\n      key: key,\n      value: value,\n      items: rest.length ? groupItems(items, rest, depth + 1, id) : items,\n      type: 'group'\n    });\n  });\n  return groups;\n}\n\nfunction flattenItems(items, opened) {\n  var flatItems = [];\n\n  var _iterator3 = _createForOfIteratorHelper(items),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n\n      // TODO: make this better\n      if ('type' in item && item.type === 'group') {\n        if (item.value != null) {\n          flatItems.push(item);\n        }\n\n        if (opened.has(item.id) || item.value == null) {\n          flatItems.push.apply(flatItems, _toConsumableArray(flattenItems(item.items, opened)));\n        }\n      } else {\n        flatItems.push(item);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return flatItems;\n}\n\nexport function useGroupedItems(items, groupBy, opened) {\n  var flatItems = computed(function () {\n    if (!groupBy.value.length) return items.value;\n    var groupedItems = groupItems(items.value, groupBy.value.map(function (item) {\n      return item.key;\n    }));\n    return flattenItems(groupedItems, opened.value);\n  });\n  return {\n    flatItems: flatItems\n  };\n}","map":{"version":3,"mappings":"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","names":["useProxiedModel","computed","inject","provide","ref","getObjectValueByPath","propsFactory","makeDataTableGroupProps","groupBy","type","Array","default","VDataTableGroupSymbol","Symbol","for","createGroupBy","props","provideGroupBy","options","disableSort","sortBy","opened","Set","sortByWithGroups","value","map","val","order","concat","isGroupOpen","group","has","id","toggleGroup","newOpened","add","delete","extractRows","items","dive","arr","item","push","key","depth","data","useGroupBy","Error","groupItemsByProperty","length","groups","Map","raw","set","get","groupItems","prefix","groupedItems","rest","slice","forEach","flattenItems","flatItems","useGroupedItems"],"sources":["../../../../src/components/VDataTable/composables/group.ts"],"sourcesContent":["// Composables\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport { computed, inject, provide, ref } from 'vue'\nimport { getObjectValueByPath, propsFactory } from '@/util'\n\n// Types\nimport type { InjectionKey, PropType, Ref } from 'vue'\nimport type { SortItem } from './sort'\nimport type { DataTableItem } from '../types'\n\nexport interface GroupableItem<T = any> {\n  type: 'item'\n  raw: T\n}\n\nexport interface Group<T = any> {\n  type: 'group'\n  depth: number\n  id: string\n  key: string\n  value: any\n  items: readonly (T | Group<T>)[]\n}\n\nexport const makeDataTableGroupProps = propsFactory({\n  groupBy: {\n    type: Array as PropType<readonly SortItem[]>,\n    default: () => ([]),\n  },\n}, 'DataTable-group')\n\nconst VDataTableGroupSymbol: InjectionKey<{\n  opened: Ref<Set<string>>\n  toggleGroup: (group: Group) => void\n  isGroupOpen: (group: Group) => boolean\n  sortByWithGroups: Ref<SortItem[]>\n  groupBy: Ref<readonly SortItem[]>\n  extractRows: (items: (DataTableItem | Group<DataTableItem>)[]) => DataTableItem[]\n}> = Symbol.for('vuetify:data-table-group')\n\ntype GroupProps = {\n  groupBy: readonly SortItem[]\n  'onUpdate:groupBy': ((value: SortItem[]) => void) | undefined\n}\n\nexport function createGroupBy (props: GroupProps) {\n  const groupBy = useProxiedModel(props, 'groupBy')\n\n  return { groupBy }\n}\n\nexport function provideGroupBy (options: {\n  groupBy: Ref<readonly SortItem[]>\n  sortBy: Ref<readonly SortItem[]>\n  disableSort?: Ref<boolean>\n}) {\n  const { disableSort, groupBy, sortBy } = options\n  const opened = ref(new Set<string>())\n\n  const sortByWithGroups = computed(() => {\n    return groupBy.value.map<SortItem>(val => ({\n      ...val,\n      order: val.order ?? false,\n    })).concat(disableSort?.value ? [] : sortBy.value)\n  })\n\n  function isGroupOpen (group: Group) {\n    return opened.value.has(group.id)\n  }\n\n  function toggleGroup (group: Group) {\n    const newOpened = new Set(opened.value)\n    if (!isGroupOpen(group)) newOpened.add(group.id)\n    else newOpened.delete(group.id)\n\n    opened.value = newOpened\n  }\n\n  function extractRows <T extends GroupableItem> (items: readonly (T | Group<T>)[]) {\n    function dive (group: Group<T>): T[] {\n      const arr = []\n\n      for (const item of group.items) {\n        if ('type' in item && item.type === 'group') {\n          arr.push(...dive(item))\n        } else {\n          arr.push(item as T)\n        }\n      }\n\n      return [...new Set(arr)]\n    }\n    return dive({ type: 'group', items, id: 'dummy', key: 'dummy', value: 'dummy', depth: 0 })\n  }\n\n  // onBeforeMount(() => {\n  //   for (const key of groupedItems.value.keys()) {\n  //     opened.value.add(key)\n  //   }\n  // })\n\n  const data = { sortByWithGroups, toggleGroup, opened, groupBy, extractRows, isGroupOpen }\n\n  provide(VDataTableGroupSymbol, data)\n\n  return data\n}\n\nexport function useGroupBy () {\n  const data = inject(VDataTableGroupSymbol)\n\n  if (!data) throw new Error('Missing group!')\n\n  return data\n}\n\nfunction groupItemsByProperty <T extends GroupableItem> (items: readonly T[], groupBy: string) {\n  if (!items.length) return []\n\n  const groups = new Map<any, T[]>()\n  for (const item of items) {\n    const value = getObjectValueByPath(item.raw, groupBy)\n\n    if (!groups.has(value)) {\n      groups.set(value, [])\n    }\n    groups.get(value)!.push(item)\n  }\n\n  return groups\n}\n\nfunction groupItems <T extends GroupableItem> (items: readonly T[], groupBy: readonly string[], depth = 0, prefix = 'root') {\n  if (!groupBy.length) return []\n\n  const groupedItems = groupItemsByProperty(items, groupBy[0])\n  const groups: Group<T>[] = []\n\n  const rest = groupBy.slice(1)\n  groupedItems.forEach((items, value) => {\n    const key = groupBy[0]\n    const id = `${prefix}_${key}_${value}`\n    groups.push({\n      depth,\n      id,\n      key,\n      value,\n      items: rest.length ? groupItems(items, rest, depth + 1, id) : items,\n      type: 'group',\n    })\n  })\n\n  return groups\n}\n\nfunction flattenItems <T extends GroupableItem> (items: readonly (T | Group<T>)[], opened: Set<string>): readonly (T | Group<T>)[] {\n  const flatItems: (T | Group<T>)[] = []\n\n  for (const item of items) {\n    // TODO: make this better\n    if ('type' in item && item.type === 'group') {\n      if (item.value != null) {\n        flatItems.push(item)\n      }\n\n      if (opened.has(item.id) || item.value == null) {\n        flatItems.push(...flattenItems(item.items, opened))\n      }\n    } else {\n      flatItems.push(item)\n    }\n  }\n\n  return flatItems\n}\n\nexport function useGroupedItems <T extends GroupableItem> (\n  items: Ref<T[]>,\n  groupBy: Ref<readonly SortItem[]>,\n  opened: Ref<Set<string>>\n) {\n  const flatItems = computed(() => {\n    if (!groupBy.value.length) return items.value\n\n    const groupedItems = groupItems(items.value, groupBy.value.map(item => item.key))\n\n    return flattenItems(groupedItems, opened.value)\n  })\n\n  return { flatItems }\n}\n"]},"metadata":{},"sourceType":"module"}