{"ast":null,"code":"// Utilities\nimport { h, mergeProps, render, resolveComponent } from 'vue';\nimport { consoleError, isObject } from \"../util/index.js\"; // Types\n\nexport function useDirectiveComponent(component, props) {\n  const concreteComponent = typeof component === 'string' ? resolveComponent(component) : component;\n  const hook = mountComponent(concreteComponent, props);\n  return {\n    mounted: hook,\n    updated: hook,\n\n    unmounted(el) {\n      render(null, el);\n    }\n\n  };\n}\n\nfunction mountComponent(component, props) {\n  return function (el, binding, vnode) {\n    const _props = typeof props === 'function' ? props(binding) : props;\n\n    const text = binding.value?.text ?? binding.value ?? _props?.text;\n    const value = isObject(binding.value) ? binding.value : {}; // Get the children from the props or directive value, or the element's children\n\n    const children = () => text ?? el.textContent; // If vnode.ctx is the same as the instance, then we're bound to a plain element\n    // and need to find the nearest parent component instance to inherit provides from\n\n\n    const provides = (vnode.ctx === binding.instance.$ ? findComponentParent(vnode, binding.instance.$)?.provides : vnode.ctx?.provides) ?? binding.instance.$.provides;\n    const node = h(component, mergeProps(_props, value), children);\n    node.appContext = Object.assign(Object.create(null), binding.instance.$.appContext, {\n      provides\n    });\n    render(node, el);\n  };\n}\n\nfunction findComponentParent(vnode, root) {\n  // Walk the tree from root until we find the child vnode\n  const stack = new Set();\n\n  const walk = children => {\n    for (const child of children) {\n      if (!child) continue;\n\n      if (child === vnode || child.el && vnode.el && child.el === vnode.el) {\n        return true;\n      }\n\n      stack.add(child);\n      let result;\n\n      if (child.suspense) {\n        result = walk([child.ssContent]);\n      } else if (Array.isArray(child.children)) {\n        result = walk(child.children);\n      } else if (child.component?.vnode) {\n        result = walk([child.component?.subTree]);\n      }\n\n      if (result) {\n        return result;\n      }\n\n      stack.delete(child);\n    }\n\n    return false;\n  };\n\n  if (!walk([root.subTree])) {\n    consoleError('Could not find original vnode, component will not inherit provides');\n    return root;\n  } // Return the first component parent\n\n\n  const result = Array.from(stack).reverse();\n\n  for (const child of result) {\n    if (child.component) {\n      return child.component;\n    }\n  }\n\n  return root;\n}","map":{"version":3,"mappings":"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","names":["h","mergeProps","render","resolveComponent","consoleError","isObject","useDirectiveComponent","component","props","concreteComponent","hook","mountComponent","mounted","updated","unmounted","el","binding","vnode","_props","text","value","children","textContent","provides","ctx","instance","$","findComponentParent","node","appContext","Object","assign","create","root","stack","Set","walk","child","add","result","suspense","ssContent","Array","isArray","subTree","delete","from","reverse"],"sources":["../../src/composables/directiveComponent.ts"],"sourcesContent":["// Utilities\nimport { h, mergeProps, render, resolveComponent } from 'vue'\nimport { consoleError, isObject } from '@/util'\n\n// Types\nimport type {\n  Component,\n  ComponentInternalInstance,\n  ComponentPublicInstance,\n  ConcreteComponent,\n  DirectiveBinding,\n  ObjectDirective,\n  VNode,\n} from 'vue'\nimport type { ComponentInstance } from '@/util'\n\ntype ExcludeProps =\n  | 'v-slots'\n  | `v-slot:${string}`\n  | `on${Uppercase<string>}${string}`\n  | 'key'\n  | 'ref'\n  | 'ref_for'\n  | 'ref_key'\n  | '$children'\n\ndeclare const CustomDirectiveSymbol: unique symbol\ntype DirectiveHook<B extends DirectiveBinding> = (el: any, binding: B, vnode: VNode<any, any>, prevVNode: VNode<any, any>) => void\nexport interface CustomDirective<B extends DirectiveBinding = DirectiveBinding> {\n  created?: DirectiveHook<B>\n  beforeMount?: DirectiveHook<B>\n  mounted?: DirectiveHook<B>\n  beforeUpdate?: DirectiveHook<B>\n  updated?: DirectiveHook<B>\n  beforeUnmount?: DirectiveHook<B>\n  unmounted?: DirectiveHook<B>\n  [CustomDirectiveSymbol]: true\n}\n\nexport function useDirectiveComponent <\n  Binding extends DirectiveBinding,\n> (component: string | Component, props?: (binding: Binding) => Record<string, any>): CustomDirective<Binding>\nexport function useDirectiveComponent <\n  C extends Component,\n  Props = Omit<ComponentInstance<C>['$props'], ExcludeProps>\n> (component: string | C, props?: Record<string, any>): ObjectDirective<any, Props>\nexport function useDirectiveComponent (\n  component: string | Component,\n  props?: Record<string, any> | ((binding: DirectiveBinding) => Record<string, any>)\n): ObjectDirective | CustomDirective {\n  const concreteComponent = (typeof component === 'string'\n    ? resolveComponent(component)\n    : component) as ConcreteComponent\n\n  const hook = mountComponent(concreteComponent, props)\n\n  return {\n    mounted: hook,\n    updated: hook,\n    unmounted (el: HTMLElement) {\n      render(null, el)\n    },\n  }\n}\n\nfunction mountComponent (component: ConcreteComponent, props?: Record<string, any> | ((binding: DirectiveBinding) => Record<string, any>)) {\n  return function (el: HTMLElement, binding: DirectiveBinding, vnode: VNode) {\n    const _props = typeof props === 'function' ? props(binding) : props\n    const text = binding.value?.text ?? binding.value ?? _props?.text\n    const value = isObject(binding.value) ? binding.value : {}\n\n    // Get the children from the props or directive value, or the element's children\n    const children = () => text ?? el.textContent\n\n    // If vnode.ctx is the same as the instance, then we're bound to a plain element\n    // and need to find the nearest parent component instance to inherit provides from\n    const provides = (vnode.ctx === binding.instance!.$\n      ? findComponentParent(vnode, binding.instance!.$)?.provides\n      : vnode.ctx?.provides) ?? binding.instance!.$.provides\n\n    const node = h(component, mergeProps(_props, value), children)\n    node.appContext = Object.assign(\n      Object.create(null),\n      (binding.instance as ComponentPublicInstance).$.appContext,\n      { provides }\n    )\n\n    render(node, el)\n  }\n}\n\nfunction findComponentParent (vnode: VNode, root: ComponentInternalInstance): ComponentInternalInstance | null {\n  // Walk the tree from root until we find the child vnode\n  const stack = new Set<VNode>()\n  const walk = (children: VNode[]): boolean => {\n    for (const child of children) {\n      if (!child) continue\n\n      if (child === vnode || (child.el && vnode.el && child.el === vnode.el)) {\n        return true\n      }\n\n      stack.add(child)\n      let result\n      if (child.suspense) {\n        result = walk([child.ssContent!])\n      } else if (Array.isArray(child.children)) {\n        result = walk(child.children as VNode[])\n      } else if (child.component?.vnode) {\n        result = walk([child.component?.subTree])\n      }\n      if (result) {\n        return result\n      }\n      stack.delete(child)\n    }\n\n    return false\n  }\n  if (!walk([root.subTree])) {\n    consoleError('Could not find original vnode, component will not inherit provides')\n    return root\n  }\n\n  // Return the first component parent\n  const result = Array.from(stack).reverse()\n  for (const child of result) {\n    if (child.component) {\n      return child.component\n    }\n  }\n  return root\n}\n"]},"metadata":{},"sourceType":"module"}