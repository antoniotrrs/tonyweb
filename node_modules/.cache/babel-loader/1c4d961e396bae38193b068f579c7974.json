{"ast":null,"code":"import _toConsumableArray from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.fixed.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.flat.js\";\nimport \"core-js/modules/es.array.unscopables.flat.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.error.cause.js\";\n// Utilities\nimport { capitalize, inject, provide, ref, watchEffect } from 'vue';\nimport { consoleError, propsFactory } from \"../../../util/index.js\"; // Types\n\nexport var makeDataTableHeaderProps = propsFactory({\n  headers: Array\n}, 'DataTable-header');\nexport var VDataTableHeadersSymbol = Symbol.for('vuetify:data-table-headers');\nvar defaultHeader = {\n  title: '',\n  sortable: false\n};\n\nvar defaultActionHeader = _objectSpread(_objectSpread({}, defaultHeader), {}, {\n  width: 48\n});\n\nfunction priorityQueue() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var queue = arr.map(function (element) {\n    return {\n      element: element,\n      priority: 0\n    };\n  });\n  return {\n    enqueue: function enqueue(element, priority) {\n      var added = false;\n\n      for (var i = 0; i < queue.length; i++) {\n        var item = queue[i];\n\n        if (item.priority > priority) {\n          queue.splice(i, 0, {\n            element: element,\n            priority: priority\n          });\n          added = true;\n          break;\n        }\n      }\n\n      if (!added) queue.push({\n        element: element,\n        priority: priority\n      });\n    },\n    size: function size() {\n      return queue.length;\n    },\n    count: function count() {\n      var count = 0;\n      if (!queue.length) return 0;\n      var whole = Math.floor(queue[0].priority);\n\n      for (var i = 0; i < queue.length; i++) {\n        if (Math.floor(queue[i].priority) === whole) count += 1;\n      }\n\n      return count;\n    },\n    dequeue: function dequeue() {\n      return queue.shift();\n    }\n  };\n}\n\nfunction extractLeaves(item) {\n  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!item.children) {\n    columns.push(item);\n  } else {\n    var _iterator = _createForOfIteratorHelper(item.children),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var child = _step.value;\n        extractLeaves(child, columns);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return columns;\n}\n\nfunction extractKeys(headers) {\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n\n  var _iterator2 = _createForOfIteratorHelper(headers),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      if (item.key) keys.add(item.key);\n\n      if (item.children) {\n        extractKeys(item.children, keys);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return keys;\n}\n\nfunction getDefaultItem(item) {\n  if (!item.key) return undefined;\n  if (item.key === 'data-table-group') return defaultHeader;\n  if (['data-table-expand', 'data-table-select'].includes(item.key)) return defaultActionHeader;\n  return undefined;\n}\n\nfunction getDepth(item) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!item.children) return depth;\n  return Math.max.apply(Math, [depth].concat(_toConsumableArray(item.children.map(function (child) {\n    return getDepth(child, depth + 1);\n  }))));\n}\n\nfunction parseFixedColumns(items) {\n  var seenFixed = false;\n\n  function setFixed(item) {\n    var parentFixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!item) return;\n\n    if (parentFixed) {\n      item.fixed = true;\n    }\n\n    if (item.fixed) {\n      if (item.children) {\n        for (var i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i], true);\n        }\n      } else {\n        if (!seenFixed) {\n          item.lastFixed = true;\n        } else if (isNaN(Number(item.width))) {\n          consoleError(\"Multiple fixed columns should have a static width (key: \".concat(item.key, \")\"));\n        } else {\n          item.minWidth = Math.max(Number(item.width) || 0, Number(item.minWidth) || 0);\n        }\n\n        seenFixed = true;\n      }\n    } else {\n      if (item.children) {\n        for (var _i = item.children.length - 1; _i >= 0; _i--) {\n          setFixed(item.children[_i]);\n        }\n      } else {\n        seenFixed = false;\n      }\n    }\n  }\n\n  for (var i = items.length - 1; i >= 0; i--) {\n    setFixed(items[i]);\n  }\n\n  function setFixedOffset(item) {\n    var fixedOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (!item) return fixedOffset;\n\n    if (item.children) {\n      item.fixedOffset = fixedOffset;\n\n      var _iterator3 = _createForOfIteratorHelper(item.children),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          fixedOffset = setFixedOffset(child, fixedOffset);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    } else if (item.fixed) {\n      item.fixedOffset = fixedOffset;\n      fixedOffset += parseFloat(item.width || '0') || 0;\n    }\n\n    return fixedOffset;\n  }\n\n  var fixedOffset = 0;\n\n  var _iterator4 = _createForOfIteratorHelper(items),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var item = _step4.value;\n      fixedOffset = setFixedOffset(item, fixedOffset);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\n\nfunction parse(items, maxDepth) {\n  var headers = [];\n  var currentDepth = 0;\n  var queue = priorityQueue(items);\n\n  while (queue.size() > 0) {\n    var rowSize = queue.count();\n    var row = [];\n    var fraction = 1;\n\n    while (rowSize > 0) {\n      var _queue$dequeue = queue.dequeue(),\n          item = _queue$dequeue.element,\n          priority = _queue$dequeue.priority;\n\n      var diff = maxDepth - currentDepth - getDepth(item);\n      row.push(_objectSpread(_objectSpread({}, item), {}, {\n        rowspan: diff !== null && diff !== void 0 ? diff : 1,\n        colspan: item.children ? extractLeaves(item).length : 1\n      }));\n\n      if (item.children) {\n        var _iterator5 = _createForOfIteratorHelper(item.children),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var child = _step5.value;\n            // This internally sorts items that are on the same priority \"row\"\n            var sort = priority % 1 + fraction / Math.pow(10, currentDepth + 2);\n            queue.enqueue(child, currentDepth + diff + sort);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      fraction += 1;\n      rowSize -= 1;\n    }\n\n    currentDepth += 1;\n    headers.push(row);\n  }\n\n  var columns = items.map(function (item) {\n    return extractLeaves(item);\n  }).flat();\n  return {\n    columns: columns,\n    headers: headers\n  };\n}\n\nfunction convertToInternalHeaders(items) {\n  var internalHeaders = [];\n\n  var _iterator6 = _createForOfIteratorHelper(items),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _defaultItem$key, _ref, _defaultItem$value, _defaultItem$sortable;\n\n      var item = _step6.value;\n\n      var defaultItem = _objectSpread(_objectSpread({}, getDefaultItem(item)), item);\n\n      var key = (_defaultItem$key = defaultItem.key) !== null && _defaultItem$key !== void 0 ? _defaultItem$key : typeof defaultItem.value === 'string' ? defaultItem.value : null;\n      var value = (_ref = (_defaultItem$value = defaultItem.value) !== null && _defaultItem$value !== void 0 ? _defaultItem$value : key) !== null && _ref !== void 0 ? _ref : null;\n\n      var internalItem = _objectSpread(_objectSpread({}, defaultItem), {}, {\n        key: key,\n        value: value,\n        sortable: (_defaultItem$sortable = defaultItem.sortable) !== null && _defaultItem$sortable !== void 0 ? _defaultItem$sortable : defaultItem.key != null || !!defaultItem.sort,\n        children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : undefined\n      });\n\n      internalHeaders.push(internalItem);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return internalHeaders;\n}\n\nexport function createHeaders(props, options) {\n  var headers = ref([]);\n  var columns = ref([]);\n  var sortFunctions = ref({});\n  var sortRawFunctions = ref({});\n  var filterFunctions = ref({});\n  watchEffect(function () {\n    var _props$items$, _options$groupBy, _options$showSelect, _options$showExpand;\n\n    var _headers = props.headers || Object.keys((_props$items$ = props.items[0]) !== null && _props$items$ !== void 0 ? _props$items$ : {}).map(function (key) {\n      return {\n        key: key,\n        title: capitalize(key)\n      };\n    });\n\n    var items = _headers.slice();\n\n    var keys = extractKeys(items);\n\n    if (options !== null && options !== void 0 && (_options$groupBy = options.groupBy) !== null && _options$groupBy !== void 0 && _options$groupBy.value.length && !keys.has('data-table-group')) {\n      items.unshift({\n        key: 'data-table-group',\n        title: 'Group'\n      });\n    }\n\n    if (options !== null && options !== void 0 && (_options$showSelect = options.showSelect) !== null && _options$showSelect !== void 0 && _options$showSelect.value && !keys.has('data-table-select')) {\n      items.unshift({\n        key: 'data-table-select'\n      });\n    }\n\n    if (options !== null && options !== void 0 && (_options$showExpand = options.showExpand) !== null && _options$showExpand !== void 0 && _options$showExpand.value && !keys.has('data-table-expand')) {\n      items.push({\n        key: 'data-table-expand'\n      });\n    }\n\n    var internalHeaders = convertToInternalHeaders(items);\n    parseFixedColumns(internalHeaders);\n    var maxDepth = Math.max.apply(Math, _toConsumableArray(internalHeaders.map(function (item) {\n      return getDepth(item);\n    }))) + 1;\n    var parsed = parse(internalHeaders, maxDepth);\n    headers.value = parsed.headers;\n    columns.value = parsed.columns;\n    var flatHeaders = parsed.headers.flat(1);\n\n    var _iterator7 = _createForOfIteratorHelper(flatHeaders),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var header = _step7.value;\n        if (!header.key) continue;\n\n        if (header.sortable) {\n          if (header.sort) {\n            sortFunctions.value[header.key] = header.sort;\n          }\n\n          if (header.sortRaw) {\n            sortRawFunctions.value[header.key] = header.sortRaw;\n          }\n        }\n\n        if (header.filter) {\n          filterFunctions.value[header.key] = header.filter;\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  });\n  var data = {\n    headers: headers,\n    columns: columns,\n    sortFunctions: sortFunctions,\n    sortRawFunctions: sortRawFunctions,\n    filterFunctions: filterFunctions\n  };\n  provide(VDataTableHeadersSymbol, data);\n  return data;\n}\nexport function useHeaders() {\n  var data = inject(VDataTableHeadersSymbol);\n  if (!data) throw new Error('Missing headers!');\n  return data;\n}","map":{"version":3,"mappings":"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","names":["capitalize","inject","provide","ref","watchEffect","consoleError","propsFactory","makeDataTableHeaderProps","headers","Array","VDataTableHeadersSymbol","Symbol","for","defaultHeader","title","sortable","defaultActionHeader","width","priorityQueue","arr","queue","map","element","priority","enqueue","added","i","length","item","splice","push","size","count","whole","Math","floor","dequeue","shift","extractLeaves","columns","children","child","extractKeys","keys","Set","key","add","getDefaultItem","undefined","includes","getDepth","depth","max","parseFixedColumns","items","seenFixed","setFixed","parentFixed","fixed","lastFixed","isNaN","Number","minWidth","setFixedOffset","fixedOffset","parseFloat","parse","maxDepth","currentDepth","rowSize","row","fraction","diff","rowspan","colspan","sort","pow","flat","convertToInternalHeaders","internalHeaders","defaultItem","value","internalItem","createHeaders","props","options","sortFunctions","sortRawFunctions","filterFunctions","_headers","Object","slice","groupBy","has","unshift","showSelect","showExpand","parsed","flatHeaders","header","sortRaw","filter","data","useHeaders","Error"],"sources":["../../../../src/components/VDataTable/composables/headers.ts"],"sourcesContent":["// Utilities\nimport { capitalize, inject, provide, ref, watchEffect } from 'vue'\nimport { consoleError, propsFactory } from '@/util'\n\n// Types\nimport type { DeepReadonly, InjectionKey, PropType, Ref } from 'vue'\nimport type { SortItem } from './sort'\nimport type { DataTableCompareFunction, DataTableHeader, InternalDataTableHeader } from '../types'\nimport type { FilterKeyFunctions } from '@/composables/filter'\n\nexport const makeDataTableHeaderProps = propsFactory({\n  headers: Array as PropType<DeepReadonly<DataTableHeader[]>>,\n}, 'DataTable-header')\n\nexport const VDataTableHeadersSymbol: InjectionKey<{\n  headers: Ref<InternalDataTableHeader[][]>\n  columns: Ref<InternalDataTableHeader[]>\n}> = Symbol.for('vuetify:data-table-headers')\n\ntype HeaderProps = {\n  headers: DeepReadonly<DataTableHeader[]> | undefined\n  items: any[]\n}\n\nconst defaultHeader = { title: '', sortable: false }\nconst defaultActionHeader = { ...defaultHeader, width: 48 }\n\nfunction priorityQueue <T> (arr: T[] = []) {\n  const queue: { element: T, priority: number }[] = arr.map(element => ({ element, priority: 0 }))\n\n  return {\n    enqueue: (element: T, priority: number) => {\n      let added = false\n      for (let i = 0; i < queue.length; i++) {\n        const item = queue[i]\n        if (item.priority > priority) {\n          queue.splice(i, 0, { element, priority })\n          added = true\n          break\n        }\n      }\n\n      if (!added) queue.push({ element, priority })\n    },\n    size: () => queue.length,\n    count: () => {\n      let count = 0\n\n      if (!queue.length) return 0\n\n      const whole = Math.floor(queue[0].priority)\n      for (let i = 0; i < queue.length; i++) {\n        if (Math.floor(queue[i].priority) === whole) count += 1\n      }\n\n      return count\n    },\n    dequeue: () => {\n      return queue.shift()\n    },\n  }\n}\n\nfunction extractLeaves (item: InternalDataTableHeader, columns: InternalDataTableHeader[] = []) {\n  if (!item.children) {\n    columns.push(item)\n  } else {\n    for (const child of item.children) {\n      extractLeaves(child, columns)\n    }\n  }\n\n  return columns\n}\n\nfunction extractKeys (headers: DeepReadonly<DataTableHeader[]>, keys = new Set<string>()) {\n  for (const item of headers) {\n    if (item.key) keys.add(item.key)\n\n    if (item.children) {\n      extractKeys(item.children, keys)\n    }\n  }\n\n  return keys\n}\n\nfunction getDefaultItem (item: DeepReadonly<DataTableHeader>) {\n  if (!item.key) return undefined\n  if (item.key === 'data-table-group') return defaultHeader\n  if (['data-table-expand', 'data-table-select'].includes(item.key)) return defaultActionHeader\n  return undefined\n}\n\nfunction getDepth (item: InternalDataTableHeader, depth = 0): number {\n  if (!item.children) return depth\n\n  return Math.max(depth, ...item.children.map(child => getDepth(child, depth + 1)))\n}\n\nfunction parseFixedColumns (items: InternalDataTableHeader[]) {\n  let seenFixed = false\n  function setFixed (item: InternalDataTableHeader, parentFixed = false) {\n    if (!item) return\n\n    if (parentFixed) {\n      item.fixed = true\n    }\n\n    if (item.fixed) {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i], true)\n        }\n      } else {\n        if (!seenFixed) {\n          item.lastFixed = true\n        } else if (isNaN(Number(item.width))) {\n          consoleError(`Multiple fixed columns should have a static width (key: ${item.key})`)\n        } else {\n          item.minWidth = Math.max(Number(item.width) || 0, Number(item.minWidth) || 0)\n        }\n        seenFixed = true\n      }\n    } else {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i])\n        }\n      } else {\n        seenFixed = false\n      }\n    }\n  }\n\n  for (let i = items.length - 1; i >= 0; i--) {\n    setFixed(items[i])\n  }\n\n  function setFixedOffset (item: InternalDataTableHeader, fixedOffset = 0) {\n    if (!item) return fixedOffset\n\n    if (item.children) {\n      item.fixedOffset = fixedOffset\n      for (const child of item.children) {\n        fixedOffset = setFixedOffset(child, fixedOffset)\n      }\n    } else if (item.fixed) {\n      item.fixedOffset = fixedOffset\n      fixedOffset += parseFloat(item.width || '0') || 0\n    }\n\n    return fixedOffset\n  }\n\n  let fixedOffset = 0\n  for (const item of items) {\n    fixedOffset = setFixedOffset(item, fixedOffset)\n  }\n}\n\nfunction parse (items: InternalDataTableHeader[], maxDepth: number) {\n  const headers: InternalDataTableHeader[][] = []\n  let currentDepth = 0\n  const queue = priorityQueue(items)\n\n  while (queue.size() > 0) {\n    let rowSize = queue.count()\n    const row: InternalDataTableHeader[] = []\n    let fraction = 1\n    while (rowSize > 0) {\n      const { element: item, priority } = queue.dequeue()!\n      const diff = maxDepth - currentDepth - getDepth(item)\n\n      row.push({\n        ...item,\n        rowspan: diff ?? 1,\n        colspan: item.children ? extractLeaves(item).length : 1,\n      })\n\n      if (item.children) {\n        for (const child of item.children) {\n          // This internally sorts items that are on the same priority \"row\"\n          const sort = priority % 1 + (fraction / Math.pow(10, currentDepth + 2))\n          queue.enqueue(child, currentDepth + diff + sort)\n        }\n      }\n\n      fraction += 1\n      rowSize -= 1\n    }\n    currentDepth += 1\n    headers.push(row)\n  }\n\n  const columns = items.map(item => extractLeaves(item)).flat()\n\n  return { columns, headers }\n}\n\nfunction convertToInternalHeaders (items: DeepReadonly<DataTableHeader[]>) {\n  const internalHeaders: InternalDataTableHeader[] = []\n  for (const item of items) {\n    const defaultItem = { ...getDefaultItem(item), ...item }\n    const key = defaultItem.key ?? (typeof defaultItem.value === 'string' ? defaultItem.value : null)\n    const value = defaultItem.value ?? key ?? null\n    const internalItem: InternalDataTableHeader = {\n      ...defaultItem,\n      key,\n      value,\n      sortable: defaultItem.sortable ?? (defaultItem.key != null || !!defaultItem.sort),\n      children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : undefined,\n    }\n\n    internalHeaders.push(internalItem)\n  }\n\n  return internalHeaders\n}\n\nexport function createHeaders (\n  props: HeaderProps,\n  options?: {\n    groupBy?: Ref<readonly SortItem[]>\n    showSelect?: Ref<boolean>\n    showExpand?: Ref<boolean>\n  }\n) {\n  const headers = ref<InternalDataTableHeader[][]>([])\n  const columns = ref<InternalDataTableHeader[]>([])\n  const sortFunctions = ref<Record<string, DataTableCompareFunction>>({})\n  const sortRawFunctions = ref<Record<string, DataTableCompareFunction>>({})\n  const filterFunctions = ref<FilterKeyFunctions>({})\n\n  watchEffect(() => {\n    const _headers = props.headers ||\n      Object.keys(props.items[0] ?? {}).map(key => ({ key, title: capitalize(key) })) as never\n\n    const items = _headers.slice()\n    const keys = extractKeys(items)\n\n    if (options?.groupBy?.value.length && !keys.has('data-table-group')) {\n      items.unshift({ key: 'data-table-group', title: 'Group' })\n    }\n\n    if (options?.showSelect?.value && !keys.has('data-table-select')) {\n      items.unshift({ key: 'data-table-select' })\n    }\n\n    if (options?.showExpand?.value && !keys.has('data-table-expand')) {\n      items.push({ key: 'data-table-expand' })\n    }\n\n    const internalHeaders = convertToInternalHeaders(items)\n\n    parseFixedColumns(internalHeaders)\n\n    const maxDepth = Math.max(...internalHeaders.map(item => getDepth(item))) + 1\n    const parsed = parse(internalHeaders, maxDepth)\n\n    headers.value = parsed.headers\n    columns.value = parsed.columns\n\n    const flatHeaders = parsed.headers.flat(1)\n\n    for (const header of flatHeaders) {\n      if (!header.key) continue\n\n      if (header.sortable) {\n        if (header.sort) {\n          sortFunctions.value[header.key] = header.sort\n        }\n\n        if (header.sortRaw) {\n          sortRawFunctions.value[header.key] = header.sortRaw\n        }\n      }\n\n      if (header.filter) {\n        filterFunctions.value[header.key] = header.filter\n      }\n    }\n  })\n\n  const data = { headers, columns, sortFunctions, sortRawFunctions, filterFunctions }\n\n  provide(VDataTableHeadersSymbol, data)\n\n  return data\n}\n\nexport function useHeaders () {\n  const data = inject(VDataTableHeadersSymbol)\n\n  if (!data) throw new Error('Missing headers!')\n\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}