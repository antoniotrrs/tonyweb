{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\n// Utilities\nimport { CircularBuffer } from \"../util/index.js\";\nvar HORIZON = 100; // ms\n\nvar HISTORY = 20; // number of samples to keep\n\n/** @see https://android.googlesource.com/platform/frameworks/native/+/master/libs/input/VelocityTracker.cpp */\n\nfunction kineticEnergyToVelocity(work) {\n  var sqrt2 = 1.41421356237;\n  return (work < 0 ? -1.0 : 1.0) * Math.sqrt(Math.abs(work)) * sqrt2;\n}\n/**\n * Returns pointer velocity in px/s\n */\n\n\nexport function calculateImpulseVelocity(samples) {\n  // The input should be in reversed time order (most recent sample at index i=0)\n  if (samples.length < 2) {\n    // if 0 or 1 points, velocity is zero\n    return 0;\n  } // if (samples[1].t > samples[0].t) {\n  //   // Algorithm will still work, but not perfectly\n  //   consoleWarn('Samples provided to calculateImpulseVelocity in the wrong order')\n  // }\n\n\n  if (samples.length === 2) {\n    // if 2 points, basic linear calculation\n    if (samples[1].t === samples[0].t) {\n      // consoleWarn(`Events have identical time stamps t=${samples[0].t}, setting velocity = 0`)\n      return 0;\n    }\n\n    return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);\n  } // Guaranteed to have at least 3 points here\n  // start with the oldest sample and go forward in time\n\n\n  var work = 0;\n\n  for (var i = samples.length - 1; i > 0; i--) {\n    if (samples[i].t === samples[i - 1].t) {\n      // consoleWarn(`Events have identical time stamps t=${samples[i].t}, skipping sample`)\n      continue;\n    }\n\n    var vprev = kineticEnergyToVelocity(work); // v[i-1]\n\n    var vcurr = (samples[i].d - samples[i - 1].d) / (samples[i].t - samples[i - 1].t); // v[i]\n\n    work += (vcurr - vprev) * Math.abs(vcurr);\n\n    if (i === samples.length - 1) {\n      work *= 0.5;\n    }\n  }\n\n  return kineticEnergyToVelocity(work) * 1000;\n}\nexport function useVelocity() {\n  var touches = {};\n\n  function addMovement(e) {\n    Array.from(e.changedTouches).forEach(function (touch) {\n      var _touches$touch$identi;\n\n      var samples = (_touches$touch$identi = touches[touch.identifier]) !== null && _touches$touch$identi !== void 0 ? _touches$touch$identi : touches[touch.identifier] = new CircularBuffer(HISTORY);\n      samples.push([e.timeStamp, touch]);\n    });\n  }\n\n  function endTouch(e) {\n    Array.from(e.changedTouches).forEach(function (touch) {\n      delete touches[touch.identifier];\n    });\n  }\n\n  function getVelocity(id) {\n    var _touches$id;\n\n    var samples = (_touches$id = touches[id]) === null || _touches$id === void 0 ? void 0 : _touches$id.values().reverse();\n\n    if (!samples) {\n      throw new Error(\"No samples for touch id \".concat(id));\n    }\n\n    var newest = samples[0];\n    var x = [];\n    var y = [];\n\n    var _iterator = _createForOfIteratorHelper(samples),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var val = _step.value;\n        if (newest[0] - val[0] > HORIZON) break;\n        x.push({\n          t: val[0],\n          d: val[1].clientX\n        });\n        y.push({\n          t: val[0],\n          d: val[1].clientY\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return {\n      x: calculateImpulseVelocity(x),\n      y: calculateImpulseVelocity(y),\n\n      get direction() {\n        var x = this.x,\n            y = this.y;\n        var _ref = [Math.abs(x), Math.abs(y)],\n            absX = _ref[0],\n            absY = _ref[1];\n        return absX > absY && x >= 0 ? 'right' : absX > absY && x <= 0 ? 'left' : absY > absX && y >= 0 ? 'down' : absY > absX && y <= 0 ? 'up' : oops();\n      }\n\n    };\n  }\n\n  return {\n    addMovement: addMovement,\n    endTouch: endTouch,\n    getVelocity: getVelocity\n  };\n}\n\nfunction oops() {\n  throw new Error();\n}","map":{"version":3,"mappings":"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","names":["CircularBuffer","HORIZON","HISTORY","kineticEnergyToVelocity","work","sqrt2","Math","sqrt","abs","calculateImpulseVelocity","samples","length","t","d","i","vprev","vcurr","useVelocity","touches","addMovement","e","Array","from","changedTouches","forEach","touch","identifier","push","timeStamp","endTouch","getVelocity","id","values","reverse","Error","newest","x","y","val","clientX","clientY","direction","absX","absY","oops"],"sources":["../../src/composables/touch.ts"],"sourcesContent":["// Utilities\nimport { CircularBuffer } from '@/util'\n\nconst HORIZON = 100 // ms\nconst HISTORY = 20 // number of samples to keep\n\nexport interface Sample {\n  t: number\n  d: number\n}\n\n/** @see https://android.googlesource.com/platform/frameworks/native/+/master/libs/input/VelocityTracker.cpp */\nfunction kineticEnergyToVelocity (work: number) {\n  const sqrt2 = 1.41421356237\n  return (work < 0 ? -1.0 : 1.0) * Math.sqrt(Math.abs(work)) * sqrt2\n}\n\n/**\n * Returns pointer velocity in px/s\n */\nexport function calculateImpulseVelocity (samples: Sample[]) {\n  // The input should be in reversed time order (most recent sample at index i=0)\n  if (samples.length < 2) {\n    // if 0 or 1 points, velocity is zero\n    return 0\n  }\n  // if (samples[1].t > samples[0].t) {\n  //   // Algorithm will still work, but not perfectly\n  //   consoleWarn('Samples provided to calculateImpulseVelocity in the wrong order')\n  // }\n  if (samples.length === 2) {\n    // if 2 points, basic linear calculation\n    if (samples[1].t === samples[0].t) {\n      // consoleWarn(`Events have identical time stamps t=${samples[0].t}, setting velocity = 0`)\n      return 0\n    }\n    return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t)\n  }\n  // Guaranteed to have at least 3 points here\n  // start with the oldest sample and go forward in time\n  let work = 0\n  for (let i = samples.length - 1; i > 0; i--) {\n    if (samples[i].t === samples[i - 1].t) {\n      // consoleWarn(`Events have identical time stamps t=${samples[i].t}, skipping sample`)\n      continue\n    }\n    const vprev = kineticEnergyToVelocity(work) // v[i-1]\n    const vcurr = (samples[i].d - samples[i - 1].d) / (samples[i].t - samples[i - 1].t) // v[i]\n    work += (vcurr - vprev) * Math.abs(vcurr)\n    if (i === samples.length - 1) {\n      work *= 0.5\n    }\n  }\n  return kineticEnergyToVelocity(work) * 1000\n}\n\nexport function useVelocity () {\n  const touches: Record<number, CircularBuffer<[number, Touch]> | undefined> = {}\n\n  function addMovement (e: TouchEvent) {\n    Array.from(e.changedTouches).forEach(touch => {\n      const samples = touches[touch.identifier] ?? (touches[touch.identifier] = new CircularBuffer(HISTORY))\n      samples.push([e.timeStamp, touch])\n    })\n  }\n\n  function endTouch (e: TouchEvent) {\n    Array.from(e.changedTouches).forEach(touch => {\n      delete touches[touch.identifier]\n    })\n  }\n\n  function getVelocity (id: number) {\n    const samples = touches[id]?.values().reverse()\n\n    if (!samples) {\n      throw new Error(`No samples for touch id ${id}`)\n    }\n\n    const newest = samples[0]\n    const x: Sample[] = []\n    const y: Sample[] = []\n    for (const val of samples) {\n      if (newest[0] - val[0] > HORIZON) break\n\n      x.push({ t: val[0], d: val[1].clientX })\n      y.push({ t: val[0], d: val[1].clientY })\n    }\n\n    return {\n      x: calculateImpulseVelocity(x),\n      y: calculateImpulseVelocity(y),\n      get direction () {\n        const { x, y } = this\n        const [absX, absY] = [Math.abs(x), Math.abs(y)]\n\n        return absX > absY && x >= 0 ? 'right'\n          : absX > absY && x <= 0 ? 'left'\n          : absY > absX && y >= 0 ? 'down'\n          : absY > absX && y <= 0 ? 'up'\n          : oops()\n      },\n    }\n  }\n\n  return { addMovement, endTouch, getVelocity }\n}\n\nfunction oops (): never {\n  throw new Error()\n}\n"]},"metadata":{},"sourceType":"module"}