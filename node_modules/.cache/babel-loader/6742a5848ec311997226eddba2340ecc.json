{"ast":null,"code":"import _asyncToGenerator from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { createTextVNode as _createTextVNode, createVNode as _createVNode } from \"vue\"; // Styles\n\nimport \"./VInfiniteScroll.css\"; // Components\n\nimport { VBtn } from \"../VBtn/index.js\";\nimport { VProgressCircular } from \"../VProgressCircular/index.js\"; // Composables\n\nimport { makeDimensionProps, useDimension } from \"../../composables/dimensions.js\";\nimport { useIntersectionObserver } from \"../../composables/intersectionObserver.js\";\nimport { useLocale } from \"../../composables/locale.js\";\nimport { makeTagProps } from \"../../composables/tag.js\"; // Utilities\n\nimport { computed, nextTick, onMounted, ref, shallowRef, watch } from 'vue';\nimport { convertToUnit, defineComponent, genericComponent, propsFactory, useRender } from \"../../util/index.js\"; // Types\n\nexport var makeVInfiniteScrollProps = propsFactory(_objectSpread(_objectSpread({\n  color: String,\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: function validator(v) {\n      return ['vertical', 'horizontal'].includes(v);\n    }\n  },\n  side: {\n    type: String,\n    default: 'end',\n    validator: function validator(v) {\n      return ['start', 'end', 'both'].includes(v);\n    }\n  },\n  mode: {\n    type: String,\n    default: 'intersect',\n    validator: function validator(v) {\n      return ['intersect', 'manual'].includes(v);\n    }\n  },\n  margin: [Number, String],\n  loadMoreText: {\n    type: String,\n    default: '$vuetify.infiniteScroll.loadMore'\n  },\n  emptyText: {\n    type: String,\n    default: '$vuetify.infiniteScroll.empty'\n  }\n}, makeDimensionProps()), makeTagProps()), 'VInfiniteScroll');\nexport var VInfiniteScrollIntersect = defineComponent({\n  name: 'VInfiniteScrollIntersect',\n  props: {\n    side: {\n      type: String,\n      required: true\n    },\n    rootMargin: String\n  },\n  emits: {\n    intersect: function intersect(side, isIntersecting) {\n      return true;\n    }\n  },\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n\n    var _useIntersectionObser = useIntersectionObserver(),\n        intersectionRef = _useIntersectionObser.intersectionRef,\n        isIntersecting = _useIntersectionObser.isIntersecting;\n\n    watch(isIntersecting, /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(val) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                emit('intersect', props.side, val);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n    useRender(function () {\n      return _createVNode(\"div\", {\n        \"class\": \"v-infinite-scroll-intersect\",\n        \"style\": {\n          '--v-infinite-margin-size': props.rootMargin\n        },\n        \"ref\": intersectionRef\n      }, [_createTextVNode(\"\\xA0\")]);\n    });\n    return {};\n  }\n});\nexport var VInfiniteScroll = genericComponent()({\n  name: 'VInfiniteScroll',\n  props: makeVInfiniteScrollProps(),\n  emits: {\n    load: function load(options) {\n      return true;\n    }\n  },\n  setup: function setup(props, _ref2) {\n    var slots = _ref2.slots,\n        emit = _ref2.emit;\n    var rootEl = ref();\n    var startStatus = shallowRef('ok');\n    var endStatus = shallowRef('ok');\n    var margin = computed(function () {\n      return convertToUnit(props.margin);\n    });\n    var isIntersecting = shallowRef(false);\n\n    function setScrollAmount(amount) {\n      if (!rootEl.value) return;\n      var property = props.direction === 'vertical' ? 'scrollTop' : 'scrollLeft';\n      rootEl.value[property] = amount;\n    }\n\n    function getScrollAmount() {\n      if (!rootEl.value) return 0;\n      var property = props.direction === 'vertical' ? 'scrollTop' : 'scrollLeft';\n      return rootEl.value[property];\n    }\n\n    function getScrollSize() {\n      if (!rootEl.value) return 0;\n      var property = props.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth';\n      return rootEl.value[property];\n    }\n\n    function getContainerSize() {\n      if (!rootEl.value) return 0;\n      var property = props.direction === 'vertical' ? 'clientHeight' : 'clientWidth';\n      return rootEl.value[property];\n    }\n\n    onMounted(function () {\n      if (!rootEl.value) return;\n\n      if (props.side === 'start') {\n        setScrollAmount(getScrollSize());\n      } else if (props.side === 'both') {\n        setScrollAmount(getScrollSize() / 2 - getContainerSize() / 2);\n      }\n    });\n\n    function setStatus(side, status) {\n      if (side === 'start') {\n        startStatus.value = status;\n      } else if (side === 'end') {\n        endStatus.value = status;\n      }\n    }\n\n    function getStatus(side) {\n      return side === 'start' ? startStatus.value : endStatus.value;\n    }\n\n    var previousScrollSize = 0;\n\n    function handleIntersect(side, _isIntersecting) {\n      isIntersecting.value = _isIntersecting;\n\n      if (isIntersecting.value) {\n        intersecting(side);\n      }\n    }\n\n    function intersecting(side) {\n      if (props.mode !== 'manual' && !isIntersecting.value) return;\n      var status = getStatus(side);\n      if (!rootEl.value || ['empty', 'loading'].includes(status)) return;\n      previousScrollSize = getScrollSize();\n      setStatus(side, 'loading');\n\n      function done(status) {\n        setStatus(side, status);\n        nextTick(function () {\n          if (status === 'empty' || status === 'error') return;\n\n          if (status === 'ok' && side === 'start') {\n            setScrollAmount(getScrollSize() - previousScrollSize + getScrollAmount());\n          }\n\n          if (props.mode !== 'manual') {\n            nextTick(function () {\n              window.requestAnimationFrame(function () {\n                window.requestAnimationFrame(function () {\n                  window.requestAnimationFrame(function () {\n                    intersecting(side);\n                  });\n                });\n              });\n            });\n          }\n        });\n      }\n\n      emit('load', {\n        side: side,\n        done: done\n      });\n    }\n\n    var _useLocale = useLocale(),\n        t = _useLocale.t;\n\n    function renderSide(side, status) {\n      var _slots$error, _slots$empty, _slots$empty2, _slots$loading3, _slots$loading4;\n\n      if (props.side !== side && props.side !== 'both') return;\n\n      var onClick = function onClick() {\n        return intersecting(side);\n      };\n\n      var slotProps = {\n        side: side,\n        props: {\n          onClick: onClick,\n          color: props.color\n        }\n      };\n      if (status === 'error') return (_slots$error = slots.error) === null || _slots$error === void 0 ? void 0 : _slots$error.call(slots, slotProps);\n      if (status === 'empty') return (_slots$empty = (_slots$empty2 = slots.empty) === null || _slots$empty2 === void 0 ? void 0 : _slots$empty2.call(slots, slotProps)) !== null && _slots$empty !== void 0 ? _slots$empty : _createVNode(\"div\", null, [t(props.emptyText)]);\n\n      if (props.mode === 'manual') {\n        var _slots$loadMore, _slots$loadMore2;\n\n        if (status === 'loading') {\n          var _slots$loading, _slots$loading2;\n\n          return (_slots$loading = (_slots$loading2 = slots.loading) === null || _slots$loading2 === void 0 ? void 0 : _slots$loading2.call(slots, slotProps)) !== null && _slots$loading !== void 0 ? _slots$loading : _createVNode(VProgressCircular, {\n            \"indeterminate\": true,\n            \"color\": props.color\n          }, null);\n        }\n\n        return (_slots$loadMore = (_slots$loadMore2 = slots['load-more']) === null || _slots$loadMore2 === void 0 ? void 0 : _slots$loadMore2.call(slots, slotProps)) !== null && _slots$loadMore !== void 0 ? _slots$loadMore : _createVNode(VBtn, {\n          \"variant\": \"outlined\",\n          \"color\": props.color,\n          \"onClick\": onClick\n        }, {\n          default: function _default() {\n            return [t(props.loadMoreText)];\n          }\n        });\n      }\n\n      return (_slots$loading3 = (_slots$loading4 = slots.loading) === null || _slots$loading4 === void 0 ? void 0 : _slots$loading4.call(slots, slotProps)) !== null && _slots$loading3 !== void 0 ? _slots$loading3 : _createVNode(VProgressCircular, {\n        \"indeterminate\": true,\n        \"color\": props.color\n      }, null);\n    }\n\n    var _useDimension = useDimension(props),\n        dimensionStyles = _useDimension.dimensionStyles;\n\n    useRender(function () {\n      var Tag = props.tag;\n      var hasStartIntersect = props.side === 'start' || props.side === 'both';\n      var hasEndIntersect = props.side === 'end' || props.side === 'both';\n      var intersectMode = props.mode === 'intersect';\n      return _createVNode(Tag, {\n        \"ref\": rootEl,\n        \"class\": ['v-infinite-scroll', \"v-infinite-scroll--\".concat(props.direction), {\n          'v-infinite-scroll--start': hasStartIntersect,\n          'v-infinite-scroll--end': hasEndIntersect\n        }],\n        \"style\": dimensionStyles.value\n      }, {\n        default: function _default() {\n          var _slots$default;\n\n          return [_createVNode(\"div\", {\n            \"class\": \"v-infinite-scroll__side\"\n          }, [renderSide('start', startStatus.value)]), hasStartIntersect && intersectMode && _createVNode(VInfiniteScrollIntersect, {\n            \"key\": \"start\",\n            \"side\": \"start\",\n            \"onIntersect\": handleIntersect,\n            \"rootMargin\": margin.value\n          }, null), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots), hasEndIntersect && intersectMode && _createVNode(VInfiniteScrollIntersect, {\n            \"key\": \"end\",\n            \"side\": \"end\",\n            \"onIntersect\": handleIntersect,\n            \"rootMargin\": margin.value\n          }, null), _createVNode(\"div\", {\n            \"class\": \"v-infinite-scroll__side\"\n          }, [renderSide('end', endStatus.value)])];\n        }\n      });\n    });\n  }\n});","map":{"version":3,"mappings":"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","names":["VBtn","VProgressCircular","makeDimensionProps","useDimension","useIntersectionObserver","useLocale","makeTagProps","computed","nextTick","onMounted","ref","shallowRef","watch","convertToUnit","defineComponent","genericComponent","propsFactory","useRender","makeVInfiniteScrollProps","color","String","direction","type","default","validator","v","includes","side","mode","margin","Number","loadMoreText","emptyText","VInfiniteScrollIntersect","name","props","required","rootMargin","emits","intersect","isIntersecting","setup","_ref","emit","intersectionRef","val","VInfiniteScroll","load","options","_ref2","slots","rootEl","startStatus","endStatus","setScrollAmount","amount","value","property","getScrollAmount","getScrollSize","getContainerSize","setStatus","status","getStatus","previousScrollSize","handleIntersect","_isIntersecting","intersecting","done","window","requestAnimationFrame","t","renderSide","onClick","slotProps","error","empty","_createVNode","loading","dimensionStyles","Tag","tag","hasStartIntersect","hasEndIntersect","intersectMode"],"sources":["../../../src/components/VInfiniteScroll/VInfiniteScroll.tsx"],"sourcesContent":["// Styles\nimport './VInfiniteScroll.sass'\n\n// Components\nimport { VBtn } from '@/components/VBtn'\nimport { VProgressCircular } from '@/components/VProgressCircular'\n\n// Composables\nimport { makeDimensionProps, useDimension } from '@/composables/dimensions'\nimport { useIntersectionObserver } from '@/composables/intersectionObserver'\nimport { useLocale } from '@/composables/locale'\nimport { makeTagProps } from '@/composables/tag'\n\n// Utilities\nimport { computed, nextTick, onMounted, ref, shallowRef, watch } from 'vue'\nimport { convertToUnit, defineComponent, genericComponent, propsFactory, useRender } from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\n\nexport type InfiniteScrollSide = 'start' | 'end' | 'both'\nexport type InfiniteScrollStatus = 'ok' | 'empty' | 'loading' | 'error'\n\ntype InfiniteScrollSlot = {\n  side: InfiniteScrollSide\n  props: Record<string, any>\n}\n\ntype VInfiniteScrollSlots = {\n  default: never\n  loading: InfiniteScrollSlot\n  error: InfiniteScrollSlot\n  empty: InfiniteScrollSlot\n  'load-more': InfiniteScrollSlot\n}\n\nexport const makeVInfiniteScrollProps = propsFactory({\n  color: String,\n  direction: {\n    type: String as PropType<'vertical' | 'horizontal'>,\n    default: 'vertical',\n    validator: (v: any) => ['vertical', 'horizontal'].includes(v),\n  },\n  side: {\n    type: String as PropType<InfiniteScrollSide>,\n    default: 'end',\n    validator: (v: any) => ['start', 'end', 'both'].includes(v),\n  },\n  mode: {\n    type: String as PropType<'intersect' | 'manual'>,\n    default: 'intersect',\n    validator: (v: any) => ['intersect', 'manual'].includes(v),\n  },\n  margin: [Number, String],\n  loadMoreText: {\n    type: String,\n    default: '$vuetify.infiniteScroll.loadMore',\n  },\n  emptyText: {\n    type: String,\n    default: '$vuetify.infiniteScroll.empty',\n  },\n\n  ...makeDimensionProps(),\n  ...makeTagProps(),\n}, 'VInfiniteScroll')\n\nexport const VInfiniteScrollIntersect = defineComponent({\n  name: 'VInfiniteScrollIntersect',\n\n  props: {\n    side: {\n      type: String as PropType<InfiniteScrollSide>,\n      required: true,\n    },\n    rootMargin: String,\n  },\n\n  emits: {\n    intersect: (side: InfiniteScrollSide, isIntersecting: boolean) => true,\n  },\n\n  setup (props, { emit }) {\n    const { intersectionRef, isIntersecting } = useIntersectionObserver()\n\n    watch(isIntersecting, async val => {\n      emit('intersect', props.side, val)\n    })\n\n    useRender(() => (\n      <div\n        class=\"v-infinite-scroll-intersect\"\n        style={{\n          '--v-infinite-margin-size': props.rootMargin,\n        }}\n        ref={ intersectionRef }\n      >&nbsp;</div>\n    ))\n\n    return {}\n  },\n})\n\nexport const VInfiniteScroll = genericComponent<VInfiniteScrollSlots>()({\n  name: 'VInfiniteScroll',\n\n  props: makeVInfiniteScrollProps(),\n\n  emits: {\n    load: (options: { side: InfiniteScrollSide, done: (status: InfiniteScrollStatus) => void }) => true,\n  },\n\n  setup (props, { slots, emit }) {\n    const rootEl = ref<HTMLDivElement>()\n    const startStatus = shallowRef<InfiniteScrollStatus>('ok')\n    const endStatus = shallowRef<InfiniteScrollStatus>('ok')\n    const margin = computed(() => convertToUnit(props.margin))\n    const isIntersecting = shallowRef(false)\n\n    function setScrollAmount (amount: number) {\n      if (!rootEl.value) return\n\n      const property = props.direction === 'vertical' ? 'scrollTop' : 'scrollLeft'\n      rootEl.value[property] = amount\n    }\n\n    function getScrollAmount () {\n      if (!rootEl.value) return 0\n\n      const property = props.direction === 'vertical' ? 'scrollTop' : 'scrollLeft'\n      return rootEl.value[property]\n    }\n\n    function getScrollSize () {\n      if (!rootEl.value) return 0\n\n      const property = props.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth'\n      return rootEl.value[property]\n    }\n\n    function getContainerSize () {\n      if (!rootEl.value) return 0\n\n      const property = props.direction === 'vertical' ? 'clientHeight' : 'clientWidth'\n      return rootEl.value[property]\n    }\n\n    onMounted(() => {\n      if (!rootEl.value) return\n\n      if (props.side === 'start') {\n        setScrollAmount(getScrollSize())\n      } else if (props.side === 'both') {\n        setScrollAmount(getScrollSize() / 2 - getContainerSize() / 2)\n      }\n    })\n\n    function setStatus (side: InfiniteScrollSide, status: InfiniteScrollStatus) {\n      if (side === 'start') {\n        startStatus.value = status\n      } else if (side === 'end') {\n        endStatus.value = status\n      }\n    }\n\n    function getStatus (side: string) {\n      return side === 'start' ? startStatus.value : endStatus.value\n    }\n\n    let previousScrollSize = 0\n    function handleIntersect (side: InfiniteScrollSide, _isIntersecting: boolean) {\n      isIntersecting.value = _isIntersecting\n      if (isIntersecting.value) {\n        intersecting(side)\n      }\n    }\n\n    function intersecting (side: InfiniteScrollSide) {\n      if (props.mode !== 'manual' && !isIntersecting.value) return\n\n      const status = getStatus(side)\n      if (!rootEl.value || ['empty', 'loading'].includes(status)) return\n\n      previousScrollSize = getScrollSize()\n      setStatus(side, 'loading')\n\n      function done (status: InfiniteScrollStatus) {\n        setStatus(side, status)\n\n        nextTick(() => {\n          if (status === 'empty' || status === 'error') return\n\n          if (status === 'ok' && side === 'start') {\n            setScrollAmount(getScrollSize() - previousScrollSize + getScrollAmount())\n          }\n          if (props.mode !== 'manual') {\n            nextTick(() => {\n              window.requestAnimationFrame(() => {\n                window.requestAnimationFrame(() => {\n                  window.requestAnimationFrame(() => {\n                    intersecting(side)\n                  })\n                })\n              })\n            })\n          }\n        })\n      }\n\n      emit('load', { side, done })\n    }\n\n    const { t } = useLocale()\n\n    function renderSide (side: InfiniteScrollSide, status: InfiniteScrollStatus) {\n      if (props.side !== side && props.side !== 'both') return\n\n      const onClick = () => intersecting(side)\n      const slotProps = { side, props: { onClick, color: props.color } }\n\n      if (status === 'error') return slots.error?.(slotProps)\n\n      if (status === 'empty') return slots.empty?.(slotProps) ?? <div>{ t(props.emptyText) }</div>\n\n      if (props.mode === 'manual') {\n        if (status === 'loading') {\n          return slots.loading?.(slotProps) ?? (\n            <VProgressCircular indeterminate color={ props.color } />\n          )\n        }\n\n        return slots['load-more']?.(slotProps) ?? (\n          <VBtn variant=\"outlined\" color={ props.color } onClick={ onClick }>\n            { t(props.loadMoreText) }\n          </VBtn>\n        )\n      }\n\n      return slots.loading?.(slotProps) ?? (\n        <VProgressCircular indeterminate color={ props.color } />\n      )\n    }\n\n    const { dimensionStyles } = useDimension(props)\n\n    useRender(() => {\n      const Tag = props.tag\n      const hasStartIntersect = props.side === 'start' || props.side === 'both'\n      const hasEndIntersect = props.side === 'end' || props.side === 'both'\n      const intersectMode = props.mode === 'intersect'\n\n      return (\n        <Tag\n          ref={ rootEl }\n          class={[\n            'v-infinite-scroll',\n            `v-infinite-scroll--${props.direction}`,\n            {\n              'v-infinite-scroll--start': hasStartIntersect,\n              'v-infinite-scroll--end': hasEndIntersect,\n            },\n          ]}\n          style={ dimensionStyles.value }\n        >\n          <div class=\"v-infinite-scroll__side\">\n            { renderSide('start', startStatus.value) }\n          </div>\n\n          { hasStartIntersect && intersectMode && (\n            <VInfiniteScrollIntersect\n              key=\"start\"\n              side=\"start\"\n              onIntersect={ handleIntersect }\n              rootMargin={ margin.value }\n            />\n          )}\n\n          { slots.default?.() }\n\n          { hasEndIntersect && intersectMode && (\n            <VInfiniteScrollIntersect\n              key=\"end\"\n              side=\"end\"\n              onIntersect={ handleIntersect }\n              rootMargin={ margin.value }\n            />\n          )}\n\n          <div class=\"v-infinite-scroll__side\">\n            { renderSide('end', endStatus.value) }\n          </div>\n        </Tag>\n      )\n    })\n  },\n})\n\nexport type VInfiniteScroll = InstanceType<typeof VInfiniteScroll>\n"]},"metadata":{},"sourceType":"module"}