{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n// Composables\nimport { useToggleScope } from \"../../composables/toggleScope.js\";\nimport { useVelocity } from \"../../composables/touch.js\"; // Utilities\n\nimport { computed, onBeforeUnmount, onMounted, onScopeDispose, shallowRef, watchEffect } from 'vue'; // Types\n\nexport function useTouch(_ref) {\n  let {\n    el,\n    isActive,\n    isTemporary,\n    width,\n    touchless,\n    position\n  } = _ref;\n  onMounted(() => {\n    window.addEventListener('touchstart', onTouchstart, {\n      passive: true\n    });\n    window.addEventListener('touchmove', onTouchmove, {\n      passive: false\n    });\n    window.addEventListener('touchend', onTouchend, {\n      passive: true\n    });\n  });\n  onBeforeUnmount(() => {\n    window.removeEventListener('touchstart', onTouchstart);\n    window.removeEventListener('touchmove', onTouchmove);\n    window.removeEventListener('touchend', onTouchend);\n  });\n  const isHorizontal = computed(() => ['left', 'right'].includes(position.value));\n  const {\n    addMovement,\n    endTouch,\n    getVelocity\n  } = useVelocity();\n  let maybeDragging = false;\n  const isDragging = shallowRef(false);\n  const dragProgress = shallowRef(0);\n  const offset = shallowRef(0);\n  let start;\n\n  function getOffset(pos, active) {\n    return (position.value === 'left' ? pos : position.value === 'right' ? document.documentElement.clientWidth - pos : position.value === 'top' ? pos : position.value === 'bottom' ? document.documentElement.clientHeight - pos : oops()) - (active ? width.value : 0);\n  }\n\n  function getProgress(pos) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const progress = position.value === 'left' ? (pos - offset.value) / width.value : position.value === 'right' ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === 'top' ? (pos - offset.value) / width.value : position.value === 'bottom' ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops();\n    return limit ? Math.max(0, Math.min(1, progress)) : progress;\n  }\n\n  function onTouchstart(e) {\n    if (touchless.value) return;\n    const touchX = e.changedTouches[0].clientX;\n    const touchY = e.changedTouches[0].clientY;\n    const touchZone = 25;\n    const inTouchZone = position.value === 'left' ? touchX < touchZone : position.value === 'right' ? touchX > document.documentElement.clientWidth - touchZone : position.value === 'top' ? touchY < touchZone : position.value === 'bottom' ? touchY > document.documentElement.clientHeight - touchZone : oops();\n    const inElement = isActive.value && (position.value === 'left' ? touchX < width.value : position.value === 'right' ? touchX > document.documentElement.clientWidth - width.value : position.value === 'top' ? touchY < width.value : position.value === 'bottom' ? touchY > document.documentElement.clientHeight - width.value : oops());\n\n    if (inTouchZone || inElement || isActive.value && isTemporary.value) {\n      start = [touchX, touchY];\n      offset.value = getOffset(isHorizontal.value ? touchX : touchY, isActive.value);\n      dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);\n      maybeDragging = offset.value > -20 && offset.value < 80;\n      endTouch(e);\n      addMovement(e);\n    }\n  }\n\n  function onTouchmove(e) {\n    const touchX = e.changedTouches[0].clientX;\n    const touchY = e.changedTouches[0].clientY;\n\n    if (maybeDragging) {\n      if (!e.cancelable) {\n        maybeDragging = false;\n        return;\n      }\n\n      const dx = Math.abs(touchX - start[0]);\n      const dy = Math.abs(touchY - start[1]);\n      const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;\n\n      if (thresholdMet) {\n        isDragging.value = true;\n        maybeDragging = false;\n      } else if ((isHorizontal.value ? dy : dx) > 3) {\n        maybeDragging = false;\n      }\n    }\n\n    if (!isDragging.value) return;\n    e.preventDefault();\n    addMovement(e);\n    const progress = getProgress(isHorizontal.value ? touchX : touchY, false);\n    dragProgress.value = Math.max(0, Math.min(1, progress));\n\n    if (progress > 1) {\n      offset.value = getOffset(isHorizontal.value ? touchX : touchY, true);\n    } else if (progress < 0) {\n      offset.value = getOffset(isHorizontal.value ? touchX : touchY, false);\n    }\n  }\n\n  function onTouchend(e) {\n    maybeDragging = false;\n    if (!isDragging.value) return;\n    addMovement(e);\n    isDragging.value = false;\n    const velocity = getVelocity(e.changedTouches[0].identifier);\n    const vx = Math.abs(velocity.x);\n    const vy = Math.abs(velocity.y);\n    const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;\n\n    if (thresholdMet) {\n      isActive.value = velocity.direction === ({\n        left: 'right',\n        right: 'left',\n        top: 'down',\n        bottom: 'up'\n      }[position.value] || oops());\n    } else {\n      isActive.value = dragProgress.value > 0.5;\n    }\n  }\n\n  const dragStyles = computed(() => {\n    return isDragging.value ? {\n      transform: position.value === 'left' ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === 'right' ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === 'top' ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === 'bottom' ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops(),\n      transition: 'none'\n    } : undefined;\n  });\n  useToggleScope(isDragging, () => {\n    const transform = el.value?.style.transform ?? null;\n    const transition = el.value?.style.transition ?? null;\n    watchEffect(() => {\n      el.value?.style.setProperty('transform', dragStyles.value?.transform || 'none');\n      el.value?.style.setProperty('transition', dragStyles.value?.transition || null);\n    });\n    onScopeDispose(() => {\n      el.value?.style.setProperty('transform', transform);\n      el.value?.style.setProperty('transition', transition);\n    });\n  });\n  return {\n    isDragging,\n    dragProgress,\n    dragStyles\n  };\n}\n\nfunction oops() {\n  throw new Error();\n}","map":{"version":3,"mappings":"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","names":["useToggleScope","useVelocity","computed","onBeforeUnmount","onMounted","onScopeDispose","shallowRef","watchEffect","useTouch","_ref","el","isActive","isTemporary","width","touchless","position","window","addEventListener","onTouchstart","passive","onTouchmove","onTouchend","removeEventListener","isHorizontal","includes","value","addMovement","endTouch","getVelocity","maybeDragging","isDragging","dragProgress","offset","start","getOffset","pos","active","document","documentElement","clientWidth","clientHeight","oops","getProgress","limit","progress","Math","max","min","e","touchX","changedTouches","clientX","touchY","clientY","touchZone","inTouchZone","inElement","cancelable","dx","abs","dy","thresholdMet","preventDefault","velocity","identifier","vx","x","vy","y","direction","left","right","top","bottom","dragStyles","transform","transition","undefined","style","setProperty","Error"],"sources":["../../../src/components/VNavigationDrawer/touch.ts"],"sourcesContent":["// Composables\nimport { useToggleScope } from '@/composables/toggleScope'\nimport { useVelocity } from '@/composables/touch'\n\n// Utilities\nimport { computed, onBeforeUnmount, onMounted, onScopeDispose, shallowRef, watchEffect } from 'vue'\n\n// Types\nimport type { Ref } from 'vue'\n\nexport function useTouch ({\n  el,\n  isActive,\n  isTemporary,\n  width,\n  touchless,\n  position,\n}: {\n  el: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n  isTemporary: Ref<boolean>\n  width: Ref<number>\n  touchless: Ref<boolean>\n  position: Ref<'left' | 'right' | 'top' | 'bottom'>\n}) {\n  onMounted(() => {\n    window.addEventListener('touchstart', onTouchstart, { passive: true })\n    window.addEventListener('touchmove', onTouchmove, { passive: false })\n    window.addEventListener('touchend', onTouchend, { passive: true })\n  })\n\n  onBeforeUnmount(() => {\n    window.removeEventListener('touchstart', onTouchstart)\n    window.removeEventListener('touchmove', onTouchmove)\n    window.removeEventListener('touchend', onTouchend)\n  })\n\n  const isHorizontal = computed(() => ['left', 'right'].includes(position.value))\n\n  const { addMovement, endTouch, getVelocity } = useVelocity()\n  let maybeDragging = false\n  const isDragging = shallowRef(false)\n  const dragProgress = shallowRef(0)\n  const offset = shallowRef(0)\n  let start: [number, number] | undefined\n\n  function getOffset (pos: number, active: boolean): number {\n    return (\n      position.value === 'left' ? pos\n      : position.value === 'right' ? document.documentElement.clientWidth - pos\n      : position.value === 'top' ? pos\n      : position.value === 'bottom' ? document.documentElement.clientHeight - pos\n      : oops()\n    ) - (active ? width.value : 0)\n  }\n\n  function getProgress (pos: number, limit = true): number {\n    const progress = (\n      position.value === 'left' ? (pos - offset.value) / width.value\n      : position.value === 'right' ? (document.documentElement.clientWidth - pos - offset.value) / width.value\n      : position.value === 'top' ? (pos - offset.value) / width.value\n      : position.value === 'bottom' ? (document.documentElement.clientHeight - pos - offset.value) / width.value\n      : oops()\n    )\n    return limit ? Math.max(0, Math.min(1, progress)) : progress\n  }\n\n  function onTouchstart (e: TouchEvent) {\n    if (touchless.value) return\n\n    const touchX = e.changedTouches[0].clientX\n    const touchY = e.changedTouches[0].clientY\n\n    const touchZone = 25\n    const inTouchZone: boolean =\n      position.value === 'left' ? touchX < touchZone\n      : position.value === 'right' ? touchX > document.documentElement.clientWidth - touchZone\n      : position.value === 'top' ? touchY < touchZone\n      : position.value === 'bottom' ? touchY > document.documentElement.clientHeight - touchZone\n      : oops()\n\n    const inElement: boolean = isActive.value && (\n      position.value === 'left' ? touchX < width.value\n      : position.value === 'right' ? touchX > document.documentElement.clientWidth - width.value\n      : position.value === 'top' ? touchY < width.value\n      : position.value === 'bottom' ? touchY > document.documentElement.clientHeight - width.value\n      : oops()\n    )\n\n    if (\n      inTouchZone ||\n      inElement ||\n      (isActive.value && isTemporary.value)\n    ) {\n      start = [touchX, touchY]\n\n      offset.value = getOffset(isHorizontal.value ? touchX : touchY, isActive.value)\n      dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY)\n\n      maybeDragging = offset.value > -20 && offset.value < 80\n      endTouch(e)\n      addMovement(e)\n    }\n  }\n\n  function onTouchmove (e: TouchEvent) {\n    const touchX = e.changedTouches[0].clientX\n    const touchY = e.changedTouches[0].clientY\n\n    if (maybeDragging) {\n      if (!e.cancelable) {\n        maybeDragging = false\n        return\n      }\n\n      const dx = Math.abs(touchX - start![0])\n      const dy = Math.abs(touchY - start![1])\n\n      const thresholdMet = isHorizontal.value\n        ? dx > dy && dx > 3\n        : dy > dx && dy > 3\n\n      if (thresholdMet) {\n        isDragging.value = true\n        maybeDragging = false\n      } else if ((isHorizontal.value ? dy : dx) > 3) {\n        maybeDragging = false\n      }\n    }\n\n    if (!isDragging.value) return\n\n    e.preventDefault()\n    addMovement(e)\n\n    const progress = getProgress(isHorizontal.value ? touchX : touchY, false)\n    dragProgress.value = Math.max(0, Math.min(1, progress))\n\n    if (progress > 1) {\n      offset.value = getOffset(isHorizontal.value ? touchX : touchY, true)\n    } else if (progress < 0) {\n      offset.value = getOffset(isHorizontal.value ? touchX : touchY, false)\n    }\n  }\n\n  function onTouchend (e: TouchEvent) {\n    maybeDragging = false\n\n    if (!isDragging.value) return\n\n    addMovement(e)\n\n    isDragging.value = false\n\n    const velocity = getVelocity(e.changedTouches[0].identifier)\n    const vx = Math.abs(velocity.x)\n    const vy = Math.abs(velocity.y)\n    const thresholdMet = isHorizontal.value\n      ? vx > vy && vx > 400\n      : vy > vx && vy > 3\n\n    if (thresholdMet) {\n      isActive.value = velocity.direction === ({\n        left: 'right',\n        right: 'left',\n        top: 'down',\n        bottom: 'up',\n      }[position.value] || oops())\n    } else {\n      isActive.value = dragProgress.value > 0.5\n    }\n  }\n\n  const dragStyles = computed(() => {\n    return isDragging.value ? {\n      transform:\n        position.value === 'left' ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))`\n        : position.value === 'right' ? `translateX(calc(100% - ${dragProgress.value * width.value}px))`\n        : position.value === 'top' ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))`\n        : position.value === 'bottom' ? `translateY(calc(100% - ${dragProgress.value * width.value}px))`\n        : oops(),\n      transition: 'none',\n    } : undefined\n  })\n\n  useToggleScope(isDragging, () => {\n    const transform = el.value?.style.transform ?? null\n    const transition = el.value?.style.transition ?? null\n\n    watchEffect(() => {\n      el.value?.style.setProperty('transform', dragStyles.value?.transform || 'none')\n      el.value?.style.setProperty('transition', dragStyles.value?.transition || null)\n    })\n\n    onScopeDispose(() => {\n      el.value?.style.setProperty('transform', transform)\n      el.value?.style.setProperty('transition', transition)\n    })\n  })\n\n  return {\n    isDragging,\n    dragProgress,\n    dragStyles,\n  }\n}\n\nfunction oops (): never {\n  throw new Error()\n}\n"]},"metadata":{},"sourceType":"module"}