{"ast":null,"code":"// @ts-nocheck\n\n/* eslint-disable */\n// import { checkCollinear, getDistance, moveTo } from './math'\n\n/**\n * From https://github.com/unsplash/react-trend/blob/master/src/helpers/DOM.helpers.js#L18\n */\nexport function genPath(points, radius) {\n  let fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 75;\n  if (points.length === 0) return '';\n  const start = points.shift();\n  const end = points[points.length - 1];\n  return (fill ? `M${start.x} ${height - start.x + 2} L${start.x} ${start.y}` : `M${start.x} ${start.y}`) + points.map((point, index) => {\n    const next = points[index + 1];\n    const prev = points[index - 1] || start;\n    const isCollinear = next && checkCollinear(next, point, prev);\n\n    if (!next || isCollinear) {\n      return `L${point.x} ${point.y}`;\n    }\n\n    const threshold = Math.min(getDistance(prev, point), getDistance(next, point));\n    const isTooCloseForRadius = threshold / 2 < radius;\n    const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;\n    const before = moveTo(prev, point, radiusForPoint);\n    const after = moveTo(next, point, radiusForPoint);\n    return `L${before.x} ${before.y}S${point.x} ${point.y} ${after.x} ${after.y}`;\n  }).join('') + (fill ? `L${end.x} ${height - start.x + 2} Z` : '');\n}\n\nfunction int(value) {\n  return parseInt(value, 10);\n}\n/**\n * https://en.wikipedia.org/wiki/Collinearity\n * x=(x1+x2)/2\n * y=(y1+y2)/2\n */\n\n\nexport function checkCollinear(p0, p1, p2) {\n  return int(p0.x + p2.x) === int(2 * p1.x) && int(p0.y + p2.y) === int(2 * p1.y);\n}\nexport function getDistance(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\nexport function moveTo(to, from, radius) {\n  const vector = {\n    x: to.x - from.x,\n    y: to.y - from.y\n  };\n  const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n  const unitVector = {\n    x: vector.x / length,\n    y: vector.y / length\n  };\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius\n  };\n}","map":{"version":3,"mappings":"AAAA;;AACA;AAGA;;AAEA;AACA;AACA;AACA,OAAO,SAASA,OAAT,CAAkBC,MAAlB,EAAmCC,MAAnC,EAA8E;AAAA,MAA3BC,IAAI,uEAAG,KAAoB;AAAf,MAAEC,MAAM,uEAAG,EAAX;AACpE,MAAIH,MAAM,CAACI,MAAPJ,KAAkB,CAAtB,EAAyB,OAAO,EAAP;AACzB,QAAMK,KAAK,GAAGL,MAAM,CAACM,KAAPN,EAAd;AACA,QAAMO,GAAG,GAAGP,MAAM,CAACA,MAAM,CAACI,MAAPJ,GAAgB,CAAjB,CAAlB;AAEA,SACE,CAACE,IAAI,GAAG,IAAIG,KAAK,CAACG,CAAC,IAAIL,MAAM,GAAGE,KAAK,CAACG,CAAfL,GAAmB,CAAC,KAAKE,KAAK,CAACG,CAAC,IAAIH,KAAK,CAACI,CAAC,EAA7D,GAAkE,IAAIJ,KAAK,CAACG,CAAC,IAAIH,KAAK,CAACI,CAAC,EAA7F,IACAT,MAAM,CACHU,GADHV,CACO,CAACW,KAAD,EAAQC,KAAR,KAAkB;AACrB,UAAMC,IAAI,GAAGb,MAAM,CAACY,KAAK,GAAG,CAAT,CAAnB;AACA,UAAME,IAAI,GAAGd,MAAM,CAACY,KAAK,GAAG,CAAT,CAANZ,IAAqBK,KAAlC;AACA,UAAMU,WAAW,GAAGF,IAAI,IAAIG,cAAc,CAACH,IAAD,EAAOF,KAAP,EAAcG,IAAd,CAA1C;;AAEA,QAAI,CAACD,IAAD,IAASE,WAAb,EAA0B;AACxB,aAAO,IAAIJ,KAAK,CAACH,CAAC,IAAIG,KAAK,CAACF,CAAC,EAA7B;AACF;;AAEA,UAAMQ,SAAS,GAAGC,IAAI,CAACC,GAALD,CAChBE,WAAW,CAACN,IAAD,EAAOH,KAAP,CADKO,EAEhBE,WAAW,CAACP,IAAD,EAAOF,KAAP,CAFKO,CAAlB;AAIA,UAAMG,mBAAmB,GAAGJ,SAAS,GAAG,CAAZA,GAAgBhB,MAA5C;AACA,UAAMqB,cAAc,GAAGD,mBAAmB,GAAGJ,SAAS,GAAG,CAAf,GAAmBhB,MAA7D;AAEA,UAAMsB,MAAM,GAAGC,MAAM,CAACV,IAAD,EAAOH,KAAP,EAAcW,cAAd,CAArB;AACA,UAAMG,KAAK,GAAGD,MAAM,CAACX,IAAD,EAAOF,KAAP,EAAcW,cAAd,CAApB;AAEA,WAAO,IAAIC,MAAM,CAACf,CAAC,IAAIe,MAAM,CAACd,CAAC,IAAIE,KAAK,CAACH,CAAC,IAAIG,KAAK,CAACF,CAAC,IAAIgB,KAAK,CAACjB,CAAC,IAAIiB,KAAK,CAAChB,CAAC,EAA3E;AACD,GArBHT,EAsBG0B,IAtBH1B,CAsBQ,EAtBRA,CADA,IAwBCE,IAAI,GAAG,IAAIK,GAAG,CAACC,CAAC,IAAIL,MAAM,GAAGE,KAAK,CAACG,CAAfL,GAAmB,CAAC,IAApC,GAA2C,EAxBhD,CADF;AA2BF;;AAEA,SAASwB,GAAT,CAAcC,KAAd,EAA8C;AAC5C,SAAOC,QAAQ,CAACD,KAAD,EAAQ,EAAR,CAAf;AACF;AAEA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASZ,cAAT,CAAyBc,EAAzB,EAAoCC,EAApC,EAA+CC,EAA/C,EAAmE;AACxE,SAAOL,GAAG,CAACG,EAAE,CAACtB,CAAHsB,GAAOE,EAAE,CAACxB,CAAX,CAAHmB,KAAqBA,GAAG,CAAC,IAAII,EAAE,CAACvB,CAAR,CAAxBmB,IAAsCA,GAAG,CAACG,EAAE,CAACrB,CAAHqB,GAAOE,EAAE,CAACvB,CAAX,CAAHkB,KAAqBA,GAAG,CAAC,IAAII,EAAE,CAACtB,CAAR,CAArE;AACF;AAEA,OAAO,SAASW,WAAT,CAAsBW,EAAtB,EAAiCC,EAAjC,EAAoD;AACzD,SAAOd,IAAI,CAACe,IAALf,CACLA,IAAI,CAACgB,GAALhB,CAASc,EAAE,CAACxB,CAAHwB,GAAOD,EAAE,CAACvB,CAAnBU,EAAsB,CAAtBA,IAA2BA,IAAI,CAACgB,GAALhB,CAASc,EAAE,CAACvB,CAAHuB,GAAOD,EAAE,CAACtB,CAAnBS,EAAsB,CAAtBA,CADtBA,CAAP;AAGF;AAEA,OAAO,SAASM,MAAT,CAAiBW,EAAjB,EAA4BC,IAA5B,EAAyCnC,MAAzC,EAAyD;AAC9D,QAAMoC,MAAM,GAAG;AAAE7B,KAAC,EAAE2B,EAAE,CAAC3B,CAAH2B,GAAOC,IAAI,CAAC5B,CAAjB;AAAoBC,KAAC,EAAE0B,EAAE,CAAC1B,CAAH0B,GAAOC,IAAI,CAAC3B;AAAnC,GAAf;AACA,QAAML,MAAM,GAAGc,IAAI,CAACe,IAALf,CAAWmB,MAAM,CAAC7B,CAAP6B,GAAWA,MAAM,CAAC7B,CAAlB6B,GAAwBA,MAAM,CAAC5B,CAAP4B,GAAWA,MAAM,CAAC5B,CAArDS,CAAf;AACA,QAAMoB,UAAU,GAAG;AAAE9B,KAAC,EAAE6B,MAAM,CAAC7B,CAAP6B,GAAWjC,MAAhB;AAAwBK,KAAC,EAAE4B,MAAM,CAAC5B,CAAP4B,GAAWjC;AAAtC,GAAnB;AAEA,SAAO;AACLI,KAAC,EAAE4B,IAAI,CAAC5B,CAAL4B,GAASE,UAAU,CAAC9B,CAAX8B,GAAerC,MADtB;AAELQ,KAAC,EAAE2B,IAAI,CAAC3B,CAAL2B,GAASE,UAAU,CAAC7B,CAAX6B,GAAerC;AAFtB,GAAP;AAIF","names":["genPath","points","radius","fill","height","length","start","shift","end","x","y","map","point","index","next","prev","isCollinear","checkCollinear","threshold","Math","min","getDistance","isTooCloseForRadius","radiusForPoint","before","moveTo","after","join","int","value","parseInt","p0","p1","p2","sqrt","pow","to","from","vector","unitVector"],"sources":["../../../../src/components/VSparkline/util/path.ts"],"sourcesContent":["// @ts-nocheck\n/* eslint-disable */\n\nimport { Point } from '../VSparkline'\n// import { checkCollinear, getDistance, moveTo } from './math'\n\n/**\n * From https://github.com/unsplash/react-trend/blob/master/src/helpers/DOM.helpers.js#L18\n */\nexport function genPath (points: Point[], radius: number, fill = false, height = 75) {\n  if (points.length === 0) return ''\n  const start = points.shift()!\n  const end = points[points.length - 1]\n\n  return (\n    (fill ? `M${start.x} ${height - start.x + 2} L${start.x} ${start.y}` : `M${start.x} ${start.y}`) +\n    points\n      .map((point, index) => {\n        const next = points[index + 1]\n        const prev = points[index - 1] || start\n        const isCollinear = next && checkCollinear(next, point, prev)\n\n        if (!next || isCollinear) {\n          return `L${point.x} ${point.y}`\n        }\n\n        const threshold = Math.min(\n          getDistance(prev, point),\n          getDistance(next, point)\n        )\n        const isTooCloseForRadius = threshold / 2 < radius\n        const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius\n\n        const before = moveTo(prev, point, radiusForPoint)\n        const after = moveTo(next, point, radiusForPoint)\n\n        return `L${before.x} ${before.y}S${point.x} ${point.y} ${after.x} ${after.y}`\n      })\n      .join('') +\n    (fill ? `L${end.x} ${height - start.x + 2} Z` : '')\n  )\n}\n\nfunction int (value: string | number): number {\n  return parseInt(value, 10)\n}\n\n/**\n * https://en.wikipedia.org/wiki/Collinearity\n * x=(x1+x2)/2\n * y=(y1+y2)/2\n */\nexport function checkCollinear (p0: Point, p1: Point, p2: Point): boolean {\n  return int(p0.x + p2.x) === int(2 * p1.x) && int(p0.y + p2.y) === int(2 * p1.y)\n}\n\nexport function getDistance (p1: Point, p2: Point): number {\n  return Math.sqrt(\n    Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)\n  )\n}\n\nexport function moveTo (to: Point, from: Point, radius: number) {\n  const vector = { x: to.x - from.x, y: to.y - from.y }\n  const length = Math.sqrt((vector.x * vector.x) + (vector.y * vector.y))\n  const unitVector = { x: vector.x / length, y: vector.y / length }\n\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}