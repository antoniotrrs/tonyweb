{"ast":null,"code":"import _objectSpread from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n// Utilities\nimport { keys } from \"../../util/index.js\"; // Types\n\nvar handleGesture = function handleGesture(wrapper) {\n  var touchstartX = wrapper.touchstartX,\n      touchendX = wrapper.touchendX,\n      touchstartY = wrapper.touchstartY,\n      touchendY = wrapper.touchendY;\n  var dirRatio = 0.5;\n  var minDistance = 16;\n  wrapper.offsetX = touchendX - touchstartX;\n  wrapper.offsetY = touchendY - touchstartY;\n\n  if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {\n    wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);\n    wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);\n  }\n\n  if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {\n    wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);\n    wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);\n  }\n};\n\nfunction _touchstart(event, wrapper) {\n  var _wrapper$start;\n\n  var touch = event.changedTouches[0];\n  wrapper.touchstartX = touch.clientX;\n  wrapper.touchstartY = touch.clientY;\n  (_wrapper$start = wrapper.start) === null || _wrapper$start === void 0 ? void 0 : _wrapper$start.call(wrapper, _objectSpread({\n    originalEvent: event\n  }, wrapper));\n}\n\nfunction _touchend(event, wrapper) {\n  var _wrapper$end;\n\n  var touch = event.changedTouches[0];\n  wrapper.touchendX = touch.clientX;\n  wrapper.touchendY = touch.clientY;\n  (_wrapper$end = wrapper.end) === null || _wrapper$end === void 0 ? void 0 : _wrapper$end.call(wrapper, _objectSpread({\n    originalEvent: event\n  }, wrapper));\n  handleGesture(wrapper);\n}\n\nfunction _touchmove(event, wrapper) {\n  var _wrapper$move;\n\n  var touch = event.changedTouches[0];\n  wrapper.touchmoveX = touch.clientX;\n  wrapper.touchmoveY = touch.clientY;\n  (_wrapper$move = wrapper.move) === null || _wrapper$move === void 0 ? void 0 : _wrapper$move.call(wrapper, _objectSpread({\n    originalEvent: event\n  }, wrapper));\n}\n\nfunction createHandlers() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var wrapper = {\n    touchstartX: 0,\n    touchstartY: 0,\n    touchendX: 0,\n    touchendY: 0,\n    touchmoveX: 0,\n    touchmoveY: 0,\n    offsetX: 0,\n    offsetY: 0,\n    left: value.left,\n    right: value.right,\n    up: value.up,\n    down: value.down,\n    start: value.start,\n    move: value.move,\n    end: value.end\n  };\n  return {\n    touchstart: function touchstart(e) {\n      return _touchstart(e, wrapper);\n    },\n    touchend: function touchend(e) {\n      return _touchend(e, wrapper);\n    },\n    touchmove: function touchmove(e) {\n      return _touchmove(e, wrapper);\n    }\n  };\n}\n\nfunction mounted(el, binding) {\n  var _value$options, _binding$instance, _target$_touchHandler;\n\n  var value = binding.value;\n  var target = value !== null && value !== void 0 && value.parent ? el.parentElement : el;\n  var options = (_value$options = value === null || value === void 0 ? void 0 : value.options) !== null && _value$options !== void 0 ? _value$options : {\n    passive: true\n  };\n  var uid = (_binding$instance = binding.instance) === null || _binding$instance === void 0 ? void 0 : _binding$instance.$.uid; // TODO: use custom uid generator\n\n  if (!target || !uid) return;\n  var handlers = createHandlers(binding.value);\n  target._touchHandlers = (_target$_touchHandler = target._touchHandlers) !== null && _target$_touchHandler !== void 0 ? _target$_touchHandler : Object.create(null);\n  target._touchHandlers[uid] = handlers;\n  keys(handlers).forEach(function (eventName) {\n    target.addEventListener(eventName, handlers[eventName], options);\n  });\n}\n\nfunction unmounted(el, binding) {\n  var _binding$value, _binding$instance2;\n\n  var target = (_binding$value = binding.value) !== null && _binding$value !== void 0 && _binding$value.parent ? el.parentElement : el;\n  var uid = (_binding$instance2 = binding.instance) === null || _binding$instance2 === void 0 ? void 0 : _binding$instance2.$.uid;\n  if (!(target !== null && target !== void 0 && target._touchHandlers) || !uid) return;\n  var handlers = target._touchHandlers[uid];\n  keys(handlers).forEach(function (eventName) {\n    target.removeEventListener(eventName, handlers[eventName]);\n  });\n  delete target._touchHandlers[uid];\n}\n\nexport var Touch = {\n  mounted: mounted,\n  unmounted: unmounted\n};\nexport default Touch;","map":{"version":3,"mappings":"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","names":["keys","handleGesture","wrapper","touchstartX","touchendX","touchstartY","touchendY","dirRatio","minDistance","offsetX","offsetY","Math","abs","left","right","up","down","touchstart","event","touch","changedTouches","clientX","clientY","start","originalEvent","touchend","end","touchmove","touchmoveX","touchmoveY","move","createHandlers","value","e","mounted","el","binding","target","parent","parentElement","options","passive","uid","instance","$","handlers","_touchHandlers","Object","create","forEach","eventName","addEventListener","unmounted","removeEventListener","Touch"],"sources":["../../../src/directives/touch/index.ts"],"sourcesContent":["// Utilities\nimport { keys } from '@/util'\n\n// Types\nimport type {\n  DirectiveBinding,\n} from 'vue'\n\nexport interface TouchHandlers {\n  start?: (wrapperEvent: { originalEvent: TouchEvent } & TouchData) => void\n  end?: (wrapperEvent: { originalEvent: TouchEvent } & TouchData) => void\n  move?: (wrapperEvent: { originalEvent: TouchEvent } & TouchData) => void\n  left?: (wrapper: TouchData) => void\n  right?: (wrapper: TouchData) => void\n  up?: (wrapper: TouchData) => void\n  down?: (wrapper: TouchData) => void\n}\n\nexport interface TouchData {\n  touchstartX: number\n  touchstartY: number\n  touchmoveX: number\n  touchmoveY: number\n  touchendX: number\n  touchendY: number\n  offsetX: number\n  offsetY: number\n}\n\nexport type TouchWrapper = TouchHandlers & TouchData\n\nexport interface TouchValue extends TouchHandlers {\n  parent?: boolean\n  options?: AddEventListenerOptions\n}\n\nexport interface TouchStoredHandlers {\n  touchstart: (e: TouchEvent) => void\n  touchend: (e: TouchEvent) => void\n  touchmove: (e: TouchEvent) => void\n}\n\nexport interface TouchDirectiveBinding extends Omit<DirectiveBinding, 'value'> {\n  value?: TouchValue\n}\n\nconst handleGesture = (wrapper: TouchWrapper) => {\n  const { touchstartX, touchendX, touchstartY, touchendY } = wrapper\n  const dirRatio = 0.5\n  const minDistance = 16\n  wrapper.offsetX = touchendX - touchstartX\n  wrapper.offsetY = touchendY - touchstartY\n\n  if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {\n    wrapper.left && (touchendX < touchstartX - minDistance) && wrapper.left(wrapper)\n    wrapper.right && (touchendX > touchstartX + minDistance) && wrapper.right(wrapper)\n  }\n\n  if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {\n    wrapper.up && (touchendY < touchstartY - minDistance) && wrapper.up(wrapper)\n    wrapper.down && (touchendY > touchstartY + minDistance) && wrapper.down(wrapper)\n  }\n}\n\nfunction touchstart (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchstartX = touch.clientX\n  wrapper.touchstartY = touch.clientY\n\n  wrapper.start?.({ originalEvent: event, ...wrapper })\n}\n\nfunction touchend (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchendX = touch.clientX\n  wrapper.touchendY = touch.clientY\n\n  wrapper.end?.({ originalEvent: event, ...wrapper })\n\n  handleGesture(wrapper)\n}\n\nfunction touchmove (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchmoveX = touch.clientX\n  wrapper.touchmoveY = touch.clientY\n\n  wrapper.move?.({ originalEvent: event, ...wrapper })\n}\n\nfunction createHandlers (value: TouchHandlers = {}): TouchStoredHandlers {\n  const wrapper = {\n    touchstartX: 0,\n    touchstartY: 0,\n    touchendX: 0,\n    touchendY: 0,\n    touchmoveX: 0,\n    touchmoveY: 0,\n    offsetX: 0,\n    offsetY: 0,\n    left: value.left,\n    right: value.right,\n    up: value.up,\n    down: value.down,\n    start: value.start,\n    move: value.move,\n    end: value.end,\n  }\n\n  return {\n    touchstart: (e: TouchEvent) => touchstart(e, wrapper),\n    touchend: (e: TouchEvent) => touchend(e, wrapper),\n    touchmove: (e: TouchEvent) => touchmove(e, wrapper),\n  }\n}\n\nfunction mounted (el: HTMLElement, binding: TouchDirectiveBinding) {\n  const value = binding.value\n  const target = value?.parent ? el.parentElement : el\n  const options = value?.options ?? { passive: true }\n  const uid = binding.instance?.$.uid // TODO: use custom uid generator\n\n  if (!target || !uid) return\n\n  const handlers = createHandlers(binding.value)\n\n  target._touchHandlers = target._touchHandlers ?? Object.create(null)\n  target._touchHandlers![uid] = handlers\n\n  keys(handlers).forEach(eventName => {\n    target.addEventListener(eventName, handlers[eventName], options)\n  })\n}\n\nfunction unmounted (el: HTMLElement, binding: TouchDirectiveBinding) {\n  const target = binding.value?.parent ? el.parentElement : el\n  const uid = binding.instance?.$.uid\n\n  if (!target?._touchHandlers || !uid) return\n\n  const handlers = target._touchHandlers[uid]\n\n  keys(handlers).forEach(eventName => {\n    target.removeEventListener(eventName, handlers[eventName])\n  })\n\n  delete target._touchHandlers[uid]\n}\n\nexport const Touch = {\n  mounted,\n  unmounted,\n}\n\nexport default Touch\n"]},"metadata":{},"sourceType":"module"}