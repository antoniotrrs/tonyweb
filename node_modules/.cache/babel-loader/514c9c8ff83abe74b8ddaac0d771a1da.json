{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\n// Utilities\nimport { h, mergeProps, render, resolveComponent } from 'vue';\nimport { consoleError, isObject } from \"../util/index.js\"; // Types\n\nexport function useDirectiveComponent(component, props) {\n  var concreteComponent = typeof component === 'string' ? resolveComponent(component) : component;\n  var hook = mountComponent(concreteComponent, props);\n  return {\n    mounted: hook,\n    updated: hook,\n    unmounted: function unmounted(el) {\n      render(null, el);\n    }\n  };\n}\n\nfunction mountComponent(component, props) {\n  return function (el, binding, vnode) {\n    var _ref, _binding$value$text, _binding$value, _ref2, _findComponentParent, _vnode$ctx;\n\n    var _props = typeof props === 'function' ? props(binding) : props;\n\n    var text = (_ref = (_binding$value$text = (_binding$value = binding.value) === null || _binding$value === void 0 ? void 0 : _binding$value.text) !== null && _binding$value$text !== void 0 ? _binding$value$text : binding.value) !== null && _ref !== void 0 ? _ref : _props === null || _props === void 0 ? void 0 : _props.text;\n    var value = isObject(binding.value) ? binding.value : {}; // Get the children from the props or directive value, or the element's children\n\n    var children = function children() {\n      return text !== null && text !== void 0 ? text : el.textContent;\n    }; // If vnode.ctx is the same as the instance, then we're bound to a plain element\n    // and need to find the nearest parent component instance to inherit provides from\n\n\n    var provides = (_ref2 = vnode.ctx === binding.instance.$ ? (_findComponentParent = findComponentParent(vnode, binding.instance.$)) === null || _findComponentParent === void 0 ? void 0 : _findComponentParent.provides : (_vnode$ctx = vnode.ctx) === null || _vnode$ctx === void 0 ? void 0 : _vnode$ctx.provides) !== null && _ref2 !== void 0 ? _ref2 : binding.instance.$.provides;\n    var node = h(component, mergeProps(_props, value), children);\n    node.appContext = Object.assign(Object.create(null), binding.instance.$.appContext, {\n      provides: provides\n    });\n    render(node, el);\n  };\n}\n\nfunction findComponentParent(vnode, root) {\n  // Walk the tree from root until we find the child vnode\n  var stack = new Set();\n\n  var walk = function walk(children) {\n    var _iterator = _createForOfIteratorHelper(children),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _child$component;\n\n        var child = _step.value;\n        if (!child) continue;\n\n        if (child === vnode || child.el && vnode.el && child.el === vnode.el) {\n          return true;\n        }\n\n        stack.add(child);\n\n        var _result = void 0;\n\n        if (child.suspense) {\n          _result = walk([child.ssContent]);\n        } else if (Array.isArray(child.children)) {\n          _result = walk(child.children);\n        } else if ((_child$component = child.component) !== null && _child$component !== void 0 && _child$component.vnode) {\n          var _child$component2;\n\n          _result = walk([(_child$component2 = child.component) === null || _child$component2 === void 0 ? void 0 : _child$component2.subTree]);\n        }\n\n        if (_result) {\n          return _result;\n        }\n\n        stack.delete(child);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  if (!walk([root.subTree])) {\n    consoleError('Could not find original vnode, component will not inherit provides');\n    return root;\n  } // Return the first component parent\n\n\n  var result = Array.from(stack).reverse();\n\n  var _iterator2 = _createForOfIteratorHelper(result),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n\n      if (child.component) {\n        return child.component;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return root;\n}","map":{"version":3,"mappings":"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","names":["h","mergeProps","render","resolveComponent","consoleError","isObject","useDirectiveComponent","component","props","concreteComponent","hook","mountComponent","mounted","updated","unmounted","el","binding","vnode","_props","text","value","children","textContent","provides","ctx","instance","$","findComponentParent","node","appContext","Object","assign","create","root","stack","Set","walk","child","add","result","suspense","ssContent","Array","isArray","subTree","delete","from","reverse"],"sources":["../../src/composables/directiveComponent.ts"],"sourcesContent":["// Utilities\nimport { h, mergeProps, render, resolveComponent } from 'vue'\nimport { consoleError, isObject } from '@/util'\n\n// Types\nimport type {\n  Component,\n  ComponentInternalInstance,\n  ComponentPublicInstance,\n  ConcreteComponent,\n  DirectiveBinding,\n  ObjectDirective,\n  VNode,\n} from 'vue'\nimport type { ComponentInstance } from '@/util'\n\ntype ExcludeProps =\n  | 'v-slots'\n  | `v-slot:${string}`\n  | `on${Uppercase<string>}${string}`\n  | 'key'\n  | 'ref'\n  | 'ref_for'\n  | 'ref_key'\n  | '$children'\n\ndeclare const CustomDirectiveSymbol: unique symbol\ntype DirectiveHook<B extends DirectiveBinding> = (el: any, binding: B, vnode: VNode<any, any>, prevVNode: VNode<any, any>) => void\nexport interface CustomDirective<B extends DirectiveBinding = DirectiveBinding> {\n  created?: DirectiveHook<B>\n  beforeMount?: DirectiveHook<B>\n  mounted?: DirectiveHook<B>\n  beforeUpdate?: DirectiveHook<B>\n  updated?: DirectiveHook<B>\n  beforeUnmount?: DirectiveHook<B>\n  unmounted?: DirectiveHook<B>\n  [CustomDirectiveSymbol]: true\n}\n\nexport function useDirectiveComponent <\n  Binding extends DirectiveBinding,\n> (component: string | Component, props?: (binding: Binding) => Record<string, any>): CustomDirective<Binding>\nexport function useDirectiveComponent <\n  C extends Component,\n  Props = Omit<ComponentInstance<C>['$props'], ExcludeProps>\n> (component: string | C, props?: Record<string, any>): ObjectDirective<any, Props>\nexport function useDirectiveComponent (\n  component: string | Component,\n  props?: Record<string, any> | ((binding: DirectiveBinding) => Record<string, any>)\n): ObjectDirective | CustomDirective {\n  const concreteComponent = (typeof component === 'string'\n    ? resolveComponent(component)\n    : component) as ConcreteComponent\n\n  const hook = mountComponent(concreteComponent, props)\n\n  return {\n    mounted: hook,\n    updated: hook,\n    unmounted (el: HTMLElement) {\n      render(null, el)\n    },\n  }\n}\n\nfunction mountComponent (component: ConcreteComponent, props?: Record<string, any> | ((binding: DirectiveBinding) => Record<string, any>)) {\n  return function (el: HTMLElement, binding: DirectiveBinding, vnode: VNode) {\n    const _props = typeof props === 'function' ? props(binding) : props\n    const text = binding.value?.text ?? binding.value ?? _props?.text\n    const value = isObject(binding.value) ? binding.value : {}\n\n    // Get the children from the props or directive value, or the element's children\n    const children = () => text ?? el.textContent\n\n    // If vnode.ctx is the same as the instance, then we're bound to a plain element\n    // and need to find the nearest parent component instance to inherit provides from\n    const provides = (vnode.ctx === binding.instance!.$\n      ? findComponentParent(vnode, binding.instance!.$)?.provides\n      : vnode.ctx?.provides) ?? binding.instance!.$.provides\n\n    const node = h(component, mergeProps(_props, value), children)\n    node.appContext = Object.assign(\n      Object.create(null),\n      (binding.instance as ComponentPublicInstance).$.appContext,\n      { provides }\n    )\n\n    render(node, el)\n  }\n}\n\nfunction findComponentParent (vnode: VNode, root: ComponentInternalInstance): ComponentInternalInstance | null {\n  // Walk the tree from root until we find the child vnode\n  const stack = new Set<VNode>()\n  const walk = (children: VNode[]): boolean => {\n    for (const child of children) {\n      if (!child) continue\n\n      if (child === vnode || (child.el && vnode.el && child.el === vnode.el)) {\n        return true\n      }\n\n      stack.add(child)\n      let result\n      if (child.suspense) {\n        result = walk([child.ssContent!])\n      } else if (Array.isArray(child.children)) {\n        result = walk(child.children as VNode[])\n      } else if (child.component?.vnode) {\n        result = walk([child.component?.subTree])\n      }\n      if (result) {\n        return result\n      }\n      stack.delete(child)\n    }\n\n    return false\n  }\n  if (!walk([root.subTree])) {\n    consoleError('Could not find original vnode, component will not inherit provides')\n    return root\n  }\n\n  // Return the first component parent\n  const result = Array.from(stack).reverse()\n  for (const child of result) {\n    if (child.component) {\n      return child.component\n    }\n  }\n  return root\n}\n"]},"metadata":{},"sourceType":"module"}