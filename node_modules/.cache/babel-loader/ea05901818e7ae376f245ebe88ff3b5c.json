{"ast":null,"code":"// Utilities\nimport { computed, useId, createVNode as _createVNode, Fragment as _Fragment } from 'vue';\nimport { makeLineProps } from \"./util/line.js\";\nimport { genericComponent, getPropertyFromItem, propsFactory, useRender } from \"../../util/index.js\"; // Types\n\nexport const makeVBarlineProps = propsFactory({\n  autoLineWidth: Boolean,\n  ...makeLineProps()\n}, 'VBarline');\nexport const VBarline = genericComponent()({\n  name: 'VBarline',\n  props: makeVBarlineProps(),\n\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const uid = useId();\n    const id = computed(() => props.id || `barline-${uid}`);\n    const autoDrawDuration = computed(() => Number(props.autoDrawDuration) || 500);\n    const hasLabels = computed(() => {\n      return Boolean(props.showLabels || props.labels.length > 0 || !!slots?.label);\n    });\n    const lineWidth = computed(() => parseFloat(props.lineWidth) || 4);\n    const totalWidth = computed(() => Math.max(props.modelValue.length * lineWidth.value, Number(props.width)));\n    const boundary = computed(() => {\n      return {\n        minX: 0,\n        maxX: totalWidth.value,\n        minY: 0,\n        maxY: parseInt(props.height, 10)\n      };\n    });\n    const items = computed(() => props.modelValue.map(item => getPropertyFromItem(item, props.itemValue, item)));\n\n    function genBars(values, boundary) {\n      const {\n        minX,\n        maxX,\n        minY,\n        maxY\n      } = boundary;\n      const totalValues = values.length;\n      let maxValue = props.max != null ? Number(props.max) : Math.max(...values);\n      let minValue = props.min != null ? Number(props.min) : Math.min(...values);\n      if (minValue > 0 && props.min == null) minValue = 0;\n      if (maxValue < 0 && props.max == null) maxValue = 0;\n      const gridX = maxX / totalValues;\n      const gridY = (maxY - minY) / (maxValue - minValue || 1);\n      const horizonY = maxY - Math.abs(minValue * gridY);\n      return values.map((value, index) => {\n        const height = Math.abs(gridY * value);\n        return {\n          x: minX + index * gridX,\n          y: horizonY - height + Number(value < 0) * height,\n          height,\n          value\n        };\n      });\n    }\n\n    const parsedLabels = computed(() => {\n      const labels = [];\n      const points = genBars(items.value, boundary.value);\n      const len = points.length;\n\n      for (let i = 0; labels.length < len; i++) {\n        const item = points[i];\n        let value = props.labels[i];\n\n        if (!value) {\n          value = typeof item === 'object' ? item.value : item;\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value)\n        });\n      }\n\n      return labels;\n    });\n    const bars = computed(() => genBars(items.value, boundary.value));\n    const offsetX = computed(() => (Math.abs(bars.value[0].x - bars.value[1].x) - lineWidth.value) / 2);\n    const smooth = computed(() => typeof props.smooth === 'boolean' ? props.smooth ? 2 : 0 : Number(props.smooth));\n    useRender(() => {\n      const gradientData = !props.gradient.slice().length ? [''] : props.gradient.slice().reverse();\n      return _createVNode(\"svg\", {\n        \"display\": \"block\"\n      }, [_createVNode(\"defs\", null, [_createVNode(\"linearGradient\", {\n        \"id\": id.value,\n        \"gradientUnits\": \"userSpaceOnUse\",\n        \"x1\": props.gradientDirection === 'left' ? '100%' : '0',\n        \"y1\": props.gradientDirection === 'top' ? '100%' : '0',\n        \"x2\": props.gradientDirection === 'right' ? '100%' : '0',\n        \"y2\": props.gradientDirection === 'bottom' ? '100%' : '0'\n      }, [gradientData.map((color, index) => _createVNode(\"stop\", {\n        \"offset\": index / Math.max(gradientData.length - 1, 1),\n        \"stop-color\": color || 'currentColor'\n      }, null))])]), _createVNode(\"clipPath\", {\n        \"id\": `${id.value}-clip`\n      }, [bars.value.map(item => _createVNode(\"rect\", {\n        \"x\": item.x + offsetX.value,\n        \"y\": item.y,\n        \"width\": lineWidth.value,\n        \"height\": item.height,\n        \"rx\": smooth.value,\n        \"ry\": smooth.value\n      }, [props.autoDraw && _createVNode(_Fragment, null, [_createVNode(\"animate\", {\n        \"attributeName\": \"y\",\n        \"from\": item.y + item.height,\n        \"to\": item.y,\n        \"dur\": `${autoDrawDuration.value}ms`,\n        \"fill\": \"freeze\"\n      }, null), _createVNode(\"animate\", {\n        \"attributeName\": \"height\",\n        \"from\": \"0\",\n        \"to\": item.height,\n        \"dur\": `${autoDrawDuration.value}ms`,\n        \"fill\": \"freeze\"\n      }, null)])]))]), hasLabels.value && _createVNode(\"g\", {\n        \"key\": \"labels\",\n        \"style\": {\n          textAnchor: 'middle',\n          dominantBaseline: 'mathematical',\n          fill: 'currentColor'\n        }\n      }, [parsedLabels.value.map((item, i) => _createVNode(\"text\", {\n        \"x\": item.x + offsetX.value + lineWidth.value / 2,\n        \"y\": parseInt(props.height, 10) - 2 + (parseInt(props.labelSize, 10) || 7 * 0.75),\n        \"font-size\": Number(props.labelSize) || 7\n      }, [slots.label?.({\n        index: i,\n        value: item.value\n      }) ?? item.value]))]), _createVNode(\"g\", {\n        \"clip-path\": `url(#${id.value}-clip)`,\n        \"fill\": `url(#${id.value})`\n      }, [_createVNode(\"rect\", {\n        \"x\": 0,\n        \"y\": 0,\n        \"width\": Math.max(props.modelValue.length * lineWidth.value, Number(props.width)),\n        \"height\": props.height\n      }, null)])]);\n    });\n  }\n\n});","map":{"version":3,"mappings":"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","names":["computed","useId","createVNode","Fragment","makeLineProps","genericComponent","getPropertyFromItem","propsFactory","useRender","makeVBarlineProps","autoLineWidth","Boolean","VBarline","name","props","setup","_ref","slots","uid","id","autoDrawDuration","Number","hasLabels","showLabels","labels","length","label","lineWidth","parseFloat","totalWidth","Math","max","modelValue","value","width","boundary","minX","maxX","minY","maxY","parseInt","height","items","map","item","itemValue","genBars","values","totalValues","maxValue","minValue","min","gridX","gridY","horizonY","abs","index","x","y","parsedLabels","points","len","i","push","String","bars","offsetX","smooth","gradientData","gradient","slice","reverse","gradientDirection","color","_createVNode","autoDraw","textAnchor","dominantBaseline","fill","labelSize"],"sources":["../../../src/components/VSparkline/VBarline.tsx"],"sourcesContent":["// Utilities\nimport { computed, useId } from 'vue'\nimport { makeLineProps } from './util/line'\nimport { genericComponent, getPropertyFromItem, propsFactory, useRender } from '@/util'\n\n// Types\nexport type VBarlineSlots = {\n  default: void\n  label: { index: number, value: string }\n}\n\nexport type SparklineItem = number | { value: number }\n\nexport type SparklineText = {\n  x: number\n  value: string\n}\n\nexport interface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport interface Bar {\n  x: number\n  y: number\n  height: number\n  value: number\n}\n\nexport const makeVBarlineProps = propsFactory({\n  autoLineWidth: Boolean,\n\n  ...makeLineProps(),\n}, 'VBarline')\n\nexport const VBarline = genericComponent<VBarlineSlots>()({\n  name: 'VBarline',\n\n  props: makeVBarlineProps(),\n\n  setup (props, { slots }) {\n    const uid = useId()\n    const id = computed(() => props.id || `barline-${uid}`)\n    const autoDrawDuration = computed(() => Number(props.autoDrawDuration) || 500)\n\n    const hasLabels = computed(() => {\n      return Boolean(\n        props.showLabels ||\n        props.labels.length > 0 ||\n        !!slots?.label\n      )\n    })\n\n    const lineWidth = computed(() => parseFloat(props.lineWidth) || 4)\n\n    const totalWidth = computed(() => Math.max(props.modelValue.length * lineWidth.value, Number(props.width)))\n\n    const boundary = computed<Boundary>(() => {\n      return {\n        minX: 0,\n        maxX: totalWidth.value,\n        minY: 0,\n        maxY: parseInt(props.height, 10),\n      }\n    })\n    const items = computed(() => props.modelValue.map(item => getPropertyFromItem(item, props.itemValue, item)))\n\n    function genBars (\n      values: number[],\n      boundary: Boundary\n    ): Bar[] {\n      const { minX, maxX, minY, maxY } = boundary\n      const totalValues = values.length\n      let maxValue = props.max != null ? Number(props.max) : Math.max(...values)\n      let minValue = props.min != null ? Number(props.min) : Math.min(...values)\n\n      if (minValue > 0 && props.min == null) minValue = 0\n      if (maxValue < 0 && props.max == null) maxValue = 0\n\n      const gridX = maxX / totalValues\n      const gridY = (maxY - minY) / ((maxValue - minValue) || 1)\n      const horizonY = maxY - Math.abs(minValue * gridY)\n\n      return values.map((value, index) => {\n        const height = Math.abs(gridY * value)\n\n        return {\n          x: minX + index * gridX,\n          y: horizonY - height +\n            Number(value < 0) * height,\n          height,\n          value,\n        }\n      })\n    }\n\n    const parsedLabels = computed(() => {\n      const labels = []\n      const points = genBars(items.value, boundary.value)\n      const len = points.length\n\n      for (let i = 0; labels.length < len; i++) {\n        const item = points[i]\n        let value = props.labels[i]\n\n        if (!value) {\n          value = typeof item === 'object'\n            ? item.value\n            : item\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value),\n        })\n      }\n\n      return labels\n    })\n\n    const bars = computed(() => genBars(items.value, boundary.value))\n    const offsetX = computed(() => (Math.abs(bars.value[0].x - bars.value[1].x) - lineWidth.value) / 2)\n    const smooth = computed(() => typeof props.smooth === 'boolean' ? (props.smooth ? 2 : 0) : Number(props.smooth))\n\n    useRender(() => {\n      const gradientData = !props.gradient.slice().length ? [''] : props.gradient.slice().reverse()\n      return (\n        <svg\n          display=\"block\"\n        >\n          <defs>\n            <linearGradient\n              id={ id.value }\n              gradientUnits=\"userSpaceOnUse\"\n              x1={ props.gradientDirection === 'left' ? '100%' : '0' }\n              y1={ props.gradientDirection === 'top' ? '100%' : '0' }\n              x2={ props.gradientDirection === 'right' ? '100%' : '0' }\n              y2={ props.gradientDirection === 'bottom' ? '100%' : '0' }\n            >\n              {\n                gradientData.map((color, index) => (\n                  <stop offset={ index / (Math.max(gradientData.length - 1, 1)) } stop-color={ color || 'currentColor' } />\n                ))\n              }\n            </linearGradient>\n          </defs>\n\n          <clipPath id={ `${id.value}-clip` }>\n            {\n              bars.value.map(item => (\n                <rect\n                    x={ item.x + offsetX.value }\n                    y={ item.y }\n                    width={ lineWidth.value }\n                    height={ item.height }\n                    rx={ smooth.value }\n                    ry={ smooth.value }\n                >\n                  { props.autoDraw && (\n                    <>\n                      <animate\n                        attributeName=\"y\"\n                        from={ item.y + item.height }\n                        to={ item.y }\n                        dur={ `${autoDrawDuration.value}ms` }\n                        fill=\"freeze\"\n                      />\n                      <animate\n                        attributeName=\"height\"\n                        from=\"0\"\n                        to={ item.height }\n                        dur={ `${autoDrawDuration.value}ms` }\n                        fill=\"freeze\"\n                      />\n                    </>\n                  )}\n                </rect>\n              ))\n            }\n          </clipPath>\n\n          { hasLabels.value && (\n            <g\n              key=\"labels\"\n              style={{\n                textAnchor: 'middle',\n                dominantBaseline: 'mathematical',\n                fill: 'currentColor',\n              }}\n            >\n              {\n                parsedLabels.value.map((item, i) => (\n                  <text\n                    x={ item.x + offsetX.value + lineWidth.value / 2 }\n                    y={ (parseInt(props.height, 10) - 2) + (parseInt(props.labelSize, 10) || 7 * 0.75) }\n                    font-size={ Number(props.labelSize) || 7 }\n                  >\n                    { slots.label?.({ index: i, value: item.value }) ?? item.value }\n                  </text>\n                ))\n              }\n            </g>\n          )}\n\n          <g\n            clip-path={ `url(#${id.value}-clip)` }\n            fill={ `url(#${id.value})` }\n          >\n            <rect\n              x={ 0 }\n              y={ 0 }\n              width={ Math.max(props.modelValue.length * lineWidth.value, Number(props.width)) }\n              height={ props.height }\n            ></rect>\n          </g>\n        </svg>\n      )\n    })\n  },\n})\n\nexport type VBarline = InstanceType<typeof VBarline>\n"]},"metadata":{},"sourceType":"module"}