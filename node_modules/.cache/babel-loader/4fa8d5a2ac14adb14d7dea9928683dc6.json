{"ast":null,"code":"import _objectSpread from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _typeof from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _toConsumableArray from \"/Users/antoniotorres/Documents/tony/tonyweb/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\n// Composables\nimport { useProxiedModel } from \"../proxiedModel.js\"; // Utilities\n\nimport { computed, inject, onBeforeMount, onBeforeUnmount, provide, ref, shallowRef, toRaw, toRef } from 'vue';\nimport { independentActiveStrategy, independentSingleActiveStrategy, leafActiveStrategy, leafSingleActiveStrategy } from \"./activeStrategies.js\";\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from \"./openStrategies.js\";\nimport { classicSelectStrategy, independentSelectStrategy, independentSingleSelectStrategy, leafSelectStrategy, leafSingleSelectStrategy, trunkSelectStrategy } from \"./selectStrategies.js\";\nimport { consoleError, getCurrentInstance, propsFactory } from \"../../util/index.js\"; // Types\n\nexport var VNestedSymbol = Symbol.for('vuetify:nested');\nexport var emptyNested = {\n  id: shallowRef(),\n  root: {\n    register: function register() {\n      return null;\n    },\n    unregister: function unregister() {\n      return null;\n    },\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: function open() {\n      return null;\n    },\n    openOnSelect: function openOnSelect() {\n      return null;\n    },\n    activate: function activate() {\n      return null;\n    },\n    select: function select() {\n      return null;\n    },\n    activatable: ref(false),\n    selectable: ref(false),\n    opened: ref(new Set()),\n    activated: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([]),\n    getPath: function getPath() {\n      return [];\n    }\n  }\n};\nexport var makeNestedProps = propsFactory({\n  activatable: Boolean,\n  selectable: Boolean,\n  activeStrategy: [String, Function, Object],\n  selectStrategy: [String, Function, Object],\n  openStrategy: [String, Object],\n  opened: null,\n  activated: null,\n  selected: null,\n  mandatory: Boolean\n}, 'nested');\nexport var useNested = function useNested(props) {\n  var isUnmounted = false;\n  var children = ref(new Map());\n  var parents = ref(new Map());\n  var opened = useProxiedModel(props, 'opened', props.opened, function (v) {\n    return new Set(v);\n  }, function (v) {\n    return _toConsumableArray(v.values());\n  });\n  var activeStrategy = computed(function () {\n    if (_typeof(props.activeStrategy) === 'object') return props.activeStrategy;\n    if (typeof props.activeStrategy === 'function') return props.activeStrategy(props.mandatory);\n\n    switch (props.activeStrategy) {\n      case 'leaf':\n        return leafActiveStrategy(props.mandatory);\n\n      case 'single-leaf':\n        return leafSingleActiveStrategy(props.mandatory);\n\n      case 'independent':\n        return independentActiveStrategy(props.mandatory);\n\n      case 'single-independent':\n      default:\n        return independentSingleActiveStrategy(props.mandatory);\n    }\n  });\n  var selectStrategy = computed(function () {\n    if (_typeof(props.selectStrategy) === 'object') return props.selectStrategy;\n    if (typeof props.selectStrategy === 'function') return props.selectStrategy(props.mandatory);\n\n    switch (props.selectStrategy) {\n      case 'single-leaf':\n        return leafSingleSelectStrategy(props.mandatory);\n\n      case 'leaf':\n        return leafSelectStrategy(props.mandatory);\n\n      case 'independent':\n        return independentSelectStrategy(props.mandatory);\n\n      case 'single-independent':\n        return independentSingleSelectStrategy(props.mandatory);\n\n      case 'trunk':\n        return trunkSelectStrategy(props.mandatory);\n\n      case 'classic':\n      default:\n        return classicSelectStrategy(props.mandatory);\n    }\n  });\n  var openStrategy = computed(function () {\n    if (_typeof(props.openStrategy) === 'object') return props.openStrategy;\n\n    switch (props.openStrategy) {\n      case 'list':\n        return listOpenStrategy;\n\n      case 'single':\n        return singleOpenStrategy;\n\n      case 'multiple':\n      default:\n        return multipleOpenStrategy;\n    }\n  });\n  var activated = useProxiedModel(props, 'activated', props.activated, function (v) {\n    return activeStrategy.value.in(v, children.value, parents.value);\n  }, function (v) {\n    return activeStrategy.value.out(v, children.value, parents.value);\n  });\n  var selected = useProxiedModel(props, 'selected', props.selected, function (v) {\n    return selectStrategy.value.in(v, children.value, parents.value);\n  }, function (v) {\n    return selectStrategy.value.out(v, children.value, parents.value);\n  });\n  onBeforeUnmount(function () {\n    isUnmounted = true;\n  });\n\n  function getPath(id) {\n    var path = [];\n    var parent = id;\n\n    while (parent != null) {\n      path.unshift(parent);\n      parent = parents.value.get(parent);\n    }\n\n    return path;\n  }\n\n  var vm = getCurrentInstance('nested');\n  var nodeIds = new Set();\n  var nested = {\n    id: shallowRef(),\n    root: {\n      opened: opened,\n      activatable: toRef(props, 'activatable'),\n      selectable: toRef(props, 'selectable'),\n      activated: activated,\n      selected: selected,\n      selectedValues: computed(function () {\n        var arr = [];\n\n        var _iterator = _createForOfIteratorHelper(selected.value.entries()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                key = _step$value[0],\n                value = _step$value[1];\n\n            if (value === 'on') arr.push(key);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return arr;\n      }),\n      register: function register(id, parentId, isGroup) {\n        if (nodeIds.has(id)) {\n          var path = getPath(id).map(String).join(' -> ');\n          var newPath = getPath(parentId).concat(id).map(String).join(' -> ');\n          consoleError(\"Multiple nodes with the same ID\\n\\t\".concat(path, \"\\n\\t\").concat(newPath));\n          return;\n        } else {\n          nodeIds.add(id);\n        }\n\n        parentId && id !== parentId && parents.value.set(id, parentId);\n        isGroup && children.value.set(id, []);\n\n        if (parentId != null) {\n          children.value.set(parentId, [].concat(_toConsumableArray(children.value.get(parentId) || []), [id]));\n        }\n      },\n      unregister: function unregister(id) {\n        if (isUnmounted) return;\n        nodeIds.delete(id);\n        children.value.delete(id);\n        var parent = parents.value.get(id);\n\n        if (parent) {\n          var _children$value$get;\n\n          var list = (_children$value$get = children.value.get(parent)) !== null && _children$value$get !== void 0 ? _children$value$get : [];\n          children.value.set(parent, list.filter(function (child) {\n            return child !== id;\n          }));\n        }\n\n        parents.value.delete(id);\n      },\n      open: function open(id, value, event) {\n        vm.emit('click:open', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newOpened = openStrategy.value.open({\n          id: id,\n          value: value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      openOnSelect: function openOnSelect(id, value, event) {\n        var newOpened = openStrategy.value.select({\n          id: id,\n          value: value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      select: function select(id, value, event) {\n        vm.emit('click:select', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newSelected = selectStrategy.value.select({\n          id: id,\n          value: value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newSelected && (selected.value = newSelected);\n        nested.root.openOnSelect(id, value, event);\n      },\n      activate: function activate(id, value, event) {\n        if (!props.activatable) {\n          return nested.root.select(id, true, event);\n        }\n\n        vm.emit('click:activate', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newActivated = activeStrategy.value.activate({\n          id: id,\n          value: value,\n          activated: new Set(activated.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n\n        if (newActivated.size !== activated.value.size) {\n          activated.value = newActivated;\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(newActivated),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _value = _step2.value;\n\n              if (!activated.value.has(_value)) {\n                activated.value = newActivated;\n                return;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var _iterator3 = _createForOfIteratorHelper(activated.value),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _value2 = _step3.value;\n\n              if (!newActivated.has(_value2)) {\n                activated.value = newActivated;\n                return;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      },\n      children: children,\n      parents: parents,\n      getPath: getPath\n    }\n  };\n  provide(VNestedSymbol, nested);\n  return nested.root;\n};\nexport var useNestedItem = function useNestedItem(id, isGroup) {\n  var parent = inject(VNestedSymbol, emptyNested);\n  var uidSymbol = Symbol('nested item');\n  var computedId = computed(function () {\n    return id.value !== undefined ? id.value : uidSymbol;\n  });\n\n  var item = _objectSpread(_objectSpread({}, parent), {}, {\n    id: computedId,\n    open: function open(_open, e) {\n      return parent.root.open(computedId.value, _open, e);\n    },\n    openOnSelect: function openOnSelect(open, e) {\n      return parent.root.openOnSelect(computedId.value, open, e);\n    },\n    isOpen: computed(function () {\n      return parent.root.opened.value.has(computedId.value);\n    }),\n    parent: computed(function () {\n      return parent.root.parents.value.get(computedId.value);\n    }),\n    activate: function activate(activated, e) {\n      return parent.root.activate(computedId.value, activated, e);\n    },\n    isActivated: computed(function () {\n      return parent.root.activated.value.has(toRaw(computedId.value));\n    }),\n    select: function select(selected, e) {\n      return parent.root.select(computedId.value, selected, e);\n    },\n    isSelected: computed(function () {\n      return parent.root.selected.value.get(toRaw(computedId.value)) === 'on';\n    }),\n    isIndeterminate: computed(function () {\n      return parent.root.selected.value.get(toRaw(computedId.value)) === 'indeterminate';\n    }),\n    isLeaf: computed(function () {\n      return !parent.root.children.value.get(computedId.value);\n    }),\n    isGroupActivator: parent.isGroupActivator\n  });\n\n  onBeforeMount(function () {\n    !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);\n  });\n  onBeforeUnmount(function () {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value);\n  });\n  isGroup && provide(VNestedSymbol, item);\n  return item;\n};\nexport var useNestedGroupActivator = function useNestedGroupActivator() {\n  var parent = inject(VNestedSymbol, emptyNested);\n  provide(VNestedSymbol, _objectSpread(_objectSpread({}, parent), {}, {\n    isGroupActivator: true\n  }));\n};","map":{"version":3,"mappings":"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","names":["useProxiedModel","computed","inject","onBeforeMount","onBeforeUnmount","provide","ref","shallowRef","toRaw","toRef","independentActiveStrategy","independentSingleActiveStrategy","leafActiveStrategy","leafSingleActiveStrategy","listOpenStrategy","multipleOpenStrategy","singleOpenStrategy","classicSelectStrategy","independentSelectStrategy","independentSingleSelectStrategy","leafSelectStrategy","leafSingleSelectStrategy","trunkSelectStrategy","consoleError","getCurrentInstance","propsFactory","VNestedSymbol","Symbol","for","emptyNested","id","root","register","unregister","parents","Map","children","open","openOnSelect","activate","select","activatable","selectable","opened","Set","activated","selected","selectedValues","getPath","makeNestedProps","Boolean","activeStrategy","String","Function","Object","selectStrategy","openStrategy","mandatory","useNested","props","isUnmounted","v","values","value","in","out","path","parent","unshift","get","vm","nodeIds","nested","arr","entries","key","push","parentId","isGroup","has","map","join","newPath","concat","add","set","delete","list","filter","child","event","emit","newOpened","newSelected","newActivated","size","useNestedItem","uidSymbol","computedId","undefined","item","e","isOpen","isActivated","isSelected","isIndeterminate","isLeaf","isGroupActivator","useNestedGroupActivator"],"sources":["../../../src/composables/nested/nested.ts"],"sourcesContent":["// Composables\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport {\n  computed,\n  inject,\n  onBeforeMount,\n  onBeforeUnmount,\n  provide,\n  ref,\n  shallowRef,\n  toRaw,\n  toRef,\n} from 'vue'\nimport {\n  independentActiveStrategy,\n  independentSingleActiveStrategy,\n  leafActiveStrategy,\n  leafSingleActiveStrategy,\n} from './activeStrategies'\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from './openStrategies'\nimport {\n  classicSelectStrategy,\n  independentSelectStrategy,\n  independentSingleSelectStrategy,\n  leafSelectStrategy,\n  leafSingleSelectStrategy,\n  trunkSelectStrategy,\n} from './selectStrategies'\nimport { consoleError, getCurrentInstance, propsFactory } from '@/util'\n\n// Types\nimport type { InjectionKey, PropType, Ref } from 'vue'\nimport type { ActiveStrategy } from './activeStrategies'\nimport type { OpenStrategy } from './openStrategies'\nimport type { SelectStrategy } from './selectStrategies'\nimport type { EventProp } from '@/util'\n\nexport type ActiveStrategyProp =\n  | 'single-leaf'\n  | 'leaf'\n  | 'independent'\n  | 'single-independent'\n  | ActiveStrategy\n  | ((mandatory: boolean) => ActiveStrategy)\nexport type SelectStrategyProp =\n  | 'single-leaf'\n  | 'leaf'\n  | 'independent'\n  | 'single-independent'\n  | 'classic'\n  | 'trunk'\n  | SelectStrategy\n  | ((mandatory: boolean) => SelectStrategy)\nexport type OpenStrategyProp = 'single' | 'multiple' | 'list' | OpenStrategy\n\nexport interface NestedProps {\n  activatable: boolean\n  selectable: boolean\n  activeStrategy: ActiveStrategyProp | undefined\n  selectStrategy: SelectStrategyProp | undefined\n  openStrategy: OpenStrategyProp | undefined\n  activated: any\n  selected: any\n  opened: any\n  mandatory: boolean\n  'onUpdate:activated': EventProp<[any]> | undefined\n  'onUpdate:selected': EventProp<[any]> | undefined\n  'onUpdate:opened': EventProp<[any]> | undefined\n}\n\ntype NestedProvide = {\n  id: Ref<unknown>\n  isGroupActivator?: boolean\n  root: {\n    children: Ref<Map<unknown, unknown[]>>\n    parents: Ref<Map<unknown, unknown>>\n    activatable: Ref<boolean>\n    selectable: Ref<boolean>\n    opened: Ref<Set<unknown>>\n    activated: Ref<Set<unknown>>\n    selected: Ref<Map<unknown, 'on' | 'off' | 'indeterminate'>>\n    selectedValues: Ref<unknown[]>\n    register: (id: unknown, parentId: unknown, isGroup?: boolean) => void\n    unregister: (id: unknown) => void\n    open: (id: unknown, value: boolean, event?: Event) => void\n    activate: (id: unknown, value: boolean, event?: Event) => void\n    select: (id: unknown, value: boolean, event?: Event) => void\n    openOnSelect: (id: unknown, value: boolean, event?: Event) => void\n    getPath: (id: unknown) => unknown[]\n  }\n}\n\nexport const VNestedSymbol: InjectionKey<NestedProvide> = Symbol.for('vuetify:nested')\n\nexport const emptyNested: NestedProvide = {\n  id: shallowRef(),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    openOnSelect: () => null,\n    activate: () => null,\n    select: () => null,\n    activatable: ref(false),\n    selectable: ref(false),\n    opened: ref(new Set()),\n    activated: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([]),\n    getPath: () => [],\n  },\n}\n\nexport const makeNestedProps = propsFactory({\n  activatable: Boolean,\n  selectable: Boolean,\n  activeStrategy: [String, Function, Object] as PropType<ActiveStrategyProp>,\n  selectStrategy: [String, Function, Object] as PropType<SelectStrategyProp>,\n  openStrategy: [String, Object] as PropType<OpenStrategyProp>,\n  opened: null,\n  activated: null,\n  selected: null,\n  mandatory: Boolean,\n}, 'nested')\n\nexport const useNested = (props: NestedProps) => {\n  let isUnmounted = false\n  const children = ref(new Map<unknown, unknown[]>())\n  const parents = ref(new Map<unknown, unknown>())\n\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()])\n\n  const activeStrategy = computed(() => {\n    if (typeof props.activeStrategy === 'object') return props.activeStrategy\n    if (typeof props.activeStrategy === 'function') return props.activeStrategy(props.mandatory)\n\n    switch (props.activeStrategy) {\n      case 'leaf': return leafActiveStrategy(props.mandatory)\n      case 'single-leaf': return leafSingleActiveStrategy(props.mandatory)\n      case 'independent': return independentActiveStrategy(props.mandatory)\n      case 'single-independent':\n      default: return independentSingleActiveStrategy(props.mandatory)\n    }\n  })\n\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy\n    if (typeof props.selectStrategy === 'function') return props.selectStrategy(props.mandatory)\n\n    switch (props.selectStrategy) {\n      case 'single-leaf': return leafSingleSelectStrategy(props.mandatory)\n      case 'leaf': return leafSelectStrategy(props.mandatory)\n      case 'independent': return independentSelectStrategy(props.mandatory)\n      case 'single-independent': return independentSingleSelectStrategy(props.mandatory)\n      case 'trunk': return trunkSelectStrategy(props.mandatory)\n      case 'classic':\n      default: return classicSelectStrategy(props.mandatory)\n    }\n  })\n\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'object') return props.openStrategy\n\n    switch (props.openStrategy) {\n      case 'list': return listOpenStrategy\n      case 'single': return singleOpenStrategy\n      case 'multiple':\n      default: return multipleOpenStrategy\n    }\n  })\n\n  const activated = useProxiedModel(\n    props,\n    'activated',\n    props.activated,\n    v => activeStrategy.value.in(v, children.value, parents.value),\n    v => activeStrategy.value.out(v, children.value, parents.value),\n  )\n  const selected = useProxiedModel(\n    props,\n    'selected',\n    props.selected,\n    v => selectStrategy.value.in(v, children.value, parents.value),\n    v => selectStrategy.value.out(v, children.value, parents.value),\n  )\n\n  onBeforeUnmount(() => {\n    isUnmounted = true\n  })\n\n  function getPath (id: unknown) {\n    const path: unknown[] = []\n    let parent: unknown = id\n\n    while (parent != null) {\n      path.unshift(parent)\n      parent = parents.value.get(parent)\n    }\n\n    return path\n  }\n\n  const vm = getCurrentInstance('nested')\n\n  const nodeIds = new Set<unknown>()\n\n  const nested: NestedProvide = {\n    id: shallowRef(),\n    root: {\n      opened,\n      activatable: toRef(props, 'activatable'),\n      selectable: toRef(props, 'selectable'),\n      activated,\n      selected,\n      selectedValues: computed(() => {\n        const arr = []\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key)\n        }\n\n        return arr\n      }),\n      register: (id, parentId, isGroup) => {\n        if (nodeIds.has(id)) {\n          const path = getPath(id).map(String).join(' -> ')\n          const newPath = getPath(parentId).concat(id).map(String).join(' -> ')\n          consoleError(`Multiple nodes with the same ID\\n\\t${path}\\n\\t${newPath}`)\n          return\n        } else {\n          nodeIds.add(id)\n        }\n\n        parentId && id !== parentId && parents.value.set(id, parentId)\n\n        isGroup && children.value.set(id, [])\n\n        if (parentId != null) {\n          children.value.set(parentId, [...children.value.get(parentId) || [], id])\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return\n\n        nodeIds.delete(id)\n        children.value.delete(id)\n        const parent = parents.value.get(id)\n        if (parent) {\n          const list = children.value.get(parent) ?? []\n          children.value.set(parent, list.filter(child => child !== id))\n        }\n        parents.value.delete(id)\n      },\n      open: (id, value, event) => {\n        vm.emit('click:open', { id, value, path: getPath(id), event })\n\n        const newOpened = openStrategy.value.open({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newOpened && (opened.value = newOpened)\n      },\n      openOnSelect: (id, value, event) => {\n        const newOpened = openStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newOpened && (opened.value = newOpened)\n      },\n      select: (id, value, event) => {\n        vm.emit('click:select', { id, value, path: getPath(id), event })\n\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newSelected && (selected.value = newSelected)\n\n        nested.root.openOnSelect(id, value, event)\n      },\n      activate: (id, value, event) => {\n        if (!props.activatable) {\n          return nested.root.select(id, true, event)\n        }\n\n        vm.emit('click:activate', { id, value, path: getPath(id), event })\n\n        const newActivated = activeStrategy.value.activate({\n          id,\n          value,\n          activated: new Set(activated.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        if (newActivated.size !== activated.value.size) {\n          activated.value = newActivated\n        } else {\n          for (const value of newActivated) {\n            if (!activated.value.has(value)) {\n              activated.value = newActivated\n              return\n            }\n          }\n          for (const value of activated.value) {\n            if (!newActivated.has(value)) {\n              activated.value = newActivated\n              return\n            }\n          }\n        }\n      },\n      children,\n      parents,\n      getPath,\n    },\n  }\n\n  provide(VNestedSymbol, nested)\n\n  return nested.root\n}\n\nexport const useNestedItem = (id: Ref<unknown>, isGroup: boolean) => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  const uidSymbol = Symbol('nested item')\n  const computedId = computed(() => id.value !== undefined ? id.value : uidSymbol)\n\n  const item = {\n    ...parent,\n    id: computedId,\n    open: (open: boolean, e: Event) => parent.root.open(computedId.value, open, e),\n    openOnSelect: (open: boolean, e?: Event) => parent.root.openOnSelect(computedId.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    activate: (activated: boolean, e?: Event) => parent.root.activate(computedId.value, activated, e),\n    isActivated: computed(() => parent.root.activated.value.has(toRaw(computedId.value))),\n    select: (selected: boolean, e?: Event) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === 'indeterminate'),\n    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),\n    isGroupActivator: parent.isGroupActivator,\n  }\n\n  onBeforeMount(() => {\n    !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup)\n  })\n\n  onBeforeUnmount(() => {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value)\n  })\n\n  isGroup && provide(VNestedSymbol, item)\n\n  return item\n}\n\nexport const useNestedGroupActivator = () => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  provide(VNestedSymbol, { ...parent, isGroupActivator: true })\n}\n"]},"metadata":{},"sourceType":"module"}