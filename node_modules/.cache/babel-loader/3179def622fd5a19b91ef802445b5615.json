{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.math.sign.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\n// Composables\nimport { useDisplay } from \"./display.js\";\nimport { useResizeObserver } from \"./resizeObserver.js\"; // Utilities\n\nimport { computed, nextTick, onScopeDispose, ref, shallowRef, watch, watchEffect } from 'vue';\nimport { clamp, debounce, getPropertyFromItem, IN_BROWSER, propsFactory } from \"../util/index.js\"; // Types\n\nvar UP = -1;\nvar DOWN = 1;\n/** Determines how large each batch of items should be */\n\nvar BUFFER_PX = 100;\nexport var makeVirtualProps = propsFactory({\n  itemHeight: {\n    type: [Number, String],\n    default: null\n  },\n  itemKey: {\n    type: [String, Array, Function],\n    default: null\n  },\n  height: [Number, String]\n}, 'virtual');\nexport function useVirtual(props, items) {\n  var display = useDisplay();\n  var itemHeight = shallowRef(0);\n  watchEffect(function () {\n    itemHeight.value = parseFloat(props.itemHeight || 0);\n  });\n  var first = shallowRef(0);\n  var last = shallowRef(Math.ceil( // Assume 16px items filling the entire screen height if\n  // not provided. This is probably incorrect but it minimises\n  // the chance of ending up with empty space at the bottom.\n  // The default value is set here to avoid poisoning getSize()\n  (parseInt(props.height) || display.height.value) / (itemHeight.value || 16)) || 1);\n  var paddingTop = shallowRef(0);\n  var paddingBottom = shallowRef(0);\n  /** The scrollable element */\n\n  var containerRef = ref();\n  /** An element marking the top of the scrollable area,\n   * used to add an offset if there's padding or other elements above the virtual list */\n\n  var markerRef = ref();\n  /** markerRef's offsetTop, lazily evaluated */\n\n  var markerOffset = 0;\n\n  var _useResizeObserver = useResizeObserver(),\n      resizeRef = _useResizeObserver.resizeRef,\n      contentRect = _useResizeObserver.contentRect;\n\n  watchEffect(function () {\n    resizeRef.value = containerRef.value;\n  });\n  var viewportHeight = computed(function () {\n    var _contentRect$value;\n\n    return containerRef.value === document.documentElement ? display.height.value : ((_contentRect$value = contentRect.value) === null || _contentRect$value === void 0 ? void 0 : _contentRect$value.height) || parseInt(props.height) || 0;\n  });\n  /** All static elements have been rendered and we have an assumed item height */\n\n  var hasInitialRender = computed(function () {\n    return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);\n  });\n  var sizes = Array.from({\n    length: items.value.length\n  });\n  var offsets = Array.from({\n    length: items.value.length\n  });\n  var updateTime = shallowRef(0);\n  var targetScrollIndex = -1;\n\n  function getSize(index) {\n    return sizes[index] || itemHeight.value;\n  }\n\n  var updateOffsets = debounce(function () {\n    var start = performance.now();\n    offsets[0] = 0;\n    var length = items.value.length;\n\n    for (var i = 1; i <= length - 1; i++) {\n      offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1);\n    }\n\n    updateTime.value = Math.max(updateTime.value, performance.now() - start);\n  }, updateTime);\n  var unwatch = watch(hasInitialRender, function (v) {\n    if (!v) return; // First render is complete, update offsets and visible\n    // items in case our assumed item height was incorrect\n\n    unwatch();\n    markerOffset = markerRef.value.offsetTop;\n    updateOffsets.immediate();\n    calculateVisibleItems();\n    if (!~targetScrollIndex) return;\n    nextTick(function () {\n      IN_BROWSER && window.requestAnimationFrame(function () {\n        scrollToIndex(targetScrollIndex);\n        targetScrollIndex = -1;\n      });\n    });\n  });\n  onScopeDispose(function () {\n    updateOffsets.clear();\n  });\n\n  function handleItemResize(index, height) {\n    var prevHeight = sizes[index];\n    var prevMinHeight = itemHeight.value;\n    itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;\n\n    if (prevHeight !== height || prevMinHeight !== itemHeight.value) {\n      sizes[index] = height;\n      updateOffsets();\n    }\n  }\n\n  function calculateOffset(index) {\n    index = clamp(index, 0, items.value.length - 1);\n    return offsets[index] || 0;\n  }\n\n  function calculateIndex(scrollTop) {\n    return binaryClosest(offsets, scrollTop);\n  }\n\n  var lastScrollTop = 0;\n  var scrollVelocity = 0;\n  var lastScrollTime = 0;\n  watch(viewportHeight, function (val, oldVal) {\n    if (oldVal) {\n      calculateVisibleItems();\n\n      if (val < oldVal) {\n        requestAnimationFrame(function () {\n          scrollVelocity = 0;\n          calculateVisibleItems();\n        });\n      }\n    }\n  });\n  var scrollTimeout = -1;\n\n  function handleScroll() {\n    if (!containerRef.value || !markerRef.value) return;\n    var scrollTop = containerRef.value.scrollTop;\n    var scrollTime = performance.now();\n    var scrollDeltaT = scrollTime - lastScrollTime;\n\n    if (scrollDeltaT > 500) {\n      scrollVelocity = Math.sign(scrollTop - lastScrollTop); // Not super important, only update at the\n      // start of a scroll sequence to avoid reflows\n\n      markerOffset = markerRef.value.offsetTop;\n    } else {\n      scrollVelocity = scrollTop - lastScrollTop;\n    }\n\n    lastScrollTop = scrollTop;\n    lastScrollTime = scrollTime;\n    window.clearTimeout(scrollTimeout);\n    scrollTimeout = window.setTimeout(handleScrollend, 500);\n    calculateVisibleItems();\n  }\n\n  function handleScrollend() {\n    if (!containerRef.value || !markerRef.value) return;\n    scrollVelocity = 0;\n    lastScrollTime = 0;\n    window.clearTimeout(scrollTimeout);\n    calculateVisibleItems();\n  }\n\n  var raf = -1;\n\n  function calculateVisibleItems() {\n    cancelAnimationFrame(raf);\n    raf = requestAnimationFrame(_calculateVisibleItems);\n  }\n\n  function _calculateVisibleItems() {\n    if (!containerRef.value || !viewportHeight.value) return;\n    var scrollTop = lastScrollTop - markerOffset;\n    var direction = Math.sign(scrollVelocity);\n    var startPx = Math.max(0, scrollTop - BUFFER_PX);\n    var start = clamp(calculateIndex(startPx), 0, items.value.length);\n    var endPx = scrollTop + viewportHeight.value + BUFFER_PX;\n    var end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length);\n\n    if ( // Only update the side we're scrolling towards,\n    // the other side will be updated incidentally\n    (direction !== UP || start < first.value) && (direction !== DOWN || end > last.value)) {\n      var topOverflow = calculateOffset(first.value) - calculateOffset(start);\n      var bottomOverflow = calculateOffset(end) - calculateOffset(last.value);\n      var bufferOverflow = Math.max(topOverflow, bottomOverflow);\n\n      if (bufferOverflow > BUFFER_PX) {\n        first.value = start;\n        last.value = end;\n      } else {\n        // Only update the side that's reached its limit if there's still buffer left\n        if (start <= 0) first.value = start;\n        if (end >= items.value.length) last.value = end;\n      }\n    }\n\n    paddingTop.value = calculateOffset(first.value);\n    paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value);\n  }\n\n  function scrollToIndex(index) {\n    var offset = calculateOffset(index);\n\n    if (!containerRef.value || index && !offset) {\n      targetScrollIndex = index;\n    } else {\n      containerRef.value.scrollTop = offset;\n    }\n  }\n\n  var computedItems = computed(function () {\n    return items.value.slice(first.value, last.value).map(function (item, index) {\n      var _index = index + first.value;\n\n      return {\n        raw: item,\n        index: _index,\n        key: getPropertyFromItem(item, props.itemKey, _index)\n      };\n    });\n  });\n  watch(items, function () {\n    sizes = Array.from({\n      length: items.value.length\n    });\n    offsets = Array.from({\n      length: items.value.length\n    });\n    updateOffsets.immediate();\n    calculateVisibleItems();\n  }, {\n    deep: 1\n  });\n  return {\n    calculateVisibleItems: calculateVisibleItems,\n    containerRef: containerRef,\n    markerRef: markerRef,\n    computedItems: computedItems,\n    paddingTop: paddingTop,\n    paddingBottom: paddingBottom,\n    scrollToIndex: scrollToIndex,\n    handleScroll: handleScroll,\n    handleScrollend: handleScrollend,\n    handleItemResize: handleItemResize\n  };\n} // https://gist.github.com/robertleeplummerjr/1cc657191d34ecd0a324\n\nfunction binaryClosest(arr, val) {\n  var high = arr.length - 1;\n  var low = 0;\n  var mid = 0;\n  var item = null;\n  var target = -1;\n\n  if (arr[high] < val) {\n    return high;\n  }\n\n  while (low <= high) {\n    mid = low + high >> 1;\n    item = arr[mid];\n\n    if (item > val) {\n      high = mid - 1;\n    } else if (item < val) {\n      target = mid;\n      low = mid + 1;\n    } else if (item === val) {\n      return mid;\n    } else {\n      return low;\n    }\n  }\n\n  return target;\n}","map":{"version":3,"mappings":"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","names":["useDisplay","useResizeObserver","computed","nextTick","onScopeDispose","ref","shallowRef","watch","watchEffect","clamp","debounce","getPropertyFromItem","IN_BROWSER","propsFactory","UP","DOWN","BUFFER_PX","makeVirtualProps","itemHeight","type","Number","String","default","itemKey","Array","Function","height","useVirtual","props","items","display","value","parseFloat","first","last","Math","ceil","parseInt","paddingTop","paddingBottom","containerRef","markerRef","markerOffset","resizeRef","contentRect","viewportHeight","document","documentElement","hasInitialRender","sizes","from","length","offsets","updateTime","targetScrollIndex","getSize","index","updateOffsets","start","performance","now","i","max","unwatch","v","offsetTop","immediate","calculateVisibleItems","window","requestAnimationFrame","scrollToIndex","clear","handleItemResize","prevHeight","prevMinHeight","min","calculateOffset","calculateIndex","scrollTop","binaryClosest","lastScrollTop","scrollVelocity","lastScrollTime","val","oldVal","scrollTimeout","handleScroll","scrollTime","scrollDeltaT","sign","clearTimeout","setTimeout","handleScrollend","raf","cancelAnimationFrame","_calculateVisibleItems","direction","startPx","endPx","end","topOverflow","bottomOverflow","bufferOverflow","offset","computedItems","slice","map","item","_index","raw","key","deep","arr","high","low","mid","target"],"sources":["../../src/composables/virtual.ts"],"sourcesContent":["// Composables\nimport { useDisplay } from '@/composables/display'\nimport { useResizeObserver } from '@/composables/resizeObserver'\n\n// Utilities\nimport { computed, nextTick, onScopeDispose, ref, shallowRef, watch, watchEffect } from 'vue'\nimport { clamp, debounce, getPropertyFromItem, IN_BROWSER, propsFactory } from '@/util'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { SelectItemKey } from '@/util'\n\nconst UP = -1\nconst DOWN = 1\n\n/** Determines how large each batch of items should be */\nconst BUFFER_PX = 100\n\ntype VirtualProps = {\n  itemHeight: number | string | null | undefined\n  itemKey: SelectItemKey\n  height: number | string | undefined\n}\n\nexport const makeVirtualProps = propsFactory({\n  itemHeight: {\n    type: [Number, String],\n    default: null,\n  },\n  itemKey: {\n    type: [String, Array, Function] as PropType<SelectItemKey>,\n    default: null,\n  },\n  height: [Number, String],\n}, 'virtual')\n\nexport function useVirtual <T> (props: VirtualProps, items: Ref<readonly T[]>) {\n  const display = useDisplay()\n\n  const itemHeight = shallowRef(0)\n  watchEffect(() => {\n    itemHeight.value = parseFloat(props.itemHeight || 0)\n  })\n\n  const first = shallowRef(0)\n  const last = shallowRef(Math.ceil(\n    // Assume 16px items filling the entire screen height if\n    // not provided. This is probably incorrect but it minimises\n    // the chance of ending up with empty space at the bottom.\n    // The default value is set here to avoid poisoning getSize()\n    (parseInt(props.height!) || display.height.value) / (itemHeight.value || 16)\n  ) || 1)\n  const paddingTop = shallowRef(0)\n  const paddingBottom = shallowRef(0)\n\n  /** The scrollable element */\n  const containerRef = ref<HTMLElement>()\n  /** An element marking the top of the scrollable area,\n   * used to add an offset if there's padding or other elements above the virtual list */\n  const markerRef = ref<HTMLElement>()\n  /** markerRef's offsetTop, lazily evaluated */\n  let markerOffset = 0\n\n  const { resizeRef, contentRect } = useResizeObserver()\n  watchEffect(() => {\n    resizeRef.value = containerRef.value\n  })\n  const viewportHeight = computed(() => {\n    return containerRef.value === document.documentElement\n      ? display.height.value\n      : contentRect.value?.height || parseInt(props.height!) || 0\n  })\n  /** All static elements have been rendered and we have an assumed item height */\n  const hasInitialRender = computed(() => {\n    return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value)\n  })\n\n  let sizes = Array.from<number | null>({ length: items.value.length })\n  let offsets = Array.from<number>({ length: items.value.length })\n  const updateTime = shallowRef(0)\n  let targetScrollIndex = -1\n\n  function getSize (index: number) {\n    return sizes[index] || itemHeight.value\n  }\n\n  const updateOffsets = debounce(() => {\n    const start = performance.now()\n    offsets[0] = 0\n    const length = items.value.length\n    for (let i = 1; i <= length - 1; i++) {\n      offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1)\n    }\n    updateTime.value = Math.max(updateTime.value, performance.now() - start)\n  }, updateTime)\n\n  const unwatch = watch(hasInitialRender, v => {\n    if (!v) return\n    // First render is complete, update offsets and visible\n    // items in case our assumed item height was incorrect\n\n    unwatch()\n    markerOffset = markerRef.value!.offsetTop\n    updateOffsets.immediate()\n    calculateVisibleItems()\n\n    if (!~targetScrollIndex) return\n\n    nextTick(() => {\n      IN_BROWSER && window.requestAnimationFrame(() => {\n        scrollToIndex(targetScrollIndex)\n        targetScrollIndex = -1\n      })\n    })\n  })\n\n  onScopeDispose(() => {\n    updateOffsets.clear()\n  })\n\n  function handleItemResize (index: number, height: number) {\n    const prevHeight = sizes[index]\n    const prevMinHeight = itemHeight.value\n\n    itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height\n\n    if (prevHeight !== height || prevMinHeight !== itemHeight.value) {\n      sizes[index] = height\n      updateOffsets()\n    }\n  }\n\n  function calculateOffset (index: number) {\n    index = clamp(index, 0, items.value.length - 1)\n    return offsets[index] || 0\n  }\n\n  function calculateIndex (scrollTop: number) {\n    return binaryClosest(offsets, scrollTop)\n  }\n\n  let lastScrollTop = 0\n  let scrollVelocity = 0\n  let lastScrollTime = 0\n\n  watch(viewportHeight, (val, oldVal) => {\n    if (oldVal) {\n      calculateVisibleItems()\n      if (val < oldVal) {\n        requestAnimationFrame(() => {\n          scrollVelocity = 0\n          calculateVisibleItems()\n        })\n      }\n    }\n  })\n\n  let scrollTimeout = -1\n  function handleScroll () {\n    if (!containerRef.value || !markerRef.value) return\n\n    const scrollTop = containerRef.value.scrollTop\n    const scrollTime = performance.now()\n    const scrollDeltaT = scrollTime - lastScrollTime\n\n    if (scrollDeltaT > 500) {\n      scrollVelocity = Math.sign(scrollTop - lastScrollTop)\n\n      // Not super important, only update at the\n      // start of a scroll sequence to avoid reflows\n      markerOffset = markerRef.value.offsetTop\n    } else {\n      scrollVelocity = scrollTop - lastScrollTop\n    }\n\n    lastScrollTop = scrollTop\n    lastScrollTime = scrollTime\n\n    window.clearTimeout(scrollTimeout)\n    scrollTimeout = window.setTimeout(handleScrollend, 500)\n\n    calculateVisibleItems()\n  }\n  function handleScrollend () {\n    if (!containerRef.value || !markerRef.value) return\n\n    scrollVelocity = 0\n    lastScrollTime = 0\n\n    window.clearTimeout(scrollTimeout)\n    calculateVisibleItems()\n  }\n\n  let raf = -1\n  function calculateVisibleItems () {\n    cancelAnimationFrame(raf)\n    raf = requestAnimationFrame(_calculateVisibleItems)\n  }\n  function _calculateVisibleItems () {\n    if (!containerRef.value || !viewportHeight.value) return\n    const scrollTop = lastScrollTop - markerOffset\n    const direction = Math.sign(scrollVelocity)\n\n    const startPx = Math.max(0, scrollTop - BUFFER_PX)\n    const start = clamp(calculateIndex(startPx), 0, items.value.length)\n\n    const endPx = scrollTop + viewportHeight.value + BUFFER_PX\n    const end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length)\n\n    if (\n      // Only update the side we're scrolling towards,\n      // the other side will be updated incidentally\n      (direction !== UP || start < first.value) &&\n      (direction !== DOWN || end > last.value)\n    ) {\n      const topOverflow = calculateOffset(first.value) - calculateOffset(start)\n      const bottomOverflow = calculateOffset(end) - calculateOffset(last.value)\n      const bufferOverflow = Math.max(topOverflow, bottomOverflow)\n\n      if (bufferOverflow > BUFFER_PX) {\n        first.value = start\n        last.value = end\n      } else {\n        // Only update the side that's reached its limit if there's still buffer left\n        if (start <= 0) first.value = start\n        if (end >= items.value.length) last.value = end\n      }\n    }\n\n    paddingTop.value = calculateOffset(first.value)\n    paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value)\n  }\n\n  function scrollToIndex (index: number) {\n    const offset = calculateOffset(index)\n    if (!containerRef.value || (index && !offset)) {\n      targetScrollIndex = index\n    } else {\n      containerRef.value.scrollTop = offset\n    }\n  }\n\n  const computedItems = computed(() => {\n    return items.value.slice(first.value, last.value).map((item, index) => {\n      const _index = index + first.value\n      return {\n        raw: item,\n        index: _index,\n        key: getPropertyFromItem(item, props.itemKey, _index),\n      }\n    })\n  })\n\n  watch(items, () => {\n    sizes = Array.from({ length: items.value.length })\n    offsets = Array.from({ length: items.value.length })\n    updateOffsets.immediate()\n    calculateVisibleItems()\n  }, { deep: 1 })\n\n  return {\n    calculateVisibleItems,\n    containerRef,\n    markerRef,\n    computedItems,\n    paddingTop,\n    paddingBottom,\n    scrollToIndex,\n    handleScroll,\n    handleScrollend,\n    handleItemResize,\n  }\n}\n\n// https://gist.github.com/robertleeplummerjr/1cc657191d34ecd0a324\nfunction binaryClosest (arr: ArrayLike<number>, val: number) {\n  let high = arr.length - 1\n  let low = 0\n  let mid = 0\n  let item = null\n  let target = -1\n\n  if (arr[high]! < val) {\n    return high\n  }\n\n  while (low <= high) {\n    mid = (low + high) >> 1\n    item = arr[mid]!\n\n    if (item > val) {\n      high = mid - 1\n    } else if (item < val) {\n      target = mid\n      low = mid + 1\n    } else if (item === val) {\n      return mid\n    } else {\n      return low\n    }\n  }\n\n  return target\n}\n"]},"metadata":{},"sourceType":"module"}