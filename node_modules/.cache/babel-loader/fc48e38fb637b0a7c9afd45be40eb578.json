{"ast":null,"code":"// Utilities\nimport { computed, onBeforeUnmount, onMounted, ref, shallowRef, watch } from 'vue';\nimport { clamp, consoleWarn, propsFactory } from \"../util/index.js\"; // Types\n// Composables\n\nexport const makeScrollProps = propsFactory({\n  scrollTarget: {\n    type: String\n  },\n  scrollThreshold: {\n    type: [String, Number],\n    default: 300\n  }\n}, 'scroll');\nexport function useScroll(props) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    canScroll\n  } = args;\n  let previousScroll = 0;\n  let previousScrollHeight = 0;\n  const target = ref(null);\n  const currentScroll = shallowRef(0);\n  const savedScroll = shallowRef(0);\n  const currentThreshold = shallowRef(0);\n  const isScrollActive = shallowRef(false);\n  const isScrollingUp = shallowRef(false);\n  const scrollThreshold = computed(() => {\n    return Number(props.scrollThreshold);\n  });\n  /**\n   * 1: at top\n   * 0: at threshold\n   */\n\n  const scrollRatio = computed(() => {\n    return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);\n  });\n\n  const onScroll = () => {\n    const targetEl = target.value;\n    if (!targetEl || canScroll && !canScroll.value) return;\n    previousScroll = currentScroll.value;\n    currentScroll.value = 'window' in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;\n    const currentScrollHeight = targetEl instanceof Window ? document.documentElement.scrollHeight : targetEl.scrollHeight;\n\n    if (previousScrollHeight !== currentScrollHeight) {\n      previousScrollHeight = currentScrollHeight;\n      return;\n    }\n\n    isScrollingUp.value = currentScroll.value < previousScroll;\n    currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);\n  };\n\n  watch(isScrollingUp, () => {\n    savedScroll.value = savedScroll.value || currentScroll.value;\n  });\n  watch(isScrollActive, () => {\n    savedScroll.value = 0;\n  });\n  onMounted(() => {\n    watch(() => props.scrollTarget, scrollTarget => {\n      const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;\n\n      if (!newTarget) {\n        consoleWarn(`Unable to locate element with identifier ${scrollTarget}`);\n        return;\n      }\n\n      if (newTarget === target.value) return;\n      target.value?.removeEventListener('scroll', onScroll);\n      target.value = newTarget;\n      target.value.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    }, {\n      immediate: true\n    });\n  });\n  onBeforeUnmount(() => {\n    target.value?.removeEventListener('scroll', onScroll);\n  }); // Do we need this? If yes - seems that\n  // there's no need to expose onScroll\n\n  canScroll && watch(canScroll, onScroll, {\n    immediate: true\n  });\n  return {\n    scrollThreshold,\n    currentScroll,\n    currentThreshold,\n    isScrollActive,\n    scrollRatio,\n    // required only for testing\n    // probably can be removed\n    // later (2 chars chlng)\n    isScrollingUp,\n    savedScroll\n  };\n}","map":{"version":3,"mappings":"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","names":["computed","onBeforeUnmount","onMounted","ref","shallowRef","watch","clamp","consoleWarn","propsFactory","makeScrollProps","scrollTarget","type","String","scrollThreshold","Number","default","useScroll","props","args","canScroll","previousScroll","previousScrollHeight","target","currentScroll","savedScroll","currentThreshold","isScrollActive","isScrollingUp","scrollRatio","value","onScroll","targetEl","pageYOffset","scrollTop","currentScrollHeight","Window","document","documentElement","scrollHeight","Math","abs","newTarget","querySelector","window","removeEventListener","addEventListener","passive","immediate"],"sources":["../../src/composables/scroll.ts"],"sourcesContent":["// Utilities\nimport {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { clamp, consoleWarn, propsFactory } from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\n\nexport interface ScrollProps {\n  scrollTarget?: string\n  scrollThreshold?: string | number\n}\n\nexport interface ThresholdMetCallbackData {\n  isScrollingUp: boolean\n  currentThreshold: number\n  savedScroll: Ref<number>\n}\n\n// Composables\nexport const makeScrollProps = propsFactory({\n  scrollTarget: {\n    type: String,\n  },\n  scrollThreshold: {\n    type: [String, Number],\n    default: 300,\n  },\n}, 'scroll')\n\nexport interface ScrollArguments {\n  canScroll?: Readonly<Ref<boolean>>\n}\n\nexport function useScroll (\n  props: ScrollProps,\n  args: ScrollArguments = {},\n) {\n  const { canScroll } = args\n  let previousScroll = 0\n  let previousScrollHeight = 0\n  const target = ref<Element | Window | null>(null)\n  const currentScroll = shallowRef(0)\n  const savedScroll = shallowRef(0)\n  const currentThreshold = shallowRef(0)\n  const isScrollActive = shallowRef(false)\n  const isScrollingUp = shallowRef(false)\n\n  const scrollThreshold = computed(() => {\n    return Number(props.scrollThreshold)\n  })\n\n  /**\n   * 1: at top\n   * 0: at threshold\n   */\n  const scrollRatio = computed(() => {\n    return clamp(((scrollThreshold.value - currentScroll.value) / scrollThreshold.value) || 0)\n  })\n\n  const onScroll = () => {\n    const targetEl = target.value\n\n    if (!targetEl || (canScroll && !canScroll.value)) return\n\n    previousScroll = currentScroll.value\n    currentScroll.value = ('window' in targetEl) ? targetEl.pageYOffset : targetEl.scrollTop\n\n    const currentScrollHeight = targetEl instanceof Window ? document.documentElement.scrollHeight : targetEl.scrollHeight\n    if (previousScrollHeight !== currentScrollHeight) {\n      previousScrollHeight = currentScrollHeight\n      return\n    }\n\n    isScrollingUp.value = currentScroll.value < previousScroll\n    currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value)\n  }\n\n  watch(isScrollingUp, () => {\n    savedScroll.value = savedScroll.value || currentScroll.value\n  })\n\n  watch(isScrollActive, () => {\n    savedScroll.value = 0\n  })\n\n  onMounted(() => {\n    watch(() => props.scrollTarget, scrollTarget => {\n      const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window\n\n      if (!newTarget) {\n        consoleWarn(`Unable to locate element with identifier ${scrollTarget}`)\n        return\n      }\n\n      if (newTarget === target.value) return\n\n      target.value?.removeEventListener('scroll', onScroll)\n      target.value = newTarget\n      target.value.addEventListener('scroll', onScroll, { passive: true })\n    }, { immediate: true })\n  })\n\n  onBeforeUnmount(() => {\n    target.value?.removeEventListener('scroll', onScroll)\n  })\n\n  // Do we need this? If yes - seems that\n  // there's no need to expose onScroll\n  canScroll && watch(canScroll, onScroll, { immediate: true })\n\n  return {\n    scrollThreshold,\n    currentScroll,\n    currentThreshold,\n    isScrollActive,\n    scrollRatio,\n\n    // required only for testing\n    // probably can be removed\n    // later (2 chars chlng)\n    isScrollingUp,\n    savedScroll,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}