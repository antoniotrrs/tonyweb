{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n// Utilities\nimport { capitalize, inject, provide, ref, watchEffect } from 'vue';\nimport { consoleError, propsFactory } from \"../../../util/index.js\"; // Types\n\nexport const makeDataTableHeaderProps = propsFactory({\n  headers: Array\n}, 'DataTable-header');\nexport const VDataTableHeadersSymbol = Symbol.for('vuetify:data-table-headers');\nconst defaultHeader = {\n  title: '',\n  sortable: false\n};\nconst defaultActionHeader = { ...defaultHeader,\n  width: 48\n};\n\nfunction priorityQueue() {\n  let arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const queue = arr.map(element => ({\n    element,\n    priority: 0\n  }));\n  return {\n    enqueue: (element, priority) => {\n      let added = false;\n\n      for (let i = 0; i < queue.length; i++) {\n        const item = queue[i];\n\n        if (item.priority > priority) {\n          queue.splice(i, 0, {\n            element,\n            priority\n          });\n          added = true;\n          break;\n        }\n      }\n\n      if (!added) queue.push({\n        element,\n        priority\n      });\n    },\n    size: () => queue.length,\n    count: () => {\n      let count = 0;\n      if (!queue.length) return 0;\n      const whole = Math.floor(queue[0].priority);\n\n      for (let i = 0; i < queue.length; i++) {\n        if (Math.floor(queue[i].priority) === whole) count += 1;\n      }\n\n      return count;\n    },\n    dequeue: () => {\n      return queue.shift();\n    }\n  };\n}\n\nfunction extractLeaves(item) {\n  let columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!item.children) {\n    columns.push(item);\n  } else {\n    for (const child of item.children) {\n      extractLeaves(child, columns);\n    }\n  }\n\n  return columns;\n}\n\nfunction extractKeys(headers) {\n  let keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n\n  for (const item of headers) {\n    if (item.key) keys.add(item.key);\n\n    if (item.children) {\n      extractKeys(item.children, keys);\n    }\n  }\n\n  return keys;\n}\n\nfunction getDefaultItem(item) {\n  if (!item.key) return undefined;\n  if (item.key === 'data-table-group') return defaultHeader;\n  if (['data-table-expand', 'data-table-select'].includes(item.key)) return defaultActionHeader;\n  return undefined;\n}\n\nfunction getDepth(item) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!item.children) return depth;\n  return Math.max(depth, ...item.children.map(child => getDepth(child, depth + 1)));\n}\n\nfunction parseFixedColumns(items) {\n  let seenFixed = false;\n\n  function setFixed(item) {\n    let parentFixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!item) return;\n\n    if (parentFixed) {\n      item.fixed = true;\n    }\n\n    if (item.fixed) {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i], true);\n        }\n      } else {\n        if (!seenFixed) {\n          item.lastFixed = true;\n        } else if (isNaN(Number(item.width))) {\n          consoleError(`Multiple fixed columns should have a static width (key: ${item.key})`);\n        } else {\n          item.minWidth = Math.max(Number(item.width) || 0, Number(item.minWidth) || 0);\n        }\n\n        seenFixed = true;\n      }\n    } else {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i]);\n        }\n      } else {\n        seenFixed = false;\n      }\n    }\n  }\n\n  for (let i = items.length - 1; i >= 0; i--) {\n    setFixed(items[i]);\n  }\n\n  function setFixedOffset(item) {\n    let fixedOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (!item) return fixedOffset;\n\n    if (item.children) {\n      item.fixedOffset = fixedOffset;\n\n      for (const child of item.children) {\n        fixedOffset = setFixedOffset(child, fixedOffset);\n      }\n    } else if (item.fixed) {\n      item.fixedOffset = fixedOffset;\n      fixedOffset += parseFloat(item.width || '0') || 0;\n    }\n\n    return fixedOffset;\n  }\n\n  let fixedOffset = 0;\n\n  for (const item of items) {\n    fixedOffset = setFixedOffset(item, fixedOffset);\n  }\n}\n\nfunction parse(items, maxDepth) {\n  const headers = [];\n  let currentDepth = 0;\n  const queue = priorityQueue(items);\n\n  while (queue.size() > 0) {\n    let rowSize = queue.count();\n    const row = [];\n    let fraction = 1;\n\n    while (rowSize > 0) {\n      const {\n        element: item,\n        priority\n      } = queue.dequeue();\n      const diff = maxDepth - currentDepth - getDepth(item);\n      row.push({ ...item,\n        rowspan: diff ?? 1,\n        colspan: item.children ? extractLeaves(item).length : 1\n      });\n\n      if (item.children) {\n        for (const child of item.children) {\n          // This internally sorts items that are on the same priority \"row\"\n          const sort = priority % 1 + fraction / Math.pow(10, currentDepth + 2);\n          queue.enqueue(child, currentDepth + diff + sort);\n        }\n      }\n\n      fraction += 1;\n      rowSize -= 1;\n    }\n\n    currentDepth += 1;\n    headers.push(row);\n  }\n\n  const columns = items.map(item => extractLeaves(item)).flat();\n  return {\n    columns,\n    headers\n  };\n}\n\nfunction convertToInternalHeaders(items) {\n  const internalHeaders = [];\n\n  for (const item of items) {\n    const defaultItem = { ...getDefaultItem(item),\n      ...item\n    };\n    const key = defaultItem.key ?? (typeof defaultItem.value === 'string' ? defaultItem.value : null);\n    const value = defaultItem.value ?? key ?? null;\n    const internalItem = { ...defaultItem,\n      key,\n      value,\n      sortable: defaultItem.sortable ?? (defaultItem.key != null || !!defaultItem.sort),\n      children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : undefined\n    };\n    internalHeaders.push(internalItem);\n  }\n\n  return internalHeaders;\n}\n\nexport function createHeaders(props, options) {\n  const headers = ref([]);\n  const columns = ref([]);\n  const sortFunctions = ref({});\n  const sortRawFunctions = ref({});\n  const filterFunctions = ref({});\n  watchEffect(() => {\n    const _headers = props.headers || Object.keys(props.items[0] ?? {}).map(key => ({\n      key,\n      title: capitalize(key)\n    }));\n\n    const items = _headers.slice();\n\n    const keys = extractKeys(items);\n\n    if (options?.groupBy?.value.length && !keys.has('data-table-group')) {\n      items.unshift({\n        key: 'data-table-group',\n        title: 'Group'\n      });\n    }\n\n    if (options?.showSelect?.value && !keys.has('data-table-select')) {\n      items.unshift({\n        key: 'data-table-select'\n      });\n    }\n\n    if (options?.showExpand?.value && !keys.has('data-table-expand')) {\n      items.push({\n        key: 'data-table-expand'\n      });\n    }\n\n    const internalHeaders = convertToInternalHeaders(items);\n    parseFixedColumns(internalHeaders);\n    const maxDepth = Math.max(...internalHeaders.map(item => getDepth(item))) + 1;\n    const parsed = parse(internalHeaders, maxDepth);\n    headers.value = parsed.headers;\n    columns.value = parsed.columns;\n    const flatHeaders = parsed.headers.flat(1);\n\n    for (const header of flatHeaders) {\n      if (!header.key) continue;\n\n      if (header.sortable) {\n        if (header.sort) {\n          sortFunctions.value[header.key] = header.sort;\n        }\n\n        if (header.sortRaw) {\n          sortRawFunctions.value[header.key] = header.sortRaw;\n        }\n      }\n\n      if (header.filter) {\n        filterFunctions.value[header.key] = header.filter;\n      }\n    }\n  });\n  const data = {\n    headers,\n    columns,\n    sortFunctions,\n    sortRawFunctions,\n    filterFunctions\n  };\n  provide(VDataTableHeadersSymbol, data);\n  return data;\n}\nexport function useHeaders() {\n  const data = inject(VDataTableHeadersSymbol);\n  if (!data) throw new Error('Missing headers!');\n  return data;\n}","map":{"version":3,"mappings":"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","names":["capitalize","inject","provide","ref","watchEffect","consoleError","propsFactory","makeDataTableHeaderProps","headers","Array","VDataTableHeadersSymbol","Symbol","for","defaultHeader","title","sortable","defaultActionHeader","width","priorityQueue","arr","queue","map","element","priority","enqueue","added","i","length","item","splice","push","size","count","whole","Math","floor","dequeue","shift","extractLeaves","columns","children","child","extractKeys","keys","Set","key","add","getDefaultItem","undefined","includes","getDepth","depth","max","parseFixedColumns","items","seenFixed","setFixed","parentFixed","fixed","lastFixed","isNaN","Number","minWidth","setFixedOffset","fixedOffset","parseFloat","parse","maxDepth","currentDepth","rowSize","row","fraction","diff","rowspan","colspan","sort","pow","flat","convertToInternalHeaders","internalHeaders","defaultItem","value","internalItem","createHeaders","props","options","sortFunctions","sortRawFunctions","filterFunctions","_headers","Object","slice","groupBy","has","unshift","showSelect","showExpand","parsed","flatHeaders","header","sortRaw","filter","data","useHeaders","Error"],"sources":["../../../../src/components/VDataTable/composables/headers.ts"],"sourcesContent":["// Utilities\nimport { capitalize, inject, provide, ref, watchEffect } from 'vue'\nimport { consoleError, propsFactory } from '@/util'\n\n// Types\nimport type { DeepReadonly, InjectionKey, PropType, Ref } from 'vue'\nimport type { SortItem } from './sort'\nimport type { DataTableCompareFunction, DataTableHeader, InternalDataTableHeader } from '../types'\nimport type { FilterKeyFunctions } from '@/composables/filter'\n\nexport const makeDataTableHeaderProps = propsFactory({\n  headers: Array as PropType<DeepReadonly<DataTableHeader[]>>,\n}, 'DataTable-header')\n\nexport const VDataTableHeadersSymbol: InjectionKey<{\n  headers: Ref<InternalDataTableHeader[][]>\n  columns: Ref<InternalDataTableHeader[]>\n}> = Symbol.for('vuetify:data-table-headers')\n\ntype HeaderProps = {\n  headers: DeepReadonly<DataTableHeader[]> | undefined\n  items: any[]\n}\n\nconst defaultHeader = { title: '', sortable: false }\nconst defaultActionHeader = { ...defaultHeader, width: 48 }\n\nfunction priorityQueue <T> (arr: T[] = []) {\n  const queue: { element: T, priority: number }[] = arr.map(element => ({ element, priority: 0 }))\n\n  return {\n    enqueue: (element: T, priority: number) => {\n      let added = false\n      for (let i = 0; i < queue.length; i++) {\n        const item = queue[i]\n        if (item.priority > priority) {\n          queue.splice(i, 0, { element, priority })\n          added = true\n          break\n        }\n      }\n\n      if (!added) queue.push({ element, priority })\n    },\n    size: () => queue.length,\n    count: () => {\n      let count = 0\n\n      if (!queue.length) return 0\n\n      const whole = Math.floor(queue[0].priority)\n      for (let i = 0; i < queue.length; i++) {\n        if (Math.floor(queue[i].priority) === whole) count += 1\n      }\n\n      return count\n    },\n    dequeue: () => {\n      return queue.shift()\n    },\n  }\n}\n\nfunction extractLeaves (item: InternalDataTableHeader, columns: InternalDataTableHeader[] = []) {\n  if (!item.children) {\n    columns.push(item)\n  } else {\n    for (const child of item.children) {\n      extractLeaves(child, columns)\n    }\n  }\n\n  return columns\n}\n\nfunction extractKeys (headers: DeepReadonly<DataTableHeader[]>, keys = new Set<string>()) {\n  for (const item of headers) {\n    if (item.key) keys.add(item.key)\n\n    if (item.children) {\n      extractKeys(item.children, keys)\n    }\n  }\n\n  return keys\n}\n\nfunction getDefaultItem (item: DeepReadonly<DataTableHeader>) {\n  if (!item.key) return undefined\n  if (item.key === 'data-table-group') return defaultHeader\n  if (['data-table-expand', 'data-table-select'].includes(item.key)) return defaultActionHeader\n  return undefined\n}\n\nfunction getDepth (item: InternalDataTableHeader, depth = 0): number {\n  if (!item.children) return depth\n\n  return Math.max(depth, ...item.children.map(child => getDepth(child, depth + 1)))\n}\n\nfunction parseFixedColumns (items: InternalDataTableHeader[]) {\n  let seenFixed = false\n  function setFixed (item: InternalDataTableHeader, parentFixed = false) {\n    if (!item) return\n\n    if (parentFixed) {\n      item.fixed = true\n    }\n\n    if (item.fixed) {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i], true)\n        }\n      } else {\n        if (!seenFixed) {\n          item.lastFixed = true\n        } else if (isNaN(Number(item.width))) {\n          consoleError(`Multiple fixed columns should have a static width (key: ${item.key})`)\n        } else {\n          item.minWidth = Math.max(Number(item.width) || 0, Number(item.minWidth) || 0)\n        }\n        seenFixed = true\n      }\n    } else {\n      if (item.children) {\n        for (let i = item.children.length - 1; i >= 0; i--) {\n          setFixed(item.children[i])\n        }\n      } else {\n        seenFixed = false\n      }\n    }\n  }\n\n  for (let i = items.length - 1; i >= 0; i--) {\n    setFixed(items[i])\n  }\n\n  function setFixedOffset (item: InternalDataTableHeader, fixedOffset = 0) {\n    if (!item) return fixedOffset\n\n    if (item.children) {\n      item.fixedOffset = fixedOffset\n      for (const child of item.children) {\n        fixedOffset = setFixedOffset(child, fixedOffset)\n      }\n    } else if (item.fixed) {\n      item.fixedOffset = fixedOffset\n      fixedOffset += parseFloat(item.width || '0') || 0\n    }\n\n    return fixedOffset\n  }\n\n  let fixedOffset = 0\n  for (const item of items) {\n    fixedOffset = setFixedOffset(item, fixedOffset)\n  }\n}\n\nfunction parse (items: InternalDataTableHeader[], maxDepth: number) {\n  const headers: InternalDataTableHeader[][] = []\n  let currentDepth = 0\n  const queue = priorityQueue(items)\n\n  while (queue.size() > 0) {\n    let rowSize = queue.count()\n    const row: InternalDataTableHeader[] = []\n    let fraction = 1\n    while (rowSize > 0) {\n      const { element: item, priority } = queue.dequeue()!\n      const diff = maxDepth - currentDepth - getDepth(item)\n\n      row.push({\n        ...item,\n        rowspan: diff ?? 1,\n        colspan: item.children ? extractLeaves(item).length : 1,\n      })\n\n      if (item.children) {\n        for (const child of item.children) {\n          // This internally sorts items that are on the same priority \"row\"\n          const sort = priority % 1 + (fraction / Math.pow(10, currentDepth + 2))\n          queue.enqueue(child, currentDepth + diff + sort)\n        }\n      }\n\n      fraction += 1\n      rowSize -= 1\n    }\n    currentDepth += 1\n    headers.push(row)\n  }\n\n  const columns = items.map(item => extractLeaves(item)).flat()\n\n  return { columns, headers }\n}\n\nfunction convertToInternalHeaders (items: DeepReadonly<DataTableHeader[]>) {\n  const internalHeaders: InternalDataTableHeader[] = []\n  for (const item of items) {\n    const defaultItem = { ...getDefaultItem(item), ...item }\n    const key = defaultItem.key ?? (typeof defaultItem.value === 'string' ? defaultItem.value : null)\n    const value = defaultItem.value ?? key ?? null\n    const internalItem: InternalDataTableHeader = {\n      ...defaultItem,\n      key,\n      value,\n      sortable: defaultItem.sortable ?? (defaultItem.key != null || !!defaultItem.sort),\n      children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : undefined,\n    }\n\n    internalHeaders.push(internalItem)\n  }\n\n  return internalHeaders\n}\n\nexport function createHeaders (\n  props: HeaderProps,\n  options?: {\n    groupBy?: Ref<readonly SortItem[]>\n    showSelect?: Ref<boolean>\n    showExpand?: Ref<boolean>\n  }\n) {\n  const headers = ref<InternalDataTableHeader[][]>([])\n  const columns = ref<InternalDataTableHeader[]>([])\n  const sortFunctions = ref<Record<string, DataTableCompareFunction>>({})\n  const sortRawFunctions = ref<Record<string, DataTableCompareFunction>>({})\n  const filterFunctions = ref<FilterKeyFunctions>({})\n\n  watchEffect(() => {\n    const _headers = props.headers ||\n      Object.keys(props.items[0] ?? {}).map(key => ({ key, title: capitalize(key) })) as never\n\n    const items = _headers.slice()\n    const keys = extractKeys(items)\n\n    if (options?.groupBy?.value.length && !keys.has('data-table-group')) {\n      items.unshift({ key: 'data-table-group', title: 'Group' })\n    }\n\n    if (options?.showSelect?.value && !keys.has('data-table-select')) {\n      items.unshift({ key: 'data-table-select' })\n    }\n\n    if (options?.showExpand?.value && !keys.has('data-table-expand')) {\n      items.push({ key: 'data-table-expand' })\n    }\n\n    const internalHeaders = convertToInternalHeaders(items)\n\n    parseFixedColumns(internalHeaders)\n\n    const maxDepth = Math.max(...internalHeaders.map(item => getDepth(item))) + 1\n    const parsed = parse(internalHeaders, maxDepth)\n\n    headers.value = parsed.headers\n    columns.value = parsed.columns\n\n    const flatHeaders = parsed.headers.flat(1)\n\n    for (const header of flatHeaders) {\n      if (!header.key) continue\n\n      if (header.sortable) {\n        if (header.sort) {\n          sortFunctions.value[header.key] = header.sort\n        }\n\n        if (header.sortRaw) {\n          sortRawFunctions.value[header.key] = header.sortRaw\n        }\n      }\n\n      if (header.filter) {\n        filterFunctions.value[header.key] = header.filter\n      }\n    }\n  })\n\n  const data = { headers, columns, sortFunctions, sortRawFunctions, filterFunctions }\n\n  provide(VDataTableHeadersSymbol, data)\n\n  return data\n}\n\nexport function useHeaders () {\n  const data = inject(VDataTableHeadersSymbol)\n\n  if (!data) throw new Error('Missing headers!')\n\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}