{"ast":null,"code":"import { Fragment as _Fragment, createVNode as _createVNode, mergeProps as _mergeProps } from \"vue\"; // Styles\n\nimport \"../VSlider/VSlider.css\"; // Components\n\nimport { makeVInputProps, VInput } from \"../VInput/VInput.js\";\nimport { VLabel } from \"../VLabel/index.js\";\nimport { getOffset, makeSliderProps, useSlider, useSteps } from \"../VSlider/slider.js\";\nimport { VSliderThumb } from \"../VSlider/VSliderThumb.js\";\nimport { VSliderTrack } from \"../VSlider/VSliderTrack.js\"; // Composables\n\nimport { makeFocusProps, useFocus } from \"../../composables/focus.js\";\nimport { useRtl } from \"../../composables/locale.js\";\nimport { useProxiedModel } from \"../../composables/proxiedModel.js\"; // Utilities\n\nimport { computed, ref } from 'vue';\nimport { genericComponent, propsFactory, useRender } from \"../../util/index.js\"; // Types\n\nexport const makeVRangeSliderProps = propsFactory({ ...makeFocusProps(),\n  ...makeVInputProps(),\n  ...makeSliderProps(),\n  strict: Boolean,\n  modelValue: {\n    type: Array,\n    default: () => [0, 0]\n  }\n}, 'VRangeSlider');\nexport const VRangeSlider = genericComponent()({\n  name: 'VRangeSlider',\n  props: makeVRangeSliderProps(),\n  emits: {\n    'update:focused': value => true,\n    'update:modelValue': value => true,\n    end: value => true,\n    start: value => true\n  },\n\n  setup(props, _ref) {\n    let {\n      slots,\n      emit\n    } = _ref;\n    const startThumbRef = ref();\n    const stopThumbRef = ref();\n    const inputRef = ref();\n    const {\n      rtlClasses\n    } = useRtl();\n\n    function getActiveThumb(e) {\n      if (!startThumbRef.value || !stopThumbRef.value) return;\n      const startOffset = getOffset(e, startThumbRef.value.$el, props.direction);\n      const stopOffset = getOffset(e, stopThumbRef.value.$el, props.direction);\n      const a = Math.abs(startOffset);\n      const b = Math.abs(stopOffset);\n      return a < b || a === b && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;\n    }\n\n    const steps = useSteps(props);\n    const model = useProxiedModel(props, 'modelValue', undefined, arr => {\n      if (!arr?.length) return [0, 0];\n      return arr.map(value => steps.roundValue(value));\n    });\n    const {\n      activeThumbRef,\n      hasLabels,\n      max,\n      min,\n      mousePressed,\n      onSliderMousedown,\n      onSliderTouchstart,\n      position,\n      trackContainerRef,\n      readonly\n    } = useSlider({\n      props,\n      steps,\n      onSliderStart: () => {\n        emit('start', model.value);\n      },\n      onSliderEnd: _ref2 => {\n        let {\n          value\n        } = _ref2;\n        const newValue = activeThumbRef.value === startThumbRef.value?.$el ? [value, model.value[1]] : [model.value[0], value];\n\n        if (!props.strict && newValue[0] < newValue[1]) {\n          model.value = newValue;\n        }\n\n        emit('end', model.value);\n      },\n      onSliderMove: _ref3 => {\n        let {\n          value\n        } = _ref3;\n        const [start, stop] = model.value;\n\n        if (!props.strict && start === stop && start !== min.value) {\n          activeThumbRef.value = value > start ? stopThumbRef.value?.$el : startThumbRef.value?.$el;\n          activeThumbRef.value?.focus();\n        }\n\n        if (activeThumbRef.value === startThumbRef.value?.$el) {\n          model.value = [Math.min(value, stop), stop];\n        } else {\n          model.value = [start, Math.max(start, value)];\n        }\n      },\n      getActiveThumb\n    });\n    const {\n      isFocused,\n      focus,\n      blur\n    } = useFocus(props);\n    const trackStart = computed(() => position(model.value[0]));\n    const trackStop = computed(() => position(model.value[1]));\n    useRender(() => {\n      const inputProps = VInput.filterProps(props);\n      const hasPrepend = !!(props.label || slots.label || slots.prepend);\n      return _createVNode(VInput, _mergeProps({\n        \"class\": ['v-slider', 'v-range-slider', {\n          'v-slider--has-labels': !!slots['tick-label'] || hasLabels.value,\n          'v-slider--focused': isFocused.value,\n          'v-slider--pressed': mousePressed.value,\n          'v-slider--disabled': props.disabled\n        }, rtlClasses.value, props.class],\n        \"style\": props.style,\n        \"ref\": inputRef\n      }, inputProps, {\n        \"focused\": isFocused.value\n      }), { ...slots,\n        prepend: hasPrepend ? slotProps => _createVNode(_Fragment, null, [slots.label?.(slotProps) ?? (props.label ? _createVNode(VLabel, {\n          \"class\": \"v-slider__label\",\n          \"text\": props.label\n        }, null) : undefined), slots.prepend?.(slotProps)]) : undefined,\n        default: _ref4 => {\n          let {\n            id,\n            messagesId\n          } = _ref4;\n          return _createVNode(\"div\", {\n            \"class\": \"v-slider__container\",\n            \"onMousedown\": !readonly.value ? onSliderMousedown : undefined,\n            \"onTouchstartPassive\": !readonly.value ? onSliderTouchstart : undefined\n          }, [_createVNode(\"input\", {\n            \"id\": `${id.value}_start`,\n            \"name\": props.name || id.value,\n            \"disabled\": !!props.disabled,\n            \"readonly\": !!props.readonly,\n            \"tabindex\": \"-1\",\n            \"value\": model.value[0]\n          }, null), _createVNode(\"input\", {\n            \"id\": `${id.value}_stop`,\n            \"name\": props.name || id.value,\n            \"disabled\": !!props.disabled,\n            \"readonly\": !!props.readonly,\n            \"tabindex\": \"-1\",\n            \"value\": model.value[1]\n          }, null), _createVNode(VSliderTrack, {\n            \"ref\": trackContainerRef,\n            \"start\": trackStart.value,\n            \"stop\": trackStop.value\n          }, {\n            'tick-label': slots['tick-label']\n          }), _createVNode(VSliderThumb, {\n            \"ref\": startThumbRef,\n            \"aria-describedby\": messagesId.value,\n            \"focused\": isFocused && activeThumbRef.value === startThumbRef.value?.$el,\n            \"modelValue\": model.value[0],\n            \"onUpdate:modelValue\": v => model.value = [v, model.value[1]],\n            \"onFocus\": e => {\n              focus();\n              activeThumbRef.value = startThumbRef.value?.$el; // Make sure second thumb is focused if\n              // the thumbs are on top of each other\n              // and they are both at minimum value\n              // but only if focused from outside.\n\n              if (max.value !== min.value && model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== stopThumbRef.value?.$el) {\n                startThumbRef.value?.$el.blur();\n                stopThumbRef.value?.$el.focus();\n              }\n            },\n            \"onBlur\": () => {\n              blur();\n              activeThumbRef.value = undefined;\n            },\n            \"min\": min.value,\n            \"max\": model.value[1],\n            \"position\": trackStart.value,\n            \"ripple\": props.ripple\n          }, {\n            'thumb-label': slots['thumb-label']\n          }), _createVNode(VSliderThumb, {\n            \"ref\": stopThumbRef,\n            \"aria-describedby\": messagesId.value,\n            \"focused\": isFocused && activeThumbRef.value === stopThumbRef.value?.$el,\n            \"modelValue\": model.value[1],\n            \"onUpdate:modelValue\": v => model.value = [model.value[0], v],\n            \"onFocus\": e => {\n              focus();\n              activeThumbRef.value = stopThumbRef.value?.$el; // Make sure first thumb is focused if\n              // the thumbs are on top of each other\n              // and they are both at maximum value\n              // but only if focused from outside.\n\n              if (max.value !== min.value && model.value[0] === model.value[1] && model.value[0] === max.value && e.relatedTarget !== startThumbRef.value?.$el) {\n                stopThumbRef.value?.$el.blur();\n                startThumbRef.value?.$el.focus();\n              }\n            },\n            \"onBlur\": () => {\n              blur();\n              activeThumbRef.value = undefined;\n            },\n            \"min\": model.value[0],\n            \"max\": max.value,\n            \"position\": trackStop.value,\n            \"ripple\": props.ripple\n          }, {\n            'thumb-label': slots['thumb-label']\n          })]);\n        }\n      });\n    });\n    return {};\n  }\n\n});","map":{"version":3,"mappings":"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","names":["makeVInputProps","VInput","VLabel","getOffset","makeSliderProps","useSlider","useSteps","VSliderThumb","VSliderTrack","makeFocusProps","useFocus","useRtl","useProxiedModel","computed","ref","genericComponent","propsFactory","useRender","makeVRangeSliderProps","strict","Boolean","modelValue","type","Array","default","VRangeSlider","name","props","emits","value","end","start","setup","_ref","slots","emit","startThumbRef","stopThumbRef","inputRef","rtlClasses","getActiveThumb","e","startOffset","$el","direction","stopOffset","a","Math","abs","b","steps","model","undefined","arr","length","map","roundValue","activeThumbRef","hasLabels","max","min","mousePressed","onSliderMousedown","onSliderTouchstart","position","trackContainerRef","readonly","onSliderStart","onSliderEnd","_ref2","newValue","onSliderMove","_ref3","stop","focus","isFocused","blur","trackStart","trackStop","inputProps","filterProps","hasPrepend","label","prepend","disabled","class","style","slotProps","_createVNode","_ref4","id","messagesId","v","relatedTarget","onBlur","ripple"],"sources":["../../../src/components/VRangeSlider/VRangeSlider.tsx"],"sourcesContent":["// Styles\nimport '../VSlider/VSlider.sass'\n\n// Components\nimport { makeVInputProps, VInput } from '@/components/VInput/VInput'\nimport { VLabel } from '@/components/VLabel'\nimport { getOffset, makeSliderProps, useSlider, useSteps } from '@/components/VSlider/slider'\nimport { VSliderThumb } from '@/components/VSlider/VSliderThumb'\nimport { VSliderTrack } from '@/components/VSlider/VSliderTrack'\n\n// Composables\nimport { makeFocusProps, useFocus } from '@/composables/focus'\nimport { useRtl } from '@/composables/locale'\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport { computed, ref } from 'vue'\nimport { genericComponent, propsFactory, useRender } from '@/util'\n\n// Types\nimport type { PropType, WritableComputedRef } from 'vue'\nimport type { VSliderSlots } from '../VSlider/VSlider'\n\nexport const makeVRangeSliderProps = propsFactory({\n  ...makeFocusProps(),\n  ...makeVInputProps(),\n  ...makeSliderProps(),\n\n  strict: Boolean,\n  modelValue: {\n    type: Array as PropType<readonly (string | number)[]>,\n    default: () => ([0, 0]),\n  },\n}, 'VRangeSlider')\n\nexport const VRangeSlider = genericComponent<VSliderSlots>()({\n  name: 'VRangeSlider',\n\n  props: makeVRangeSliderProps(),\n\n  emits: {\n    'update:focused': (value: boolean) => true,\n    'update:modelValue': (value: [number, number]) => true,\n    end: (value: [number, number]) => true,\n    start: (value: [number, number]) => true,\n  },\n\n  setup (props, { slots, emit }) {\n    const startThumbRef = ref<VSliderThumb>()\n    const stopThumbRef = ref<VSliderThumb>()\n    const inputRef = ref<VInput>()\n    const { rtlClasses } = useRtl()\n\n    function getActiveThumb (e: MouseEvent | TouchEvent) {\n      if (!startThumbRef.value || !stopThumbRef.value) return\n\n      const startOffset = getOffset(e, startThumbRef.value.$el, props.direction)\n      const stopOffset = getOffset(e, stopThumbRef.value.$el, props.direction)\n\n      const a = Math.abs(startOffset)\n      const b = Math.abs(stopOffset)\n\n      return (a < b || (a === b && startOffset < 0)) ? startThumbRef.value.$el : stopThumbRef.value.$el\n    }\n\n    const steps = useSteps(props)\n\n    const model = useProxiedModel(\n      props,\n      'modelValue',\n      undefined,\n      arr => {\n        if (!arr?.length) return [0, 0]\n\n        return arr.map(value => steps.roundValue(value))\n      },\n    ) as WritableComputedRef<[number, number]> & { readonly externalValue: number[] }\n\n    const {\n      activeThumbRef,\n      hasLabels,\n      max,\n      min,\n      mousePressed,\n      onSliderMousedown,\n      onSliderTouchstart,\n      position,\n      trackContainerRef,\n      readonly,\n    } = useSlider({\n      props,\n      steps,\n      onSliderStart: () => {\n        emit('start', model.value)\n      },\n      onSliderEnd: ({ value }) => {\n        const newValue: [number, number] = activeThumbRef.value === startThumbRef.value?.$el\n          ? [value, model.value[1]]\n          : [model.value[0], value]\n\n        if (!props.strict && newValue[0] < newValue[1]) {\n          model.value = newValue\n        }\n\n        emit('end', model.value)\n      },\n      onSliderMove: ({ value }) => {\n        const [start, stop] = model.value\n\n        if (!props.strict && start === stop && start !== min.value) {\n          activeThumbRef.value = value > start ? stopThumbRef.value?.$el : startThumbRef.value?.$el\n          activeThumbRef.value?.focus()\n        }\n\n        if (activeThumbRef.value === startThumbRef.value?.$el) {\n          model.value = [Math.min(value, stop), stop]\n        } else {\n          model.value = [start, Math.max(start, value)]\n        }\n      },\n      getActiveThumb,\n    })\n\n    const { isFocused, focus, blur } = useFocus(props)\n    const trackStart = computed(() => position(model.value[0]))\n    const trackStop = computed(() => position(model.value[1]))\n\n    useRender(() => {\n      const inputProps = VInput.filterProps(props)\n      const hasPrepend = !!(props.label || slots.label || slots.prepend)\n\n      return (\n        <VInput\n          class={[\n            'v-slider',\n            'v-range-slider',\n            {\n              'v-slider--has-labels': !!slots['tick-label'] || hasLabels.value,\n              'v-slider--focused': isFocused.value,\n              'v-slider--pressed': mousePressed.value,\n              'v-slider--disabled': props.disabled,\n            },\n            rtlClasses.value,\n            props.class,\n          ]}\n          style={ props.style }\n          ref={ inputRef }\n          { ...inputProps }\n          focused={ isFocused.value }\n        >\n          {{\n            ...slots,\n            prepend: hasPrepend ? slotProps => (\n              <>\n                { slots.label?.(slotProps) ?? (\n                  props.label\n                    ? (\n                      <VLabel\n                        class=\"v-slider__label\"\n                        text={ props.label }\n                      />\n                    ) : undefined\n                )}\n\n                { slots.prepend?.(slotProps) }\n              </>\n            ) : undefined,\n            default: ({ id, messagesId }) => (\n              <div\n                class=\"v-slider__container\"\n                onMousedown={ !readonly.value ? onSliderMousedown : undefined }\n                onTouchstartPassive={ !readonly.value ? onSliderTouchstart : undefined }\n              >\n                <input\n                  id={ `${id.value}_start` }\n                  name={ props.name || id.value }\n                  disabled={ !!props.disabled }\n                  readonly={ !!props.readonly }\n                  tabindex=\"-1\"\n                  value={ model.value[0] }\n                />\n\n                <input\n                  id={ `${id.value}_stop` }\n                  name={ props.name || id.value }\n                  disabled={ !!props.disabled }\n                  readonly={ !!props.readonly }\n                  tabindex=\"-1\"\n                  value={ model.value[1] }\n                />\n\n                <VSliderTrack\n                  ref={ trackContainerRef }\n                  start={ trackStart.value }\n                  stop={ trackStop.value }\n                >\n                  {{ 'tick-label': slots['tick-label'] }}\n                </VSliderTrack>\n\n                <VSliderThumb\n                  ref={ startThumbRef }\n                  aria-describedby={ messagesId.value }\n                  focused={ isFocused && activeThumbRef.value === startThumbRef.value?.$el }\n                  modelValue={ model.value[0] }\n                  onUpdate:modelValue={ v => (model.value = [v, model.value[1]]) }\n                  onFocus={ (e: FocusEvent) => {\n                    focus()\n                    activeThumbRef.value = startThumbRef.value?.$el\n\n                    // Make sure second thumb is focused if\n                    // the thumbs are on top of each other\n                    // and they are both at minimum value\n                    // but only if focused from outside.\n                    if (\n                      max.value !== min.value &&\n                      model.value[0] === model.value[1] &&\n                      model.value[1] === min.value &&\n                      e.relatedTarget !== stopThumbRef.value?.$el\n                    ) {\n                      startThumbRef.value?.$el.blur()\n                      stopThumbRef.value?.$el.focus()\n                    }\n                  }}\n                  onBlur={ () => {\n                    blur()\n                    activeThumbRef.value = undefined\n                  }}\n                  min={ min.value }\n                  max={ model.value[1] }\n                  position={ trackStart.value }\n                  ripple={ props.ripple }\n                >\n                  {{ 'thumb-label': slots['thumb-label'] }}\n                </VSliderThumb>\n\n                <VSliderThumb\n                  ref={ stopThumbRef }\n                  aria-describedby={ messagesId.value }\n                  focused={ isFocused && activeThumbRef.value === stopThumbRef.value?.$el }\n                  modelValue={ model.value[1] }\n                  onUpdate:modelValue={ v => (model.value = [model.value[0], v]) }\n                  onFocus={ (e: FocusEvent) => {\n                    focus()\n                    activeThumbRef.value = stopThumbRef.value?.$el\n\n                    // Make sure first thumb is focused if\n                    // the thumbs are on top of each other\n                    // and they are both at maximum value\n                    // but only if focused from outside.\n                    if (\n                      max.value !== min.value &&\n                      model.value[0] === model.value[1] &&\n                      model.value[0] === max.value &&\n                      e.relatedTarget !== startThumbRef.value?.$el\n                    ) {\n                      stopThumbRef.value?.$el.blur()\n                      startThumbRef.value?.$el.focus()\n                    }\n                  }}\n                  onBlur={ () => {\n                    blur()\n                    activeThumbRef.value = undefined\n                  }}\n                  min={ model.value[0] }\n                  max={ max.value }\n                  position={ trackStop.value }\n                  ripple={ props.ripple }\n                >\n                  {{ 'thumb-label': slots['thumb-label'] }}\n                </VSliderThumb>\n              </div>\n            ),\n          }}\n        </VInput>\n      )\n    })\n\n    return {}\n  },\n})\n\nexport type VRangeSlider = InstanceType<typeof VRangeSlider>\n"]},"metadata":{},"sourceType":"module"}